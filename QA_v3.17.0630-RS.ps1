#Requires -Version 2
<#
    QA MASTER SCRIPT
    DO NOT EDIT THIS FILE - ALL CHANGES WILL BE LOST
    THIS FILE IS AUTO-COMPILED FROM SEVERAL SOURCE FILES
    VERSION : v3.17.0630
    COMPILED: 2017/06/30 21:09
#>[CmdletBinding(DefaultParameterSetName = 'HLP')]
Param (
    [Parameter(ParameterSetName='QAC', Mandatory=$true, Position=1)][string[]]$ComputerName,
    [Parameter(ParameterSetName='QAC', Mandatory=$false           )][switch]  $SkipHTMLHelp,
    [Parameter(ParameterSetName='QAC', Mandatory=$false           )][switch]  $GenerateCSV,
    [Parameter(ParameterSetName='QAC', Mandatory=$false           )][switch]  $GenerateXML,
    [Parameter(ParameterSetName='QAC', Mandatory=$false           )][switch]  $DoNotPing,
    [Parameter(ParameterSetName='HLP', Mandatory=$false           )][switch]  $Help
)
Set-StrictMode -Version 2
 
[string]   $version               = "v3.17.0630"
[string]   $settingsFile          = "default-settings.ini"
[hashtable]$script:lang           = @{}
[hashtable]$script:qahelp         = @{}

Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }

[array]$script:qaChecks = ('c-acc-01-local-users','c-acc-02-local-account-names','c-acc-03-local-admins','c-acc-04-local-groups','c-acc-05-service-logon-accounts',
                           'c-acc-06-guest-account','c-acc-07-builtin-group-members-1','c-com-01-mcafee-antivirus-installed','c-com-02-scom-monitoring-installed',
                           'c-com-03-sccm-installed','c-com-04-netbackup-agent-installed','c-com-05-last-patch-date','c-com-06-wsus-server','c-com-09-trend-antivirus-installed',
                           'c-drv-01-system-drive-size','c-drv-02-min-drive-freespace','c-drv-03-pagefile-size-location','c-drv-04-cd-dvd-drive','c-drv-05-shared-folders',
                           'c-drv-06-san-storage','c-drv-07-disk-management-agent','c-drv-08-drive-ntfs-format','c-drv-09-partition-type','c-hvh-01-server-core',
                           'c-hvh-02-no-other-server-roles','c-hvh-03-vm-location','c-hvh-04-integration-services','c-hvh-05-jumbo-frames','c-hvh-06-generation-type',
                           'c-net-01-ipv6-status','c-net-02-unused-network-interfaces','c-net-03-network-adapter-labels','c-net-04-binding-order','c-net-05-network-speed-duplex',
                           'c-net-06-network-agent','c-net-07-network-teaming','c-net-08-management-adapter','c-net-09-static-routes','c-net-10-power-management',
                           'c-net-11-dns-settings','c-net-12-fileprint-services','c-reg-01-local-time','c-reg-02-timezone','c-reg-03-location','c-reg-04-language',
                           'c-sec-01-schannel-p1-ciphers','c-sec-02-schannel-p2-hashes','c-sec-03-schannel-p3-keyexchangealgorithms','c-sec-04-schannel-p4-protocols',
                           'c-sec-05-schannel-p5-cipher-order','c-sec-06-reject-enumerate-accounts','c-sec-07-reject-enumerate-shares','c-sec-08-domain-credential-caching',
                           'c-sec-09-request-admin-elevated','c-sec-10-anonymous-pipe-share-access','c-sec-11-iis-default-page','c-sec-12-smb-signing-on','c-sec-13-rsa-authentication',
                           'c-sec-14-firewall-rules','c-sec-15-firewall-state','c-sec-16-open-ports','c-sec-17-smb1-disabled','c-sys-01-pending-reboot','c-sys-02-windows-license',
                           'c-sys-03-services-not-started','c-sys-04-services-not-stopped','c-sys-05-system-event-log','c-sys-06-application-event-log','c-sys-07-devices-status',
                           'c-sys-09-scheduled-tasks','c-sys-10-print-spooler','c-sys-11-autorun-disabled','c-sys-12-snmp-configuration','c-sys-13-domain-member',
                           'c-sys-14-power-plan','c-sys-15-hibernation','c-sys-16-remote-desktop','c-sys-17-terminal-services-licenced','c-sys-18-check-current-ou',
                           'c-sys-19-hp-smh-version','c-sys-20-dell-oma-version','c-sys-21-gold-image','c-sys-22-installed-services','c-vmw-01-tools-version',
                           'c-vmw-02-time-sync','c-vmw-03-nic-type','c-vmw-04-lsi-sas-controller','c-vmw-05-scsi-drive-count','c-vmw-06-total-vm-size','c-vmw-07-cd-dvd-floppy-mounted',
                           'c-vmw-08-failover-clustering')

##############################################################################################################################################################################################
# QA Check Script Blocks
$cacc01 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseUsers'] = ('Guest', 'ASPNET', '___VMware')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['A'] = 'One or more local accounts exist'
$script:lang['B'] = 'No additional local accounts'
$script:lang['C'] = 'This is a workgroup server, is this correct.?'
$script:lang['Name'] = 'Local Users'
<#
    DESCRIPTION: 
        Check all local users to ensure that no non-standard accounts exist.  Unless the server is not in a domain, there should be no additional user accounts.
        Example standard accounts include "ASPNET", "__VMware"

    REQUIRED-INPUTS:
        IgnoreTheseUsers - List of know user or groups accounts to ignore

    DEFAULT-VALUES:
        IgnoreTheseUsers = ('Guest', 'ASPNET', '___VMware')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No additional local accounts exist
        WARNING:
        FAIL:
            One or more local accounts exist
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-acc-01-local-users
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-01-local-users'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string] $query1 = "SELECT Name FROM Win32_UserAccount WHERE LocalAccount='True'"
        $script:appSettings['IgnoreTheseUsers'] | ForEach { $query1 += ' AND NOT Name LIKE "%{0}%"' -f $_ }
        [array]  $check  = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name

        [string] $query2 = "SELECT PartOfDomain FROM Win32_ComputerSystem"
        [boolean]$domain = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty PartOfDomain
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($domain -eq $true)
    {
        If ($check.Count -gt 0)
        {
            $result.result  = $script:lang['Fail']
            $result.message = $script:lang['A']
            $check | ForEach { $result.data += '{0},#' -f $_ }
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = $script:lang['B']
        }
    }
    Else
    {
        $result.result  = $script:lang['Warning']
        $result.message = $script:lang['C']
    }

    Return $result
}
c-acc-01-local-users -serverName $serverName -resultPath $resultPath
}
$cacc02 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['InvalidAdminNames'] = ('Administrator', 'Admin', 'Guest', 'Guest1')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Local Account Names'
<#
    DESCRIPTION: 
        Checks to see if the default local "Administrator" and "Guest" accounts have been renamed.

    REQUIRED-INPUTS:
        InvalidAdminNames - List of names that should not be used

    DEFAULT-VALUES:
        InvalidAdminNames = ('Administrator', 'Admin', 'Guest', 'Guest1')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All local accounts have been renamed
        WARNING:
        FAIL:
            A local account was found that needs to be renamed
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-acc-02-local-account-names
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-02-local-account-names'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Name FROM Win32_UserAccount WHERE LocalAccount="True"'
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $accsFound = 0
    ForEach ($acc In $check)
    {
        $script:appSettings['InvalidAdminNames'] | ForEach {
            If ($acc -like $_)
            {
                $accsFound += 1
                $result.data += '{0},#' -f $acc
            }
        }
    }

    If ($accsFound -gt 0)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'A local account was found that needs to be renamed'
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Local accounts have been renamed'
    }
    
    Return $result
}
c-acc-02-local-account-names -serverName $serverName -resultPath $resultPath
}
$cacc03 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseUsers'] = ('Domain Admins', 'Enterprise Admins')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Local Admins'
<#
    DESCRIPTION: 
        Check the local administrators group to ensure no non-standard accounts exist.
        If there is a specific application requirement for local administration access then these need to be well documented.

    REQUIRED-INPUTS:
        IgnoreTheseUsers - List of know user or groups accounts to ignore

    DEFAULT-VALUES:
        IgnoreTheseUsers = ('Domain Admins', 'Enterprise Admins')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No local administrators found
        WARNING:
            This is a workgroup server, is this correct.?
        FAIL:
            One or more local administrator accounts exist
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-acc-03-local-admins
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-03-local-admins'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string] $query  = "SELECT PartOfDomain FROM Win32_ComputerSystem"
        [boolean]$domain = Get-WmiObject -ComputerName $serverName -Query $query  -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty PartOfDomain

        [string]$query1  = 'SELECT * FROM Win32_Group WHERE SID="S-1-5-32-544" AND LocalAccount="True"'
        [object]$object1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2

        [string]$query2  = "SELECT PartComponent FROM Win32_GroupUser WHERE GroupComponent=`"Win32_Group.Domain='$serverName',Name='$($object1.Name)'`""
        [object]$object2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2

        [System.Collections.ArrayList]$members = @()
        $object2 | ForEach { 
            [string]$item = (($_.PartComponent).Split('"')[3])
            If (-not $script:appSettings['IgnoreTheseUsers'].Contains($item)) { $members += $item }
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }
 
    If ($domain -eq $true)
    {
        If ($members.count -gt 0)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more local administrator accounts exist'
            $members | ForEach { $result.data += '{0},#' -f $_ }
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'No local administrators found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Warning']
        $result.message = 'This is a workgroup server, is this correct.?'
    }

    Return $result
}
c-acc-03-local-admins -serverName $serverName -resultPath $resultPath
}
$cacc04 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseUsers'] = ('Allowed RODC Password Replication Group', 'Cert Publishers', 'ConfigMgr Remote Control Users', 'Denied RODC Password Replication Group', 'DHCP', 'DnsAdmins', 'HelpServicesGroup', 'IIS_WPG', 'Offer Remote Assistance Helpers', 'Pre-Windows 2000 Compatible Access', 'RAS and IAS Servers', 'TelnetClients', 'WinRMRemoteWMIUsers__', 'SQLServer', 'RSABypass')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Local Groups'
<#
    DESCRIPTION: 
        Check all local groups and ensure no additional groups exist. If there is a specific application requirement for local groups then these need to be documented with a designated team specified as the owner.
        If you use specific role groups, make sure they are excluded in the settings file.

    REQUIRED-INPUTS:
        IgnoreTheseUsers - List of known user or groups accounts to ignore

    DEFAULT-VALUES:
        IgnoreTheseUsers = ('Allowed RODC Password Replication Group', 'Cert Publishers', 'ConfigMgr Remote Control Users', 'Denied RODC Password Replication Group', 'DHCP', 'DnsAdmins', 'HelpServicesGroup', 'IIS_WPG', 'Offer Remote Assistance Helpers', 'Pre-Windows 2000 Compatible Access', 'RAS and IAS Servers', 'TelnetClients', 'WinRMRemoteWMIUsers__', 'SQLServer', 'RSABypass')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No additional local accounts
        WARNING:
        FAIL:
            One or more local groups exist
        MANUAL:
        NA:
            Server is a domain controller

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-DomainController
#>

Function c-acc-04-local-groups
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-04-local-groups'

    #... CHECK STARTS HERE ...#

    Try
    {
        If ((Check-DomainController $serverName) -eq $false)
        {
            [string]$query = 'SELECT Name, SID FROM Win32_Group WHERE LocalAccount="True" AND NOT SID LIKE "S-1-5-32-%"'
            $script:appSettings['IgnoreTheseUsers'] | ForEach { $query += ' AND NOT Name LIKE "%{0}%"' -f $_ }
            [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
        }
        Else
        {
            [array]$check = '!!DCignore'
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        If ($check[0] -eq '!!DCignore')
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'Server is a domain controller'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more local groups exist'
            $check | ForEach { $result.data += '{0},#' -f $_ }
        }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No additional local accounts'
    }
    Return $result
}
Function Check-DomainController
{
    Param ([string]$ServerName)
    Try {
        $query = "SELECT DomainRole FROM Win32_ComputerSystem"
        $check = Get-WmiObject -ComputerName $ServerName -Query $query -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object DomainRole
        If ($check.DomainRole -eq 4 -or $check.DomainRole -eq 5) { Return $true } }
    Catch { Return $false }
    Return $false
}
c-acc-04-local-groups -serverName $serverName -resultPath $resultPath
}
$cacc05 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseUsers'] = ('NT AUTHORITY\\NetworkService', 'NT AUTHORITY\\LocalService', 'LocalSystem')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Service Logon Accounts'
<#
    DESCRIPTION: 
        Checks all services to ensure no user accounts are assigned.
        If specific application service accounts are required then they should be domain level accounts (not local) and restricted from interactice access by policy.

    REQUIRED-INPUTS:
        IgnoreTheseUsers - List of known user or groups accounts to ignore

    DEFAULT-VALUES:
        IgnoreTheseUsers = ('NT AUTHORITY\\NetworkService', 'NT AUTHORITY\\LocalService', 'LocalSystem')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No services found running under a local accounts
        WARNING:
        FAIL:
            One or more services was found to be running under local accounts
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-acc-05-service-logon-accounts
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-05-service-logon-accounts'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DisplayName, StartName FROM Win32_Service WHERE NOT DisplayName=""'
        $script:appSettings['IgnoreTheseUsers'] | ForEach { $query += ' AND NOT StartName = "{0}"' -f $_ }
        [object]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object DisplayName, StartName
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Warning']
        $result.message = 'One or more services was found to be running under local accounts'
        $check | ForEach { $result.data += '{0} ({1}),#' -f $_.DisplayName, $_.StartName }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No services found running under a local accounts'
    }
    
    Return $result
}
c-acc-05-service-logon-accounts -serverName $serverName -resultPath $resultPath
}
$cacc06 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Guest Account'
<#
    DESCRIPTION: 
        Checks to make sure that the guest user account has been disabled.  The guest account is located via the well known SID.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Guest account is disabled
        WARNING:
        FAIL:
            Guest account has not been disabled
        MANUAL:
        NA:
            Guest account does not exist

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-acc-06-guest-account
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-06-guest-account'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Name, Disabled FROM Win32_UserAccount WHERE LocalAccount="True" AND SID LIKE "%-501"'    # Local Guest account SID always ends in '-501'
        [object]$guest = Get-WmiObject  -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, Disabled
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($guest) -eq $true)
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Guest account does not exist'
    }
    Else
    {
        If ($guest.Disabled -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Guest account is disabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Guest account has not been disabled'
            $result.data    = $guest.Name
        }
    }

    Return $result
}
c-acc-06-guest-account -serverName $serverName -resultPath $resultPath
}
$cacc07 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['AllMustExist'] = 'False'
$script:appSettings['GroupMembers'] = ('Domain Admins')
$script:appSettings['GroupName'] = 'Remote Desktop Users'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Built-In Group Members (1 of 3)'
<#
    DESCRIPTION: 
        Checks the builtin group memberships to make sure specific users or groups are members.  If there is only one entry in "GroupMembers", then "AllMustExist" will be set to "TRUE".
        !nThis is check 1 of 3 that can be used to check different groups.

    REQUIRED-INPUTS:
        AllMustExist - "True|False" - Do all group members need to exist for a "Pass"
        GroupMembers - List of users or groups that should listed as a member
        GroupName    - Local group name to check

    DEFAULT-VALUES:
        AllMustExist = 'False'
        GroupMembers = ('Domain Admins')
        GroupName    = 'Remote Desktop Users'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No additional users exist
            Additional users exist
        WARNING:
            Invalid group name
        FAIL:
            Additional users exist
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-acc-07-builtin-group-members-1
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-07-builtin-group-members-1'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query     = "SELECT * FROM Win32_Group WHERE Name='$($script:appSettings['GroupName'])' AND LocalAccount='True'"
        [object]$WMIObject = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2

        If ([string]::IsNullOrEmpty($WMIObject) -eq $false)
        {
            [array]$check1 = $WMIObject.GetRelated('Win32_Account', 'Win32_GroupUser', '', '', 'PartComponent', 'GroupComponent', $false, $null) | Select-Object -ExpandProperty Name

            [array]$check2 = @()    # GROUP MEMBERSHIP list
            [array]$check3 = @()    # CHECK NAME list
            ForEach ($Item In $check1) { If ($script:appSettings['GroupMembers'] -notcontains $Item) { $check2 += $Item } }
            If ([string]::IsNullOrEmpty($script:appSettings['GroupMembers']) -eq $false) {
                ForEach ($Item In $script:appSettings['GroupMembers']) { If ($check1 -notcontains $Item) { $check3 += $Item } }
            }

            $check2 = ($check2 | Select-Object -Unique)
            If (($check2.Count -eq 0) -and ($check3.Count -eq 0))
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'No additional users exist'
                $result.data    = $script:appSettings['GroupName']
            }
            Else
            {
                If (($script:appSettings['GroupMembers'].Count) -eq 1) { $script:appSettings['AllMustExist'] = 'True' }
                If  ($script:appSettings['AllMustExist'] -eq 'True')
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = 'Additional users exist'
                    $result.data    = "$($script:appSettings['GroupName']),#In Group: $($check2 -join ', '),#In Check: $($check3 -join ', ')"
                }
                Else
                {
                    $result.result  = $script:lang['Pass']
                    $result.message = 'Additional users exist'
                    $result.data    = "$($script:appSettings['GroupName']),#In Group: $($check2 -join ', '),#In Check: $($check3 -join ', ')"
                }
            }
        }
        Else
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'Invalid group name'
            $result.data    = $script:appSettings['GroupName']
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Return $result
}
c-acc-07-builtin-group-members-1 -serverName $serverName -resultPath $resultPath
}
$cacc08 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['AllMustExist'] = 'False'
$script:appSettings['GroupMembers'] = ('')
$script:appSettings['GroupName'] = ''
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Built-In Group Members (2 of 3)'
<#
    DESCRIPTION: 
        Checks the builtin group memberships to make sure specific users or groups are members.  If there is only one entry in "GroupMembers", then "AllMustExist" will be set to "TRUE".
        !nThis is check 2 of 3 that can be used to check different groups.

    REQUIRED-INPUTS:
        AllMustExist - "True|False" - Do all group members need to exist for a "Pass"
        GroupMembers - List of users or groups that should listed as a member
        GroupName    - Local group name to check

    DEFAULT-VALUES:
        AllMustExist = 'False'
        GroupMembers = ('')
        GroupName    = ''

    DEFAULT-STATE:
        Skip

    RESULTS:
        PASS:
            No additional users exist
            Additional users exist
        WARNING:
            Invalid group name
        FAIL:
            Additional users exist
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-acc-08-builtin-group-members-2
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-07-builtin-group-members-2'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query     = "SELECT * FROM Win32_Group WHERE Name='$($script:appSettings['GroupName'])' AND LocalAccount='True'"
        [object]$WMIObject = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2

        If ([string]::IsNullOrEmpty($WMIObject) -eq $false)
        {
            [array]$check1 = $WMIObject.GetRelated('Win32_Account', 'Win32_GroupUser', '', '', 'PartComponent', 'GroupComponent', $false, $null) | Select-Object -ExpandProperty Name

            [array]$check2 = @()    # GROUP MEMBERSHIP list
            [array]$check3 = @()    # CHECK NAME list
            ForEach ($Item In $check1) { If ($script:appSettings['GroupMembers'] -notcontains $Item) { $check2 += $Item } }
            If ([string]::IsNullOrEmpty($script:appSettings['GroupMembers']) -eq $false) {
                ForEach ($Item In $script:appSettings['GroupMembers']) { If ($check1 -notcontains $Item) { $check3 += $Item } }
            }

            $check2 = ($check2 | Select-Object -Unique)
            If (($check2.Count -eq 0) -and ($check3.Count -eq 0))
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'No additional users exist'
                $result.data    = $script:appSettings['GroupName']
            }
            Else
            {
                If (($script:appSettings['GroupMembers'].Count) -eq 1) { $script:appSettings['AllMustExist'] = 'True' }
                If  ($script:appSettings['AllMustExist'] -eq 'True')
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = 'Additional users exist'
                    $result.data    = "$($script:appSettings['GroupName']),#In Group: $($check2 -join ', '),#In Check: $($check3 -join ', ')"
                }
                Else
                {
                    $result.result  = $script:lang['Pass']
                    $result.message = 'Additional users exist'
                    $result.data    = "$($script:appSettings['GroupName']),#In Group: $($check2 -join ', '),#In Check: $($check3 -join ', ')"
                }
            }
        }
        Else
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'Invalid group name'
            $result.data    = $script:appSettings['GroupName']
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Return $result
}
c-acc-08-builtin-group-members-2 -serverName $serverName -resultPath $resultPath
}
$cacc09 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['AllMustExist'] = 'False'
$script:appSettings['GroupMembers'] = ('')
$script:appSettings['GroupName'] = ''
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Built-In Group Members (3 of 3)'
<#
    DESCRIPTION: 
        Checks the builtin group memberships to make sure specific users or groups are members.  If there is only one entry in "GroupMembers", then "AllMustExist" will be set to "TRUE".
        !nThis is check 3 of 3 that can be used to check different groups.

    REQUIRED-INPUTS:
        AllMustExist - "True|False" - Do all group members need to exist for a "Pass"
        GroupMembers - List of users or groups that should listed as a member
        GroupName    - Local group name to check

    DEFAULT-VALUES:
        AllMustExist = 'False'
        GroupMembers = ('')
        GroupName    = ''

    DEFAULT-STATE:
        Skip

    RESULTS:
        PASS:
            No additional users exist
            Additional users exist
        WARNING:
            Invalid group name
        FAIL:
            Additional users exist
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-acc-09-builtin-group-members-3
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-09-builtin-group-members-3'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query     = "SELECT * FROM Win32_Group WHERE Name='$($script:appSettings['GroupName'])' AND LocalAccount='True'"
        [object]$WMIObject = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2

        If ([string]::IsNullOrEmpty($WMIObject) -eq $false)
        {
            [array]$check1 = $WMIObject.GetRelated('Win32_Account', 'Win32_GroupUser', '', '', 'PartComponent', 'GroupComponent', $false, $null) | Select-Object -ExpandProperty Name

            [array]$check2 = @()    # GROUP MEMBERSHIP list
            [array]$check3 = @()    # CHECK NAME list
            ForEach ($Item In $check1) { If ($script:appSettings['GroupMembers'] -notcontains $Item) { $check2 += $Item } }
            If ([string]::IsNullOrEmpty($script:appSettings['GroupMembers']) -eq $false) {
                ForEach ($Item In $script:appSettings['GroupMembers']) { If ($check1 -notcontains $Item) { $check3 += $Item } }
            }

            $check2 = ($check2 | Select-Object -Unique)
            If (($check2.Count -eq 0) -and ($check3.Count -eq 0))
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'No additional users exist'
                $result.data    = $script:appSettings['GroupName']
            }
            Else
            {
                If (($script:appSettings['GroupMembers'].Count) -eq 1) { $script:appSettings['AllMustExist'] = 'True' }
                If  ($script:appSettings['AllMustExist'] -eq 'True')
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = 'Additional users exist'
                    $result.data    = "$($script:appSettings['GroupName']),#In Group: $($check2 -join ', '),#In Check: $($check3 -join ', ')"
                }
                Else
                {
                    $result.result  = $script:lang['Pass']
                    $result.message = 'Additional users exist'
                    $result.data    = "$($script:appSettings['GroupName']),#In Group: $($check2 -join ', '),#In Check: $($check3 -join ', ')"
                }
            }
        }
        Else
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'Invalid group name'
            $result.data    = $script:appSettings['GroupName']
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Return $result
}
c-acc-09-builtin-group-members-3 -serverName $serverName -resultPath $resultPath
}
$ccom01 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['MaximumDATAgeAllowed'] = '7'
$script:appSettings['ProductName'] = 'McAfee VirusScan Enterprise'
$script:appSettings['ProductVersion'] = '8.8'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'McAfee AV Installed'
<#
    DESCRIPTION: 
        Check that McAfee anti-virus is installed and virus definitions are up to date.

    REQUIRED-INPUTS:
        MaximumDATAgeAllowed - Maximum number of days that DATs are allowed to be out of date|Integer
        ProductName          - Full name of the McAfee product
        ProductVersion       - Current version of the product that you are using|Decimal

    DEFAULT-VALUES:
        MaximumDATAgeAllowed = '7'
        ProductName          = 'McAfee VirusScan Enterprise'
        ProductVersion       = '8.8'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            McAfee product found, DATs are OK
        WARNING:
        FAIL:
            McAfee product not found, install required
            DATs are not up-to-date
            No DAT version found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-Software
#>

Function c-com-01-mcafee-antivirus-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-01-mcafee-antivirus-installed'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$verCheck = Check-Software -serverName $serverName -displayName $script:appSettings['ProductName']
        If ($verCheck -eq '-1') { Throw 'Error opening registry key' }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($verCheck) -eq $false)
    {
        [string]$verNeed  = $script:appSettings['ProductVersion']

        # Check AV Version
        If ($verCheck -ge $verNeed)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'McAfee product  found, '
            $result.data    = 'Version {0}, ' -f $verCheck
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'McAfee product found, but wrong version, '
            $result.data    = 'Version {0} found. Expected version: {1},#' -f $verCheck, $script:appSettings['ProductVersion']
        }

        # Check DAT Update date
        Try
        {
            [datetime]$dtVal = '01/01/1901'
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('Software\Wow6432Node\McAfee\AVEngine')
            If ($regKey) { $dtVal = $regKey.GetValue('AVDatDate') }
            Try {$regKey.Close() } Catch {}
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($dtVal -ne '01/01/1901')
        {
            $days = ((Get-Date) - $dtVal).Days
            If ($days -le $script:appSettings['MaximumDATAgeAllowed'])
            {
                $result.result   = $script:lang['Pass']
                $result.message += 'DATs are OK'
                $result.data    += 'DATs {0} day(s) old' -f $days.ToString()
            }
            Else
            {
                $result.result   = $script:lang['Fail']
                $result.message += 'DATs are not up-to-date'
                $result.data    += 'DATs {0} day(s) old' -f $days.ToString()
            }
        }
        Else
        {
            $result.result   = $script:lang['Fail']
            $result.message += 'No DAT version found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = '{0} not found, install required' -f $script:appSettings['ProductName']
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Check-Software
{
    Param ([string]$ServerName, [string]$DisplayName)
    Try {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() } }
    Catch { Return '-1' }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } } }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Check-Software -ServerName $serverName -DisplayName $displayName }
            Else { $verCheck = $null } } }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
c-com-01-mcafee-antivirus-installed -serverName $serverName -resultPath $resultPath
}
$ccom02 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductNames'] = ('Microsoft Monitoring Agent', 'System Center Operations Manager', 'Operations Manager Agent')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Monitoring Installed'
<#
    DESCRIPTION: 
        Check relevant monitoring tool agent is installed and that the correct port is open to the management server.

    REQUIRED-INPUTS:
        ProductNames - List of SCOM agent product names to search for

    DEFAULT-VALUES:
        ProductNames = ('Microsoft Monitoring Agent', 'System Center Operations Manager', 'Operations Manager Agent')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            {product} found, Port {port} open to {server}
        WARNING:
        FAIL:
            Monitoring software not found, install required
            {product} found, agent not configured with port and/or servername
            {product} found, port {port} not open to {server}
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-Port
        Check-Software
#>

Function c-com-02-scom-monitoring-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-02-scom-monitoring-installed'

    #... CHECK STARTS HERE ...#

    Try
    {
        [boolean]$found = $false
        $script:appSettings['ProductNames'] | ForEach {
            [string]$verCheck = Check-Software -serverName $serverName -displayName $_
            If ($verCheck -eq '-1') { Throw 'Error open registry key' }
            If ([string]::IsNullOrEmpty($verCheck) -eq $false)
            {
                $found            = $true
                [string]$prodName = $_
                [string]$prodVer  = $verCheck
            }
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('Software\Microsoft\Microsoft Operations Manager\3.0\Agent Management Groups')
        If ($regKey) {
            [string[]]$regSubKey = $regKey.GetSubKeyNames()
            If ($regSubKey.Count -gt 0) {
                $regKey = $null
                $regKey = $reg.OpenSubKey("Software\Microsoft\Microsoft Operations Manager\3.0\Agent Management Groups\$($regSubKey[0])\Parent Health Services\0")
                If ($regkey) {
                    [string]$valName = $regKey.GetValue('NetworkName')
                    [string]$valPort = $regKey.GetValue('Port')
                }
            }
        }
        Try {$regKey.Close() } Catch {}
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($found -eq $true)
    {
        If (([string]::IsNullOrEmpty($valName) -eq $false) -and ([string]::IsNullOrEmpty($valPort) -eq $false))
        {
            [boolean]$portTest = (Check-Port -serverName $valName -Port $valPort)
            If ($portTest -eq $true)
            {
                $result.result  = $script:lang['Pass']
                $result.message = '{0} found' -f $prodName
                $result.data    = 'Version {0},#Port {1} open to {2}' -f $prodVer, $valPort, $valName.ToLower()
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = '{0} found' -f $prodName
                $result.data    = 'Version {0},#Port {1} not open to {2}' -f $prodVer, $valPort, $valName.ToLower()
            }
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = '{0} found' -f $prodName
            $result.data    = 'Version {0},#Agent not configured with port and/or servername' -f $prodVer
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Monitoring software not found, install required'
    }

    Return $result
}
Function Check-Port
{
    Param ([string]$ServerName, [string]$Port)
    Try {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($ServerName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
    } } Catch { Return $false }
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Check-Software
{
    Param ([string]$ServerName, [string]$DisplayName)
    Try {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() } }
    Catch { Return '-1' }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } } }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Check-Software -ServerName $serverName -DisplayName $displayName }
            Else { $verCheck = $null } } }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
c-com-02-scom-monitoring-installed -serverName $serverName -resultPath $resultPath
}
$ccom03 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'SCCM Installed'
<#
    DESCRIPTION: 
        Check relevant SCCM agent process is running, and that the correct port is open to the management server.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            SCCM agent found, port {port} open to {server}
        WARNING:
        FAIL:
            SCCM agent found, agent not configured with port and/or servername
            SCCM agent found, port {port} not open to {server}
            SCCM agent not found, install required
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-Port
#>

Function c-com-03-sccm-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-03-sccm-installed'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Name FROM Win32_Process WHERE Name="CcmExec.exe"'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('Software\Microsoft\CCM')
        If ($regKey) {
            [string]               $valPort = $regKey.GetValue('Port')           # SCCM 2007
            [string]               $valName = $regKey.GetValue('NetworkName')    # SCCM 2007
            If ($valPort -eq '') { $valPort = $regKey.GetValue('HttpsPort') }    # SCCM 2010+
            If ($valName -eq '') { $valName = $regKey.GetValue('SMSSLP')    }    # SCCM 2010+

            # Fall back check for hostname check
            If ($valName -eq '') {
                $regKey  = $reg.OpenSubKey('Software\Microsoft\CCM\FSP')
                If ($regKey) { $valName = $regKey.GetValue('HostName') }
            }
        }
        Try {$regKey.Close() } Catch {}
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($check) -eq $false)
    {
        If (([string]::IsNullOrEmpty($valName) -eq $false) -and ([string]::IsNullOrEmpty($valPort) -eq $false))
        {
            [boolean]$portTest = (Check-Port -serverName $valName -Port $valPort)
            If ($portTest -eq $true)
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'SCCM agent found'
                $result.data    = 'Port {0} open to {1}' -f $valPort, $valName.ToLower()
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'SCCM agent found'
                $resilt.data    = 'Port {0} not open to {1}' -f $valPort, $valName.ToLower()
            }
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'SCCM agent found'
            $result.data    = 'Agent not configured with port and/or servername'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'SCCM agent not found, install required'
    }

    Return $result
}
Function Check-Port
{
    Param ([string]$ServerName, [string]$Port)
    Try {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($ServerName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
    } } Catch { Return $false }
}
c-com-03-sccm-installed -serverName $serverName -resultPath $resultPath
}
$ccom04 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductName'] = 'Symantec NetBackup'
$script:appSettings['RequiredServerRoles'] = ('Exchange', 'SQL')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'NetBackup Agent Installed'
<#
    DESCRIPTION: 
        Check NetBackup agent is installed and that the correct port is open to the management server.
        Only applies to physical servers, or virtual servers with a list of known software installed.

    REQUIRED-INPUTS:
        ProductName         - Full name of the product to look for
        RequiredServerRoles - List of known software to check if installed

    DEFAULT-VALUES:
        ProductName         = 'Symantec NetBackup'
        RequiredServerRoles = ('Exchange', 'SQL')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            {product} found, Port 1556 open to {server}
        WARNING:
        FAIL:
            {product} not found
            Port 1556 not open to {server}
            Backup agent software not found, but this server has {role} installed which requires it
            Backup agent software not found, but this server is a domain controller which requires it
        MANUAL:
            Is this server backed up via VADP.?  Manually check vCenter annotations, and look for "NetBackup.VADP: 1"
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-DomainController
        Check-VMware
        Check-HyperV
        Check-Port
        Check-Software
#>

Function c-com-04-netbackup-agent-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-04-netbackup-agent-installed'
    
    #... CHECK STARTS HERE ...#

    [string]$verCheck = (Check-Software -serverName $serverName -displayName $script:appSettings['ProductName'])
    If ($verCheck -eq '-1') { Throw 'Error opening registry key' }
    If ([string]::IsNullOrEmpty($verCheck) -eq $false)
    {
        $result.result  = $script:lang['Pass']
        $result.message = '{0} found'     -f $script:appSettings['ProductName']
        $result.data    = 'Version {0},#' -f $verCheck

        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('Software\Veritas\NetBackup\CurrentVersion\Config')
            If ($regKey) { [string[]]$valNames = $regKey.GetValue('Server') }
            Try {$regKey.Close()} Catch {}
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        ForEach ($server In $valNames)
        {
            [boolean]$portTest = (Check-Port -serverName $server -Port 1556)
            If   ($portTest -eq $true)                   { $result.data += ('Port 1556 open to {0},#'     -f $server.ToLower()) }
            Else { $result.result = $script:lang['Fail'];  $result.data += ('Port 1556 not open to {0},#' -f $server.ToLower()) }
        }
    }
    Else
    {
        If (((Check-VMware $serverName) -eq $true) -or ((Check-HyperV $serverName) -eq $true))
        {
            # If backup software not installed, and is a VM, then check for additional software to see if it should be installed
            $found = $false
            $script:appSettings['RequiredServerRoles'] | ForEach {
                [string]$verExist = Check-Software -serverName $serverName -displayName $_
                If ($verCheck -eq '-1') { Throw 'Error opening registry key' }
                If ([string]::IsNullOrEmpty($verCheck) -eq $false)
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = '{0} not found' -f $script:appSettings['ProductName']
                    $result.data    = 'Backup agent software not found, but this server has {0} installed which requires it' -f $_
                    $found          = $true
                }
            }

            If ((Check-DomainController $serverName) -eq $true)
            {
                $result.result  = $script:lang['Fail']
                $result.message = '{0} not found' -f $script:appSettings['ProductName']
                $result.data    = 'Backup agent software not found, but this server is a domain controller which requires it'
                $found          = $true
            }

            If ($found -eq $false)
            {
                $result.result  = $script:lang['Manual']
                $result.message = '{0} not found, VADP backup.?' -f $script:appSettings['ProductName']
                $result.data    = 'Is this server backed up via VADP.?  Manually check vCenter annotations, and look for "NetBackup.VADP: 1"'
            }
        }
        Else
        {
            # Physical server
            $result.result  = $script:lang['Fail']
            $result.message = '{0} not found' -f $script:appSettings['ProductName']
            $result.data    = ''
        }
    }
    
    Return $result
}
Function Check-DomainController
{
    Param ([string]$ServerName)
    Try {
        $query = "SELECT DomainRole FROM Win32_ComputerSystem"
        $check = Get-WmiObject -ComputerName $ServerName -Query $query -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object DomainRole
        If ($check.DomainRole -eq 4 -or $check.DomainRole -eq 5) { Return $true } }
    Catch { Return $false }
    Return $false
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
Function Check-HyperV
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}
Function Check-Port
{
    Param ([string]$ServerName, [string]$Port)
    Try {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($ServerName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
    } } Catch { Return $false }
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Check-Software
{
    Param ([string]$ServerName, [string]$DisplayName)
    Try {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() } }
    Catch { Return '-1' }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } } }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Check-Software -ServerName $serverName -DisplayName $displayName }
            Else { $verCheck = $null } } }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
c-com-04-netbackup-agent-installed -serverName $serverName -resultPath $resultPath
}
$ccom05 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['MaximumLastPatchAgeAllowed'] = '35'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Patching Compliant'
<#
    DESCRIPTION: 
        Check server is compliant with patch policy (must be patched to latest released patch level for this customer).
        Check date of last patch and return WARNING if not within specified number of days, and FAIL if not within number of days *2.

    REQUIRED-INPUTS:
        MaximumLastPatchAgeAllowed - Mamimum number of days that patching is allowed to be out of date|Integer

    DEFAULT-VALUES:
        MaximumLastPatchAgeAllowed = '35'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Windows patches applied
        WARNING:
            Server not patched within the last {num} days
            Operating system not supported by check
        FAIL:
            Server not patched within the last {num} days
            No last patch date - server has never been updated
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-com-05-last-patch-date
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-05-last-patch-date'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Caption FROM Win32_OperatingSystem'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption

        If ($check -notlike '*2003*')
        {
            $session  = [activator]::CreateInstance([type]::GetTypeFromProgID('Microsoft.Update.Session', $serverName)) 
            $searcher = $session.CreateUpdateSearcher()
            $history  = $searcher.GetTotalHistoryCount()
            If ($history -gt 0) { [datetime]$check = $searcher.QueryHistory(0, 1) | Select-Object -ExpandProperty Date } Else { [datetime]$check = 0 }
        }
        Else
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'Operating system not supported by check'
            $result.data    = ''
            Return $result
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check -ne 0)
    {
        [int]$days = ((Get-Date) - $check).Days
        If ($days -gt ($script:appSettings['MaximumLastPatchAgeAllowed'] * 2))
        {
            # 2 months (using default setting)
            $result.result  = $script:lang['Fail']
            $result.message = 'Server not patched within the last {0} days' -f ($script:appSettings['MaximumLastPatchAgeAllowed'] * 2)
            $result.data    = 'Last patched: {0} ({1} days ago)' -f $check, $days
        }
        ElseIf ($days -gt $script:appSettings['MaximumLastPatchAgeAllowed'])
        {
            # 1 month (using default setting)
            $result.result  = $script:lang['Warning']
            $result.message = 'Server not patched within the last {0} days' -f $script:appSettings['MaximumLastPatchAgeAllowed']
            $result.data    = 'Last patched: {0} ({1} days ago)' -f $check, $days
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Windows patches applied'
            $result.data    = 'Last patched: {0} ({1} days ago)' -f $check, $days
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'No last patch date - server has never been updated'
    }

    Return $result
}
c-com-05-last-patch-date -serverName $serverName -resultPath $resultPath
}
$ccom06 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'WSUS Server Setting'
<#
    DESCRIPTION: 
        Check that a WSUS server has been specified and that the correct port is open to the management server.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            WSUS server configured, port {port} open to {server}
        WARNING:
        FAIL:
            WSUS server configured, port {port} not open to {server}
            WSUS server has not been configured
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-Port
#>

Function c-com-06-wsus-server
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-06-wsus-server'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('Software\Policies\Microsoft\Windows\WindowsUpdate')
        If ($regKey) { [string]$keyVal = ($regKey.GetValue('WUServer')).ToLower() }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'WSUS server configured'
        $result.data    = $keyVal

        $keyVal = $keyVal.Replace('http://', '').Replace('https://', '')
        If ($keyVal.Contains(':') -eq $true) { [string]$name = ($keyVal.Split(':')[0]); [string]$port = $keyVal.Split(':')[1] }
        Else {                                 [string]$name =  $keyVal;                [string]$port = 80                    }

        [boolean]$portTest = (Check-Port -serverName $name -Port $port)
        If   ($portTest -eq $true) {                   $result.data += (',#Port {0} open to {1}'     -f $port, $name.ToLower()) }
        Else { $result.result = $script:lang['Fail'];  $result.data += (',#Port {0} not open to {1}' -f $port, $name.ToLower()) }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'WSUS server has not been configured'
    }

    Return $result
}
Function Check-Port
{
    Param ([string]$ServerName, [string]$Port)
    Try {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($ServerName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
    } } Catch { Return $false }
}
c-com-06-wsus-server -serverName $serverName -resultPath $resultPath
}
$ccom07 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Sentinel Agent Installed'
<#
    DESCRIPTION: 
        Check sentinel monitoring agent is installed, and that the correct port is open to the management server.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Skip

    RESULTS:
        PASS:
            Sentinel agent found, port {port} open to {server}
        WARNING:
        FAIL:
            Sentinel agent found, port {port} not open to {server}
            Sentinel agent not found, install required
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-Software
        Check-Port
#>

Function c-com-07-sentinel-agent-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-07-sentinel-agent-installed'

    #... CHECK STARTS HERE ...#

    [string]$verCheck = Check-Software -serverName $serverName -displayName 'NetIQ Sentinel Agent'
    If ($verCheck -eq '-1') { Throw 'Error opening registry key' }
    If ([string]::IsNullOrEmpty($verCheck) -eq $false)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Sentinel agent found'
        $result.data    = 'Version {0},#' -f $verCheck

        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('Software\Wow6432Node\NetIQ\Security Manager\Configurations')
            If ($regKey) { [string[]]$regAgt = ($regKey.GetSubKeyNames()) }
            Try {$regKey.Close() } Catch {}

            $regKey = $reg.OpenSubKey("Software\Wow6432Node\NetIQ\Security Manager\Configurations\$($regAgt[0])\Operations\Agent\Consolidators")
            If ($regKey) {
                [array]$valCons = @()
                ForEach ($key In (0..9))
                {
                    $valCons += $(New-Object -TypeName PSObject -Property @{'host' = $($regKey.GetValue("Consolidator $key Host")); `
                                                                            'port' = $($regKey.GetValue("Consolidator $key Port")); } )
                }
            }
            Try {$regKey.Close() } Catch {}
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        ForEach ($key In (0..9))
        {
            If ([string]::IsNullOrEmpty($($valCons[$key].host)) -eq $false)
            {
                $portTest = Check-Port -serverName $($valCons[$key].host) -Port $($valCons[$key].port)
                If ($portTest -eq $true) { $result.data += ('Port {0} open to {1}'     -f $($valCons[$key].port), $($valCons[$key].host.ToLower()))                                        }
                Else                     { $result.data += ('Port {0} not open to {1}' -f $($valCons[$key].port), $($valCons[$key].host.ToLower())); $result.result = $script:lang['Fail'] }
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Sentinel agent not found, install required'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Check-Software
{
    Param ([string]$ServerName, [string]$DisplayName)
    Try {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() } }
    Catch { Return '-1' }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } } }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Check-Software -ServerName $serverName -DisplayName $displayName }
            Else { $verCheck = $null } } }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Check-Port
{
    Param ([string]$ServerName, [string]$Port)
    Try {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($ServerName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
    } } Catch { Return $false }
}
c-com-07-sentinel-agent-installed -serverName $serverName -resultPath $resultPath
}
$ccom08 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['CustomerCode'] = 'ACME'
$script:appSettings['ListeningPort'] = '4750'
$script:appSettings['LocalAccount'] = 'Administrator'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'BladeLogic Agent Installed'
<#
    DESCRIPTION: 
        Check BladeLogic monitoring agent is installed, and that the correct port is listening.
        Also check that the USERS.LOCAL file is configured correctly.

    REQUIRED-INPUTS:
        ListeningPort - Port number that the agent listens on|Integer
        CustomerCode  - Customer name found in USERS.LOCAL: ACME_L3AdminW:* rw,map=Administrator
        LocalAccount  - Mapped account name found in USERS.LOCAL: ACME_L3AdminW:* rw,map=Administrator

    DEFAULT-VALUES:
        ListeningPort = '4750'
        CustomerCode  = 'ACME'
        LocalAccount  = 'Administrator'

    DEFAULT-STATE:
        Skip

    RESULTS:
        PASS:
            BladeLogic agent found, and file confgiured
        WARNING:
        FAIL:
            BladeLogic agent not found, install required
            Required port not listening
            USERS.LOCAL not configured
            USERS.LOCAL not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-Software
#>

Function c-com-08-bladelogic-agent-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-08-bladelogic-agent-installed'

    #... CHECK STARTS HERE ...#

    [string]$verCheck = Check-Software -serverName $serverName -displayName 'BMC BladeLogic Server Automation RSCD Agent'
    If ($verCheck -eq '-1') { Throw 'Error opening registry key' }
    If ([string]::IsNullOrEmpty($verCheck) -eq $false)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'BladeLogic agent found'
        $result.data    = 'Version {0},#' -f $verCheck

        Try
        {
            # Check for listening port...
            [boolean]$found = $false
            $TCPProperties = [System.Net.NetworkInformation.IPGlobalProperties]::GetIPGlobalProperties()
            [System.Net.IPEndPoint[]]$Connections = $TCPProperties.GetActiveTcpListeners()
            ForEach ($Port In $Connections) { If ($($Port.Port) -eq $script:appSettings['ListeningPort']) { $found = $true } }

            If ($found -eq $true)
            {
                $result.data += 'Port {0} is listening,#' -f $script:appSettings['ListeningPort']
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.data   += 'Port {0} not listening,#' -f $script:appSettings['ListeningPort']
            }

            # Check USER.LOCAL configuration file
            If ((Test-Path -Path "\\$serverName\admin$\rsc\users.local") -eq $true)
            {
                [boolean] $found = $false
                [string[]]$file  = (Get-Content -Path "\\$serverName\admin$\rsc\users.local")
                ForEach ($line In $file) { If (($line.StartsWith($script:appSettings['CustomerCode']) -eq $true) -and ($line.EndsWith($script:appSettings['LocalAccount']) -eq $true)) { $found = $true } }

                If ($found -eq $true)
                {
                    $result.data += 'USERS.LOCAL configured correctly'
                }
                Else
                {
                    $result.result  = $script:lang['Fail']
                    $result.data   += 'USERS.LOCAL not configured'
                }
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.data   += 'USERS.LOCAL not found, or ADMIN$ share not enabled'
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'BladeLogic agent not found, install required'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Check-Software
{
    Param ([string]$ServerName, [string]$DisplayName)
    Try {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() } }
    Catch { Return '-1' }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } } }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Check-Software -ServerName $serverName -DisplayName $displayName }
            Else { $verCheck = $null } } }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
c-com-08-bladelogic-agent-installed -serverName $serverName -resultPath $resultPath
}
$ccom09 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DATPathLocation'] = 'C:\Program Files (x86)\Trend Micro\OfficeScan Client\'
$script:appSettings['MaximumDATAgeAllowed'] = '7'
$script:appSettings['ProductName'] = 'Trend Micro OfficeScan Client'
$script:appSettings['ProductVersion'] = '10.6'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Trend AV Installed'
<#
    DESCRIPTION: 
        Check that Trend anti-virus is installed and virus definitions are up to date.

    REQUIRED-INPUTS:
        MaximumDATAgeAllowed - Maximum number of days that DATs are allowed to be out of date|Integer
        ProductName          - Full name of the Trend product
        ProductVersion       - Current version of the product that you are using|Decimal
        DATPathLocation      - Full path location of the DAT location|File

    DEFAULT-VALUES:
        MaximumDATAgeAllowed = '7'
        ProductName          = 'Trend Micro OfficeScan Client'
        ProductVersion       = '10.6'
        DATPathLocation      = 'C:\Program Files (x86)\Trend Micro\OfficeScan Client\'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Trend product found, DATs are OK
        WARNING:
        FAIL:
            Trend product not found, install required
            DATs are not up-to-date
            No DAT version found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-Software
#>

Function c-com-09-trend-antivirus-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-09-trend-antivirus-installed'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$verCheck = Check-Software -serverName $serverName -displayName $script:appSettings['ProductName']
        If ($verCheck -eq '-1') { Throw 'Error opening registry key' }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($verCheck) -eq $false)
    {
        [string]$verNeed  = $script:appSettings['ProductVersion']

        # Check AV Version
        If ($verCheck -ge $verNeed)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Trend product found, '
            $result.data    = 'Version {0}, ' -f $verCheck
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Trend product found, but wrong version, '
            $result.data    = 'Version {0} found. Expected version: {1},#' -f $verCheck, $script:appSettings['ProductVersion']
        }

        # Check DAT Update date
        Try
        {
            [string]$datName = 'icrc$oth.*'
            $script:appSettings['DATPathLocation'] = $script:appSettings['DATPathLocation'].Replace(':', '$')
            If (Test-Path -Path "\\$serverName\$($script:appSettings['DATPathLocation'])\")
            {
                [datetime]$dtVal = '01/01/1901'
                $dtVal = (Get-ItemProperty -Path "\\$serverName\$($script:appSettings['DATPathLocation'])\$datName" | Sort-Object LastWriteTime | Select-Object -Last 1).LastWriteTime

                If ($dtVal -ne '01/01/1901')
                {
                    $days = ((Get-Date) - $dtVal).Days
                    If ($days -le $script:appSettings['MaximumDATAgeAllowed'])
                    {
                        $result.result   = $script:lang['Pass']
                        $result.message += 'DATs are OK'
                        $result.data    += 'DATs {0} day(s) old' -f $days.ToString()
                    }
                    Else
                    {
                        $result.result   = $script:lang['Fail']
                        $result.message += 'DATs are not up-to-date'
                        $result.data    += 'DATs {0} day(s) old' -f $days.ToString()
                    }
                }
            }
            Else
            {
                $result.result   = $script:lang['Fail']
                $result.message += 'No DAT version found'
            }
        }
        Catch
        {
            $result.result   = $script:lang['Fail']
            $result.message += 'No DAT version found'
        }

        # Get master server name
        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('Software\Wow6432Node\TrendMicro\PC-cillinNTCorp\CurrentVersion\Internet Settings')
            If ($regKey) {
                [string]$regVal1 = $regKey.GetValue('Server')
                [string]$regVal2 = $regKey.GetValue('ServerPort')
            }
            Try {$regKey.Close() } Catch {}
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If (($regVal1 -ne '') -and ($regVal2 -ne '')) { $result.data += "Master Server: $regVal1 : $regVal2" }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = '{0} not found, install required' -f $script:appSettings['ProductName']
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Check-Software
{
    Param ([string]$ServerName, [string]$DisplayName)
    Try {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() } }
    Catch { Return '-1' }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } } }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Check-Software -ServerName $serverName -DisplayName $displayName }
            Else { $verCheck = $null } } }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
c-com-09-trend-antivirus-installed -serverName $serverName -resultPath $resultPath
}
$cdrv01 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['MinimumSystemDriveSize'] = '49'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'System Drive Size'
<#
    DESCRIPTION: 
        Check the system drive is a minimum size of 50gb for Windows 2008+ servers (some are reporting 49gb).
        
    REQUIRED-INPUTS:
        MinimumSystemDriveSize - Minimum size of the system drive|Integer

    DEFAULT-VALUES:
        MinimumSystemDriveSize = '49'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            System drive ({letter}) meets minimum required size
        WARNING:
        FAIL:
            System drive ({letter}) is too small, should be {size}gb
        MANUAL:
            Unable to get drive size, please check manually
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-drv-01-system-drive-size
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-drv-01-system-drive-size'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query1 = 'SELECT SystemDrive FROM Win32_OperatingSystem'
        [string]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty SystemDrive
        If ([string]::IsNullOrEmpty($check1) -eq $false)
        {
            [string]$query2 = 'SELECT Size FROM Win32_LogicalDisk WHERE Name = "{0}"' -f $check1
            [string]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Size
            [int]   $sizeGB = [decimal]::Round(($check2 / (1024*1024*1024)))
        }
        Else
        {
            [int]$sizeGB = -1
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($sizeGB -ne -1)
    {
        If ($sizeGB -ge $script:appSettings['MinimumSystemDriveSize'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'System drive ({0}) meets minimum required size' -f $check1
            $result.data    = 'Size: {0}gb' -f $sizeGB
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'System drive ({0}) is too small, should be {1}gb' -f $check1, $script:appSettings['MinimumSystemDriveSize']
            $result.data    = 'Size: {0}gb' -f $sizeGB
        }
    }
    Else
    {
        $result.result  = $script:lang['Manual']
        $result.message = 'Unable to get drive size, please check manually'
        $result.data    = 'System drive needs to be {0}gb or larger' -f $script:appSettings['MinimumSystemDriveSize']
    }

    Return $result
}
c-drv-01-system-drive-size -serverName $serverName -resultPath $resultPath
}
$cdrv02 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseDrives'] = ('A', 'B')
$script:appSettings['MinimumDrivePercentFree'] = '17'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Min Drive % Freespace'
<#
    DESCRIPTION: 
        Ensure all drives have a minimum amount of free space.  Measured as a percentage.

    REQUIRED-INPUTS:
        IgnoreTheseDrives       - List of drive letters to ignore
        MinimumDrivePercentFree - Minimum free space available on each drive as a percentage|Integer

    DEFAULT-VALUES:
        IgnoreTheseDrives       = ('A', 'B')
        MinimumDrivePercentFree = '17'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All drives have the required minimum free space of {size}%
        WARNING:
        FAIL:
            One or more drives were found with less than {size}% free space
        MANUAL:
            Unable to get drive information, please check manually
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-drv-02-min-drive-freespace
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-drv-02-min-drive-freespace'
 
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT * FROM Win32_LogicalDisk WHERE DriveType = "3"'    # Filter on DriveType = 3 (Fixed Drives)
        $script:appSettings['IgnoreTheseDrives'] | ForEach { $query += ' AND NOT Name = "{0}"' -f $_ }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, FreeSpace, Size
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $countFailed = 0
    If ($check -ne $null)
    {
        ForEach ($drive In $check)
        {
            $free = $drive.FreeSpace
            $size = $drive.Size
            If ($size -ne $null)
            {
                $percentFree  = [decimal]::Round(($free / $size) * 100)
                $result.data += $drive.Name + ' (' + $percentFree + '% free),#'
                If ($percentFree -lt $script:appSettings['MinimumDrivePercentFree']) { $countFailed += 1 }
            }
        }
    
        If ($countFailed -ne 0)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more drives were found with less than ' + $script:appSettings['MinimumDrivePercentFree'] + '% free space'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All drives have the required minimum free space of ' + $script:appSettings['MinimumDrivePercentFree'] + '%'
        }
    }
    Else
    {
        $result.result  = $script:lang['Manual']
        $result.message = 'Unable to get drive information, please check manually'
        $result.data    = 'All drives need to have ' + $script:appSettings['MinimumDrivePercentFree'] + '% or more free'
    }
    Return $result
}
c-drv-02-min-drive-freespace -serverName $serverName -resultPath $resultPath
}
$cdrv03 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['FixedPageFileSize'] = '4096'
$script:appSettings['PageFileLocation'] = 'C:\'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Pagefile Location & Size'
<#
    DESCRIPTION: 
        Check the page file is located on the system drive and is a fixed size.  The default setting is 4096MB (4GB).
        If the page file is larger a document detailing the tuning process used must exist and should follow Microsoft best tuning practices (http://support.microsoft.com/kb/2021748).

    REQUIRED-INPUTS:
        FixedPageFileSize - Fixed size in MB of the page file|Integer
        PageFileLocation  - Drive location of the page file

    DEFAULT-VALUES:
        FixedPageFileSize = '4096'
        PageFileLocation  = 'C:\'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Pagefile is set correctly
        WARNING: 
        FAIL:
            Pagefile is system managed
            Pagefile is not set correctly
        MANUAL:
            Unable to get page file information, please check manually
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-drv-03-pagefile-size-location
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-drv-03-pagefile-size-location'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]  $query1 = 'SELECT Name, InitialSize, MaximumSize FROM Win32_PageFileSetting'
        [string]  $query2 = 'SELECT AutomaticManagedPagefile FROM Win32_ComputerSystem'
        [object[]]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2                               | Select-Object Name, InitialSize, MaximumSize
        [string]  $check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 -ErrorAction SilentlyContinue | Select-Object -ExpandProperty AutomaticManagedPagefile
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check2 -eq $true)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Pagefile is system managed'
        $result.data    = ''    # Set below
    }
    Else
    {
        If (($check1 -eq $null) -and ($check2 -eq $false))
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Unable to get page file information, please check manually'
            $result.data    = ''    # Set below
        }
        ElseIf ($check1 -ne $null)
        {
            If (($check1[0].MaximumSize -eq $script:appSettings['FixedPageFileSize']) -and ($check1[0].InitialSize -eq $script:appSettings['FixedPageFileSize']) -and ($check1[0].Name.ToLower().StartsWith($script:appSettings['PageFileLocation'].ToLower())))
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'Pagefile is set correctly'
                $result.data    = 'Location: {0},#Fixed Size: {1}mb' -f $script:appSettings['PageFileLocation'], $script:appSettings['FixedPageFileSize']
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Pagefile is not set correctly'
                $result.data    = 'Location: {0},#Initial Size: {1}mb, Maximum Size: {2}mb' -f $check1[0].Name, $check1[0].InitialSize, $check1[0].MaximumSize
            }
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Pagefile does not exist on {0} drive' -f $script:appSettings['PageFileLocation']
            $result.data    = ''    # Set below
        }
    }

    If ($result.data -eq '')
    {
        $result.message += ',#It should be: location: {0}, fixed Size: {1}mb' -f $script:appSettings['PageFileLocation'], $script:appSettings['FixedPageFileSize']
        $result.data = ('It should be set as follows,#A fixed custom size of {0}mb and located on the {1} drive' -f $script:appSettings['FixedPageFileSize'], $script:appSettings['PageFileLocation'])
    }

    Return $result
}
c-drv-03-pagefile-size-location -serverName $serverName -resultPath $resultPath
}
$cdrv04 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DVDDriveLetter'] = 'R:'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'CD/DVD Drive Letter'
<#
    DESCRIPTION: 
        If a CD/DVD drive is present on the server confirm it is configured as "R:".

    REQUIRED-INPUTS:
        DVDDriveLetter - Drive letter of the CD/DVD drive

    DEFAULT-VALUES:
        DVDDriveLetter = 'R:'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            CD/DVD drive set correctly
        WARNING:
        FAIL:
            CD/DVD drive found, but not configured as {letter}
        MANUAL:
        NA:
            No CD/DVD drives found

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-drv-04-cd-dvd-drive
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-drv-04-cd-dvd-drive'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DeviceID FROM Win32_LogicalDisk WHERE DriveType="5"'    # DriveType 5 is CD/DVD Drive
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty DeviceID
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If (($check.Count -eq 0 ) -or ([string]::IsNullOrEmpty($check) -eq $true))
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'No CD/DVD drives found'
    }
    Else
    {
        [boolean]$found = $false
        $check | ForEach {
            If ($_ -eq $script:appSettings['DVDDriveLetter']) { $found = $true }
            $result.data += '{0},#' -f $_
        }

        If ($found -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'CD/DVD drive set correctly'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'CD/DVD drive found, but not configured as {0}' -f $script:appSettings['DVDDriveLetter']
        }
    }

    Return $result
}
c-drv-04-cd-dvd-drive -serverName $serverName -resultPath $resultPath
}
$cdrv05 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseShares'] = ('NETLOGON', 'SYSVOL', 'CertEnroll')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Shared Folders'
<#
    DESCRIPTION: 
        Check shared folders to ensure no additional shares are present.  Shared folders should be documented with a designated team specified as the owner.

    REQUIRED-INPUTS:
        IgnoreTheseShares - List of share names that can be ignored

    DEFAULT-VALUES:
        IgnoreTheseShares = ('NETLOGON', 'SYSVOL', 'CertEnroll')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No additional shares found
        WARNING:
            Shared folders found, check against documentation
        FAIL:
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-drv-05-shared-folders
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-drv-05-shared-folders'

    #... CHECK STARTS HERE ...#

    Try
    {   #                                                              Admin Shares         IPC Share
        [string]$query = "SELECT Name FROM Win32_Share WHERE NOT(Type='2147483648' OR Type='2147483651') AND NOT Name=''"
        If ($script:appSettings['IgnoreTheseShares'].Count -gt 0)
        {
            For ($i = 0; $i -lt $script:appSettings['IgnoreTheseShares'].Count; $i++)
            {
                $query += " AND NOT Name='" + $script:appSettings['IgnoreTheseShares'][$i] + "'"
            }
        }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Warning']
        $result.message = 'Shared folders found, check against documentation'
        $check | ForEach { $result.data += '{0},#' -f $_ }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No additional shares found'
    }
    
    Return $result
}
c-drv-05-shared-folders -serverName $serverName -resultPath $resultPath
}
$cdrv06 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductNames'] = ('HDLM GUI', 'SANsurfer', 'Emulex FC')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'SAN Storage Software'
<#
    DESCRIPTION: 
        Where SAN storage is used, ensure multipathing software is installed and Dual Paths are present and functioning.
        This only checks that known software is installed.  A manual check must be done to ensure it is configured correctly.

    REQUIRED-INPUTS:
        ProductNames - List of software to check if installed

    DEFAULT-VALUES:
        ProductNames = ('HDLM GUI', 'SANsurfer', 'Emulex FC')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
        WARNING:
        FAIL:
            SAN storage software not found, install required
        MANUAL:
            {product} found
        NA:
            Not a physical machine

    APPLIES:
        Physical Servers

    REQUIRED-FUNCTIONS:
        Check-Software
        Check-VMware
        Check-HyperV
#>

Function c-drv-06-san-storage
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-drv-06-san-storage'
    
    #... CHECK STARTS HERE ...#

    If (((Check-VMware $serverName) -eq $false) -and ((Check-HyperV $serverName) -eq $false))
    {
        [string]$query = 'SELECT Caption FROM Win32_OperatingSystem'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption

        If ($check -like '*201*')
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'Windows 2012 and above use native multipathing'
        }
        Else
        {
            Try
            {
                [boolean]$found = $false
                $script:appSettings['ProductNames'] | ForEach {
                    [string]$verCheck = Check-Software -serverName $serverName -displayName $_
                    If ($verCheck -eq '-1') { Throw 'Error opening registry key' }
                    If ([string]::IsNullOrEmpty($verCheck) -eq $false)
                    {
                        $found            = $true
                        [string]$prodName = $_
                        [string]$prodVer  = $verCheck
                    }
                }
            }
            Catch
            {
                $result.result  = $script:lang['Error']
                $result.message = $script:lang['Script-Error']
                $result.data    = $_.Exception.Message
                Return $result
            }        

            If ($found -eq $true)
            {
                $result.result  = $script:lang['Manual']
                $result.message = '{0} found'   -f $prodName
                $result.data    = 'Version {0}' -f $prodVer
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'SAN storage software not found, install required'
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a physical machine'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Check-Software
{
    Param ([string]$ServerName, [string]$DisplayName)
    Try {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() } }
    Catch { Return '-1' }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } } }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Check-Software -ServerName $serverName -DisplayName $displayName }
            Else { $verCheck = $null } } }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
Function Check-HyperV
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}
c-drv-06-san-storage -serverName $serverName -resultPath $resultPath
}
$cdrv07 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductNames'] = ('HP Array Configuration Utility', 'Dell OpenManage Server Administrator', 'Broadcom Drivers And Management Applications')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Disk Management Agent'
<#
    DESCRIPTION: 
        Check local disk array management agent is installed on the server.
        This only checks that known software is installed.  A manual check must be done to ensure it is configured correctly.

    REQUIRED-INPUTS:
        ProductNames - List of sofware to check if installed

    DEFAULT-VALUES:
        ProductNames = ('HP Array Configuration Utility', 'Dell OpenManage Server Administrator', 'Broadcom Drivers And Management Applications')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
        WARNING:
        FAIL:
            Disk management software not found, install required
        MANUAL:
            {product} found
        NA:
            Not a physical machine

    APPLIES:
        Physical Servers

    REQUIRED-FUNCTIONS:
        Check-Software
        Check-VMware
        Check-HyperV
#>

Function c-drv-07-disk-management-agent
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-drv-07-disk-management-agent'
    
    #... CHECK STARTS HERE ...#

    If (((Check-VMware $serverName) -eq $false) -and ((Check-HyperV $serverName) -eq $false))
    {
        Try
        {
            [boolean]$found = $false
            $script:appSettings['ProductNames'] | ForEach {
                [string]$verCheck = Check-Software -serverName $serverName -displayName $_
                If ($verCheck -eq '-1') { Throw 'Error opening registry key' }
                If ([string]::IsNullOrEmpty($verCheck) -eq $false)
                {
                    $found            = $true
                    [string]$prodName = $_
                    [string]$prodVer  = $verCheck
                }
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }        

        If ($found -eq $true)
        {
            $result.result  = $script:lang['Manual']
            $result.message = '{0} found'   -f $prodName
            $result.data    = 'Version {0}' -f $prodVer
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Disk management software not found, install required'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a physical machine'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Check-Software
{
    Param ([string]$ServerName, [string]$DisplayName)
    Try {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() } }
    Catch { Return '-1' }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } } }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Check-Software -ServerName $serverName -DisplayName $displayName }
            Else { $verCheck = $null } } }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
Function Check-HyperV
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}
c-drv-07-disk-management-agent -serverName $serverName -resultPath $resultPath
}
$cdrv08 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Drives NTFS format'
<#
    DESCRIPTION: 
        Ensure all drives are formatted as NTFS.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All drives are formatted as NTFS
        WARNING:
        FAIL:
            One or more drives were found not formatted as NTFS
        MANUAL:
            Unable to get drive information, please check manually
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-drv-08-drive-ntfs-format
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-drv-08-drive-ntfs-format'
 
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT *  FROM Win32_LogicalDisk WHERE DriveType = "3"'    # Filter on DriveType=3 (Fixed Drives)
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, FileSystem
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $countFailed = 0
    $result.data = ''
    If ($check -ne $null)
    {
        $check | ForEach {
            If ($_.FileSystem -ne 'NTFS')
            {
                If ($_.FileSystem -eq $null) { $_.FileSystem = 'Not Formatted' }
                $result.data += '{0} ({1}),#' -f $_.Name, $_.FileSystem
                $countFailed += 1
            }
        }
    
        If ($countFailed -ne 0)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more drives were found not formatted as NTFS'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All drives are formatted as NTFS'
        }
    }
    Else
    {
        $result.result  = $script:lang['Manual']
        $result.message = 'Unable to get drive information, please check manually'
        $result.data    = 'All drives need to be formatted as NTFS'
    }
    Return $result
}
c-drv-08-drive-ntfs-format -serverName $serverName -resultPath $resultPath
}
$cdrv09 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreOffline'] = 'True'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Drive Partition Type'
<#
    DESCRIPTION: 
        Ensure all drives types are set to BASIC and with a partition style of MBR.

    REQUIRED-INPUTS:
        IgnoreOffline - "True|False" - Ignore any drives that are marked as offline

    DEFAULT-VALUES:
        IgnoreOffline = 'True'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All drive types are BASIC, with partition styles of MBR
        WARNING:
        FAIL:
            One or more partition styles are not MBR
            One or more drives types are not BASIC
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-drv-09-partition-type
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-drv-09-partition-type'
 
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Name, Type FROM Win32_DiskPartition WHERE (NOT Type = "Installable File System")'
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, Type
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        [int]$gptA = 0; [int]$gptB = 0; [int]$gptC = 0; [array]$data = @()
        ForEach ($part In $check)
        {
            If (($part.Type).StartsWith('GPT: Basic'))   {                                                         $gptA++; $data += ($($part.Name).Split(',')[0])   }    # BASIC   + GPT
            If (($part.Type).StartsWith('GPT: Logical')) {                                                         $gptC++; $data += ($($part.Name).Split(',')[0])   }    # DYNAMIC + GPT
            If (($part.Type).StartsWith('Logical'))      {                                                         $gptB++; $data += ($($part.Name).Split(',')[0])   }    # DYNAMIC + MBR
            If (($part.Type).StartsWith('GPT: Unknown')) { If ($script:appSettings['IgnoreOffline'] -eq 'False') { $gptD++; $data += ($($part.Name).Split(',')[0]) } }    # OFFLINE + GPT
        }

        $result.result  = $script:lang['Fail']
        $result.data    = (($data | Select-Object -Unique) -join ', ')

        If (($gptA -gt 0) -or ($gptC -gt 0)) { $result.message += 'One or more partition styles are not MBR,#' }
        If (($gptB -gt 0) -or ($gptC -gt 0)) { $result.message += 'One or more drives types are not BASIC,#'   }
        If  ($gptD -gt 0)                    { $result.message += 'One of more drives are unknown'             }

        If ($script:appSettings['IgnoreOffline'] -eq 'True') { $result.message += 'Ignoring unknown drive types' }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All drive types are BASIC, with partition styles of MBR'
        $result.data    = $_.Exception.Message
    }

    Return $result
}
c-drv-09-partition-type -serverName $serverName -resultPath $resultPath
}
$chvh01 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Server Core'
<#
    DESCRIPTION: 
        Check Hyper-V is installed on Windows Server Core.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Hyper-V is using Windows Server Core
        WARNING:
        FAIL:
            Hyper-V is not using Windows Server Core
        MANUAL:
        NA:
            Not a Hyper-V server

    APPLIES:
        Hyper-V Host Servers

    REQUIRED-FUNCTIONS:
        Check-NameSpace
#>

Function c-hvh-01-server-core
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-hvh-01-server-core'
 
    #... CHECK STARTS HERE ...#

    If ((Check-NameSpace -ServerName $serverName -NameSpace 'ROOT\Virtualization') -eq $true)
    {
        Try
        {
            [string]$query = 'SELECT Name FROM Win32_ServerFeature WHERE Name = "Server Graphical Shell"'
            [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name

            If ($check.Trim() -eq 'Server Graphical Shell')
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Hyper-V is not using Windows Server Core'
            }
            Else
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'Hyper-V is using Windows Server Core'
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Hyper-V host server'
    }

    Return $result
}
Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-hvh-01-server-core -serverName $serverName -resultPath $resultPath
}
$chvh02 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseRoleIDs'] = ('20', '33', '67', '340', '417', '466', '477', '481', '487')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'No Other Server Roles'
<#
    DESCRIPTION: 
        Check Hyper-V is the only one installed.  See this list for IDs: https://msdn.microsoft.com/en-us/library/cc280268(v=vs.85).aspx

    REQUIRED-INPUTS:
        IgnoreTheseRoleIDs - List of IDs that can be ignored|Integer

    DEFAULT-VALUES:
        IgnoreTheseRoleIDs = ('20', '33', '67', '340', '417', '466', '477', '481', '487')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No extra server roles or features exist
        WARNING:
        FAIL:
            One or more extra server roles or features exist
        MANUAL:
        NA:
            Not a Hyper-V server

    APPLIES:
        Hyper-V Host Servers

    REQUIRED-FUNCTIONS:
        Check-NameSpace
#>

Function c-hvh-02-no-other-server-roles
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-hvh-02-no-other-server-roles'
 
    #... CHECK STARTS HERE ...#

    If ((Check-NameSpace -ServerName $serverName -NameSpace 'ROOT\Virtualization') -eq $true)
    {
        Try
        {
            [string]$queryOS = 'SELECT Caption FROM Win32_OperatingSystem'
            [string]$checkOS = Get-WmiObject -ComputerName $serverName -Query $queryOS -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption

            If ($check -like '*2008')        # 2008
            {
                [string]$query = "Select Name, ID FROM Win32_ServerFeature WHERE ParentID = '0'"
                [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2
            }
            ElseIf ($check -like '*201*')    # 2012, 2016
            {
                [array]$check = (Get-WindowsFeature | Where-Object { ($_.InstallState -eq 'Installed') -and ($_.Depth -eq 1) } |
                                                      Select-Object @{N='Id'; E={$_.AdditionalInfo.NumericId}}) |
                                                      Select-Object -ExpandProperty Id
            }
            Else
            {
                Throw 'Operating system not supported'
            }

            [System.Collections.ArrayList]$check2 = @()
            $check | ForEach { $check2 += $_ }

            ForEach ($ck In $check)
            {
                ForEach ($exc In $script:appSettings['IgnoreTheseRoleIDs'])
                {
                    If ($ck.ID -eq $exc) { $check2.Remove($ck) }
                }
            }

        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check2.Count -ne 0)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more extra server roles or features exist'
            $check2 | ForEach { $result.data += '{0},#' -f $_.Name }
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'No extra server roles or features exist'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Hyper-V host server'
    }

    Return $result
}
Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-hvh-02-no-other-server-roles -serverName $serverName -resultPath $resultPath
}
$chvh03 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'VM Location'
<#
    DESCRIPTION: 
        Check all VMs are running from a non-system drive.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No virtual machines are using the system drive
        WARNING:
        FAIL:
            One or more virtual machines are using the system drive
        MANUAL:
        NA:
            Not a Hyper-V server
            No virtual machines exist on this host

    APPLIES:
        Hyper-V Host Servers

    REQUIRED-FUNCTIONS:
        Check-NameSpace
#>

Function c-hvh-03-vm-location
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-hvh-03-vm-location'
 
    #... CHECK STARTS HERE ...#

    If ((Check-NameSpace -ServerName $serverName -NameSpace 'ROOT\Virtualization') -eq $true)
    {
        Try
        {
            [string]$query = 'SELECT * FROM Msvm_ComputerSystem WHERE Caption="Virtual Machine"'
            [object]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Virtualization\v2
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check.Count -ne 0)
        {
            [string]$result.data = ''
            ForEach ($vm In $check)
            {
                $VSSD = Get-WmiObject -ComputerName $serverName -Query "SELECT * FROM Msvm_VirtualSystemSettingData     WHERE ConfigurationID =              '$($VM.Name)'"  -Namespace ROOT\Virtualization\v2
                $SASD = Get-WmiObject -ComputerName $serverName -Query "SELECT * FROM Msvm_StorageAllocationSettingData WHERE      InstanceID LIKE 'Microsoft:$($VM.Name)%'" -Namespace ROOT\Virtualization\v2

                # Check config location
                If ((-not $($VSSD.ConfigurationDataRoot).StartsWith("$env:SystemDrive\ClusterStorage\")) -and ($($VSSD.ConfigurationDataRoot) -eq $env:SystemDrive))
                {
                    $result.data += '{0}: Configuration,#' -f $VM.ElementName
                }

                # Check hard disk location(s)
                ForEach ($SA In $SASD)
                {
                    [int]   $driveNum  = $(($SA.Parent).Split('\')[11])
                    [string]$drivePath = $SA.HostResource[$driveNum]
                    If ((-not ($drivePath.StartsWith("$env:SystemDrive\ClusterStorage\"))) -and (-not ($drivePath.ToLower()).EndsWith('.iso')))
                    {
                        $result.data += '{0}: Disk {1},#' -f $VM.ElementName, $SA.HostResource[$driveNum]
                    }
                }
            }

            If ($result.data -ne '')
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'One or more virtual machines are using the system drive'
            }
            Else
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'No virtual machines are using the system drive'
            }
        }
        Else
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'No virtual machines exist on this host'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Hyper-V host server'
    }

    Return $result
}
Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-hvh-03-vm-location -serverName $serverName -resultPath $resultPath
}
$chvh04 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Integration Services'
<#
    DESCRIPTION: 
        Check the version of the Integration Services installed on all VMs

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:    
            All VMs are up to date
        WARNING:
        FAIL:
            One or more VMs are not up to date, or do not have the integration services installed
        MANUAL:
        NA:
            No VMs are located on this host
            Not a Hyper-V server

    APPLIES:
        Hyper-V Host Servers

    REQUIRED-FUNCTIONS:
        Check-NameSpace
#>

Function c-hvh-04-integration-services
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-hvh-04-integration-services'
 
    #... CHECK STARTS HERE ...#

    If ((Check-NameSpace -ServerName $serverName -NameSpace 'ROOT\Virtualization') -eq $true)
    {
        Try
        {
            [string]$query = 'SELECT * FROM Msvm_ComputerSystem WHERE Caption="Virtual Machine"'
            [object]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Virtualization\v2
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check.Count -ne 0)
        {
            [string]$result.data = ''
            ForEach ($vm In $check)
            {
                $VSMS = Get-WmiObject -Class 'Msvm_VirtualSystemManagementService' -Namespace ROOT\Virtualization\v2
                $Info = $VSMS.GetSummaryInformation($vm.__PATH, 123)

                Switch ($Info.SummaryInformation[0].IntegrationServicesVersionState)
                {
                    '0' { $result.data += "$($vm.ElementName): Unknown,#"     }    # Unknown
                    '1' { $result.data += ''                                  }    # Up To Date
                    '2' { $result.data += "$($vm.ElementName): Out of date,#" }    # Out Of Date
                }
            }

            If ($result.data -ne '')
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'One or more VMs are not up to date, or do not have the integration services installed'
            }
            ELse
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'All VMs are up to date'
            }
        }
        Else
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'No VMs are located on this host'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Hyper-V host server'
    }

    Return $result
}
Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-hvh-04-integration-services -serverName $serverName -resultPath $resultPath
}
$chvh05 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseAdapters'] = ('')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Jumbo Frames Enabled'
<#
    DESCRIPTION: 
        Check the network adapter jumbo frame setting.  Should be set to 9000 or more.

    REQUIRED-INPUTS:
        IgnoreTheseAdapters - List of adapters to ignore this setting for

    DEFAULT-VALUES:
        IgnoreTheseAdapters = ('')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All network adapters configured correctly
        WARNING:
        FAIL:
            One or more network adapters are not using Jumbo Frames
            No network adapters found or enabled
        MANUAL:
        NA:

    APPLIES:
        Hyper-V Host Servers

    REQUIRED-FUNCTIONS:
        Check-NameSpace
#>

Function c-hvh-05-jumbo-frames
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-hvh-05-jumbo-frames'

    #... CHECK STARTS HERE ...#

    If ((Check-NameSpace -ServerName $serverName -NameSpace 'ROOT\Virtualization') -eq $true)
    {
        Try
        {
            [string]$query = 'SELECT * FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled = "True"'
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check.Count -gt 0)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All network adapters configured correctly'

            ForEach ($connection In $check)
            {
                $data   = $connection.Caption -split ']'
                $suffix = $data[0].Substring(($data[0].length - 4), 4)

                Try
                {
                    $reg     = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
                    $regKey1 = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318}\' + $suffix)
                    If ($regKey1) { $keyVal = $regKey1.GetValue('*JumboPacket') }
                }
                Catch
                {
                    $result.result  = $script:lang['Error']
                    $result.message = $script:lang['Script-Error']
                    $result.data    = $_.Exception.Message
                    Return $result
                }

                If (($keyVal -gt '1') -and ($keyVal -lt '9000'))    # Jumbo frames > 9000
                {
                    [boolean]$ignore = $false
                    [string] $nic    = $connection.GetRelated('Win32_NetworkAdapter') | Select-Object -ExpandProperty NetConnectionID
                    $script:appSettings['IgnoreTheseAdapters'] | ForEach { If ($nic -like "*$_*") { $ignore = $true } }
                    If ($ignore -eq $false)
                    {
                        $result.result   = $script:lang['Fail']
                        $result.message  = 'One or more network adapters are not using Jumbo Frames'
                        $result.data    += "$nic - $keyVal,#"
                    }
                }
            }
            $regKey1.Close()
            $reg.Close()
        }
        Else
        {
           $result.result  = $script:lang['Fail']
           $result.message = 'No network adapters found or enabled'
           $result.data    = ''
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Hyper-V host server'
    }
    Return $result
}
Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-hvh-05-jumbo-frames -serverName $serverName -resultPath $resultPath
}
$chvh06 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Generation Type'
<#
    DESCRIPTION: 
        Check that all Windows 2012+ VMs are built as generation 2 VMs

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:    
            All VMs are the correct generation type
        WARNING:
        FAIL:
            One or more Windows 2012+ VMs are not generation 2 VMs
        MANUAL:
        NA:
            No VMs are located on this host
            Not a Hyper-V server

    APPLIES:
        Hyper-V Host Servers

    REQUIRED-FUNCTIONS:
        Check-NameSpace
#>

Function c-hvh-06-generation-type
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-hvh-06-generation-type'
 
    #... CHECK STARTS HERE ...#

    If ((Check-NameSpace -ServerName $serverName -NameSpace 'ROOT\Virtualization') -eq $true)
    {
        Try
        {
            [string]$query = 'SELECT * FROM Msvm_ComputerSystem WHERE Caption="Virtual Machine"'
            [object]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Virtualization\v2
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check.Count -ne 0)
        {
            [string]$result.data = ''
            ForEach ($vm In $check)
            {
                $VSMS = Get-WmiObject -Class 'Msvm_VirtualSystemManagementService' -Namespace ROOT\Virtualization\v2
                $Info = $VSMS.GetSummaryInformation($vm.__PATH, (106, 135))

                If ($($Info.SummaryInformation[0].GuestOperatingSystem) -like '*201*')    # 2012, 2016
                {
                    If (($Info.SummaryInformation[0].VirtualSystemSubType).Split(':')[3] -eq '1') { $result.data += "$($vm.ElementName),#" }
                }
            }

            If ($result.data -ne '')
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'One or more Windows 2012+ VMs are not generation 2 VMs'
            }
            ELse
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'All VMs are the correct generation type'
            }
        }
        Else
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'No VMs are located on this host'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Hyper-V host server'
    }

    Return $result
}
Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-hvh-06-generation-type -serverName $serverName -resultPath $resultPath
}
$cnet01 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IPv6State'] = 'Disabled'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Global And NIC IPv6 Status'
<#
    DESCRIPTION:
        Check the global IPv6 setting and of status of each NIC.

    REQUIRED-INPUTS:
        IPv6State - "Enabled|Disabled" - State of the IPv6 protocol for each network adapter

    DEFAULT-VALUES:
        IPv6State = 'Disabled'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            D:IPv6 setting disabled globally
            E:IPv6 setting enabled globally, all NICs enabled
        WARNING:
            D:IPv6 setting enabled globally, all NICs disabled
        FAIL:
            D:IPv6 setting enabled globally, one or more NICs enabled
            E:IPv6 setting enabled globally, one or more NICs disabled
            E:IPv6 setting disabled globally
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-net-01-ipv6-status
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-01-ipv6-status'

    #... CHECK STARTS HERE ...#

    If ($script:appSettings['IPv6State'] -eq 'Disabled') { [string]$lookingFor = '-1'; [string]$stateGood = 'disabled'; [string]$stateBad = 'enabled'  }
    Else                                                 { [string]$lookingFor =  '0'; [string]$stateGood = 'enabled' ; [string]$stateBad = 'disabled' }

    Try
    {
        # First check if IPv6 is set globally
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\TCPIP6\Parameters')
        If ($regKey) { [string]$keyVal = $regKey.GetValue('DisabledComponents') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = '1: ' + $_.Exception.Message
        Return $result
    }

    # Check each enabled adapter to see their IPv6 status
    Try
    {
        # Get list of all adapters...
        [string]$query    = 'SELECT NetConnectionID, GUID FROM Win32_NetworkAdapter WHERE NetEnabled = "TRUE"'
        [object]$object   = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object NetConnectionID, GUID
        [object]$adapters = $object | Where-Object { [string]::IsNullOrEmpty($_.NetConnectionID) -eq $false } | Sort-Object NetConnectionID

        # ...and IPv6 enabled adapters...
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey2 = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\TCPIP6\Linkage')
        If ($regKey2) { $keyVal2 = $regKey2.GetValue('Bind') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result   = $script:lang['Error']
        $result.message += $script:lang['Script-Error']
        $result.data     = '2: ' + $_.Exception.Message
        Return $result
    }

    # Separate IPv6 enabled adapters
    [System.Collections.ArrayList]$ipv6d = @()                           # To hold list of IPv6 DISABLED adapters
    [System.Collections.ArrayList]$ipv6e = @()                           # To hold list of IPv6 ENABLED  adapters
    $adapters | ForEach { $ipv6d.Add($_.NetConnectionID) | Out-Null }    # 

    ForEach ($bind In $keyVal2)
    {
        [string]$deviceid = $bind.split('\')[2]
        [string]$found = ''
        $adapters | ForEach { If ($_.GUID -eq $deviceid) { $found = $_.NetConnectionID } }

        If ($found -ne '')
        {
            $ipv6e.Add(   $found) | Out-Null
            $ipv6d.Remove($found) | Out-Null
        }
    }

    # If setting is ENABLED, check all adapters
    $result.data = ''
    If ($script:appSettings['IPv6State'] -eq 'Disabled')
    {
        If ($keyval -ne $lookingFor)
        {
            If ($ipv6e.Count -gt 0)
            {
                # FAIL
                $result.result   = $script:lang['Fail']
                $result.message += "IPv6 setting $stateBad globally, one or more NICs $stateBad"
                $ipv6e | ForEach { $result.data += "$_,#" }
            }
            Else
            {
                # WARNING
                $result.result   = $script:lang['Warning']
                $result.message += "IPv6 setting $stateBad globally, all NICs $stateGood"
                $ipv6e | ForEach { $result.data += "$_,#" }
            }
        }
        Else
        {
            # PASS
            $result.result   = $script:lang['Pass']
            $result.message += "IPv6 setting $stateGood globally"
        }
    }
    Else
    {
        If ($keyval -ne $lookingFor)
        {
            # FAIL
            $result.result   = $script:lang['Fail']
            $result.message += "IPv6 setting $stateBad globally"
        }
        Else
        {
            If ($ipv6d.Count -gt 0)
            {
                # FAIL
                $result.result   = $script:lang['Fail']
                $result.message += "IPv6 setting $stateGood globally, one or more NICs $stateBad"
                $ipv6d | ForEach { $result.data += "$_,#" }
            }
            Else
            {
                # PASS
                $result.result   = $script:lang['Pass']
                $result.message += "IPv6 setting $stateGood globally, all NICs $stateGood"
                $ipv6d | ForEach { $result.data += "$_,#" }
            }
        }
    }
    Return $result
}
c-net-01-ipv6-status -serverName $serverName -resultPath $resultPath
}
$cnet02 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Unused Network Adapters'
<#
    DESCRIPTION: 
        Check there are no unused Network interfaces on the server.  We define "not in use" by showing any ENABLED NICs that are set to DHCP.
        All NICs should have a statically assigned IP address.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No DHCP enabled adapters found
        WARNING:
        FAIL:
            DHCP enabled adapters found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-net-02-unused-network-interfaces
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-02-unused-network-interfaces'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT * FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled="TRUE" AND DHCPEnabled="TRUE"'
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'DHCP enabled adapters found'
        $check | ForEach {
            $nicName = $_.GetRelated('Win32_NetworkAdapter') | Select-Object -ExpandProperty NetConnectionID
            $result.data += '{0},#' -f $nicName
        }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No DHCP enabled adapters found'
    }

    Return $result
}
c-net-02-unused-network-interfaces -serverName $serverName -resultPath $resultPath
}
$cnet03 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Network Adapter Names'
<#
    DESCRIPTION: 
        Check network interfaces are labelled so their purpose is easily identifiable.  FAIL if any adapter names are "Local Area Connection x" or "Ethernet x".

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All adapters renamed from default
        WARNING:
        FAIL:
            An adapter was found with the default name
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-net-03-network-adapter-labels
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-03-network-adapter-labels'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT NetConnectionID, NetConnectionStatus FROM Win32_NetworkAdapter WHERE NetConnectionID = "" AND NetConnectionStatus = "2"'
        ('Local Area Connection', 'Ethernet') | ForEach { $query += ' OR NetConnectionID LIKE "%{0}%"' -f $_ }
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty NetConnectionID
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $result.result  = $script:lang['Pass']
    $result.message = 'All adapters renamed from default'

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'An adapter was found with the default name'
        $check | ForEach { $result.data += '{0},#' -f $_ }
    }

    Return $result
}
c-net-03-network-adapter-labels -serverName $serverName -resultPath $resultPath
}
$cnet04 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ManagementAdapterNames'] = ('Management', 'MGMT', 'MGT')
$script:appSettings['ProductionAdapterNames'] = ('Production', 'PROD', 'PRD')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Network Binding Order'
<#
    DESCRIPTION: 
        Check binding order is set correctly for "Production" as the primary network adapter then as applicable for other interfaces.
        If no "Production" adapter is found, then "Management" should be first.

    REQUIRED-INPUTS:
        ManagementAdapterNames - List of names or partial names of Management network adapters
        ProductionAdapterNames - List of names or partial names of Production network adapters

    DEFAULT-VALUES:
        ManagementAdapterNames = ('Management', 'MGMT', 'MGT')
        ProductionAdapterNames = ('Production', 'PROD', 'PRD')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Binding order correctly set
        WARNING:
        FAIL:
            No network adapters found
            Production or management adapters not listed
            Binding order incorrect, {name} should be first
            Registry setting not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-net-04-binding-order
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-04-binding-order'

    #... CHECK STARTS HERE ...#

    Try
    {
        # Get binding order GUIDs from reg key
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\Tcpip\Linkage')
        If ($regKey) { $keyVal = $regKey.GetValue('Bind') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    [array]$bindingorder = $null
    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        ForEach ($bind In $keyVal)
        {
            Try
            {
                [string]$deviceid = ($bind -split '\\')[2]
                If ($deviceid -notlike '{*}')
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = 'No network adapters found'
                    $result.data    = ''
                    Return $result
                }

                Try
                {
                    [string]$query   = 'SELECT NetConnectionID FROM Win32_NetworkAdapter WHERE GUID="{0}"' -f $deviceid
                    [array] $adapter = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object -ExpandProperty NetConnectionID
                }
                Catch { }
            }
            Catch
            {
                $result.result  = $script:lang['Error']
                $result.message = $script:lang['Script-Error']
                $result.data    = $_.Exception.Message
                Return $result
            }

            If ([string]::IsNullOrEmpty($adapter) -eq $false)
            {
                $bindingorder +=            $adapter
                $result.data  += '{0},#' -f $adapter
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
        Return $result
    }

    [boolean]$prodExists = $false
    [boolean]$mgmtExists = $false

    If ($bindingorder -eq $null)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Production or Management adapters not listed'
        $result.data    = ''
        Return $result
    }

    # Check if 'Production' actually exists
    ForEach ($p In $script:appSettings['ProductionAdapterNames'])
    {
        # Check if firstmost binding is 'Production'
        If ($bindingorder[0] -like '{0}*' -f $p )
        {
            $prodExists     = $true
            $result.result  = $script:lang['Pass']
            $result.message = 'Binding order correctly set'
            Break
        }
        ElseIf ($bindingorder -like '*{0}*' -f $p)
        {
            $prodExists     = $true
            $result.result  = $script:lang['Fail']
            $result.message = 'Binding order incorrect, {0} should be first' -f $script:appSettings['ProductionAdapterNames'][0]
            Break
        }
        Else
        {
            $prodExists = $false
        }
    }

    If ($prodExists -eq $false)
    {
        # No 'Production', check for 'Management'
        ForEach ($m In $script:appSettings['ManagementAdapterNames'])
        {
            # Check if firstmost binding is 'Management'
            If ($bindingorder[0] -like '{0}*' -f $m)
            {
                $mgmtExists     = $true
                $result.result  = $script:lang['Pass']
                $result.message = 'Binding order correctly set'
                Break
            }
            ElseIf ($bindingorder -like '*{0}*' -f $m)
            {
                $mgmtExists     = $true
                $result.result  = $script:lang['Fail']
                $result.message = 'Binding order incorrect, {0} should be first' -f $script:appSettings['ManagementAdapterNames'][0]
                Break
            }
            Else
            {
                $mgmtExists = $false
            }
        }
    }

    If (($prodExists -eq $false) -and ($mgmtExists -eq $false))
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Production or Management adapters not listed'
    }
    
    Return $result
}
c-net-04-binding-order -serverName $serverName -resultPath $resultPath
}
$cnet05 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Network Speed And Duplex'
<#
    DESCRIPTION: 
        Check the network adapter speed and duplex settings.  Should be set to "Full Duplex" and "Auto".

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All network adapters configured correctly
        WARNING:
            One or more network adapters configured incorrectly
        FAIL:
            No network adapters found or enabled
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-net-05-network-speed-duplex
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-05-network-speed-duplex'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT * FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled = "True"'
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All network adapters configured correctly'

        ForEach ($connection In $check)
        {
            $data   = $connection.Caption -split ']'
            $suffix = $data[0].Substring(($data[0].length - 4), 4)

            Try
            {
                $reg     = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
                $regKey1 = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318}\' + $suffix)
                If ($regKey1) { $keyVal = $regKey1.GetValue('*PhysicalMediaType') }
            }
            Catch
            {
                $result.result  = $script:lang['Error']
                $result.message = $script:lang['Script-Error']
                $result.data    = $_.Exception.Message
                Return $result
            }

            If ($keyVal -eq '14')    # Ethernet
            {
                $nic   = $connection.GetRelated('Win32_NetworkAdapter') | Select-Object Speed, NetConnectionID
                $keySD = $regKey1.GetValue('*SpeedDuplex')

                $regPath2 = 'SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318}\' + $suffix + '\Ndi\Params\*SpeedDuplex\enum'
                $regKey2  = $reg.OpenSubKey($regPath2)
                If ($keySD -ne $null) { $duplex = $regKey2.GetValue($keySD) } Else { $duplex = 'unknown' }

                $nicSpeed = [math]::Round($nic.Speed/1000000)
                If (($nicSpeed -lt 1000) -or ($duplex -notlike '*auto*'))
                {
                    $result.result  = $script:lang['Warning']
                    $result.message = 'One or more network adapters configured incorrectly'
                }
                $result.data += '{0}: {1}mb ({2}),#' -f $nic.NetConnectionID, $nicSpeed, $duplex
                If ($keySD -ne $null) { $regKey2.Close() }
            }
        }
        $regKey1.Close()
        $reg.Close()
    }
    Else
    {
       $result.result  = $script:lang['Fail']
       $result.message = 'No network adapters found or enabled'
       $result.data    = ''
    }

    Return $result
}
c-net-05-network-speed-duplex -serverName $serverName -resultPath $resultPath
}
$cnet06 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductNames'] = ('HP Network Config Utility', 'Broadcom Advanced Control Suite', 'Broadcom Drivers and Management Applications')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Network Management Agent'
<#
    DESCRIPTION:
        Check local network management agent is installed on the server.  This only checks that known software is installed.

    REQUIRED-INPUTS:
        ProductNames - List of software to check if installed

    DEFAULT-VALUES:
        ProductNames = ('HP Network Config Utility', 'Broadcom Advanced Control Suite', 'Broadcom Drivers and Management Applications')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            {product} found
        WARNING:
        FAIL:
            Network management software not found, install required
        MANUAL:
        NA:
            Not a physical machine

    APPLIES:
        Physical Servers

    REQUIRED-FUNCTIONS:
        Check-Software
        Check-VMware
        Check-HyperV
#>

Function c-net-06-network-agent
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-06-network-agent'

    #... CHECK STARTS HERE ...#

    If (((Check-VMware $serverName) -eq $false) -and ((Check-HyperV $serverName) -eq $false))
    {
        Try
        {
            [boolean]$found = $false
            $script:appSettings['ProductNames'] | ForEach {
                [string]$verCheck = Check-Software -serverName $serverName -displayName $_
                If ($verCheck -eq '-1') { Throw 'Error opening registry key' }
                If ([string]::IsNullOrEmpty($verCheck) -eq $false)
                {
                    $found            = $true
                    [string]$prodName = $_
                    [string]$prodVer  = $verCheck
                }
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($found -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.message = '{0} found'   -f $prodName
            $result.data    = 'Version {0}' -f $prodVer
        }
        Else
        {
            # Fallback detection method
            [string]$keyVal = ''
            $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Manufacturer
            If ($wmiBIOS.Manufacturer -like 'HP*')
            {
                Try
                {
                    $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
                    $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows\CurrentVersion\Control Panel\CPLs')
                    If ($regKey) { $keyVal = $regKey.GetValue('CPQTEAM') }
                    Try { $regKey.Close() } Catch { }
                    $reg.Close()
                }
                Catch { }
            }
            ElseIf ($wmiBIOS.Manufacturer -like 'Dell*')
            {
                # TODO (If required)
            }
            Else { $keyVal = '' }

            If ($keyVal -eq '')
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Network management software not found, install required'
            }
            Else
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'Software not Fallback method used'
                $result.data    = $keyVal
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a physical machine'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Check-Software
{
    Param ([string]$ServerName, [string]$DisplayName)
    Try {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() } }
    Catch { Return '-1' }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } } }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Check-Software -ServerName $serverName -DisplayName $displayName }
            Else { $verCheck = $null } } }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
Function Check-HyperV
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}
c-net-06-network-agent -serverName $serverName -resultPath $resultPath
}
$cnet07 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['NetworkTeamNames'] = ('HP Network Teaming', 'BASP Virtual Adapter')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Network Teaming'
<#
    DESCRIPTION: 
        Check network interfaces for known teaming names, manually check they are configured correctly.  Fail if no teams found or if server is a virtual.  Checked configuration is:
        Teaming Mode: "Static Independent";  Load Balancing Mode: "Address Hash";  Standby Adapter: (set).

    REQUIRED-INPUTS:
        NetworkTeamNames - List of network teaming adapters

    DEFAULT-VALUES:
        NetworkTeamNames = ('HP Network Teaming', 'BASP Virtual Adapter')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Network team count: {number}
        WARNING:
        FAIL:
            No teamed network adapter(s) found
            There are no network teams configured on this server
            Native teaming enabled on virtual machine
            Team configuration is not set correctly
        MANUAL:
            Teamed network adpater(s) found, check they are configured correctly
        NA:
            Not a physical server
            Operating system not supported

    APPLIES:
        Physical Servers

    REQUIRED-FUNCTIONS:
        Check-VMware
        Check-HyperV
#>

Function c-net-07-network-teaming
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-07-network-teaming'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Caption FROM Win32_OperatingSystem'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption

        If ($check -like '*200*')    # 2003, 2008
        {
            [string]$query1 = 'SELECT ProductName, NetConnectionID FROM Win32_NetworkAdapter WHERE ProductName = "dummyValue"'
            $script:appSettings['NetworkTeamNames'] | ForEach { $query1 += ' AND ProductName = "{0}"' -f $script:appSettings['NetworkTeamNames'] }
            [array]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty NetConnectionID
        }
        ElseIf ($check -like '*201*')    # 2012, 2016
        {
            [string]$query1 = 'SELECT Name, LoadBalancingAlgorithm, TeamingMode FROM MSFT_NetLbfoTeam'
            [array] $check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\StandardCimv2 | Select-Object Name, LoadBalancingAlgorithm, TeamingMode | Sort-Object Name

            If ([string]::IsNullOrEmpty($check1) -eq $false)
            {
                [string]$query2 = 'SELECT Name, Team, AdministrativeMode, FailureReason, OperationalMode FROM MSFT_NetLbfoTeamMember'
                [array] $check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\StandardCimv2 | Select-Object Name, Team, AdministrativeMode, FailureReason, OperationalMode | Sort-Object Name

                [string]$query3 = 'SELECT Team, VlanID FROM MSFT_NetLbfoTeamNic'
                [array] $check3 = Get-WmiObject -ComputerName $serverName -Query $query3 -Namespace ROOT\StandardCimv2 | Select-Object Team, VlanID
            }
            Else
            {
                [array]$check1 = ('NOTEAMS')    # 
            }
        }
        Else
        {
            [array]$check1 = ('UNKNOWN')    # Desktop OS, Unsupported
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }


    If ($check -like '*200*')    # 2003, 2008
    {
        If (((Check-VMware $serverName) -eq $false) -and ((Check-HyperV $serverName) -eq $false))
        {
            If ($check1.Count -gt 0)
            {
                $result.result  = $script:lang['Manual']
                $result.message = 'Teamed network adpater(s) found, check they are configured correctly'
                $check1 | ForEach { $result.data += '{0},#' -f $_ }
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'No teamed network adapter(s) found'
            }
        }
        Else
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'Not a physical server'
        }
    }
    ElseIf ($check -like '*201*')    # 2012, 2016
    {
        If ($check1 -eq 'NOTEAMS')
        {
            If (((Check-VMware $serverName) -eq $true) -or ((Check-HyperV $serverName) -eq $true))
            {
                $result.result  = $script:lang['Not-Applicable']
                $result.message = 'Not a phsical server'
                $result.data    = ''
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'There are no network teams configured on this server'
                $result.data    = 'All phyiscal servers should have teamed network adapters'
            }
        }
        Else
        {
            If (((Check-VMware $serverName) -eq $true) -or ((Check-HyperV $serverName) -eq $true))
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Native teaming enabled on virtual machine'
                $result.data    = 'Virtual machines should not be using network teaming'
            }
            Else
            {
                [array]$teams = @()
                ForEach ($team In $check1)
                {
                    [PSCustomObject]$newTeam = New-Object -TypeName PSObject -Property @{'name'=''; 'lba'=''; 'tm'=''; 'adapters'=@(); 'standby'=''}
                    $newTeam.name = $team.Name
                    $newTeam.lba  = $team.LoadBalancingAlgorithm
                    $newTeam.tm   = $team.TeamingMode

                    ForEach ($nic In $check2)
                    {
                        If ($nic.Team -eq $team.Name)
                        {
                            $newTeam.adapters += $nic.Name
                            If (($nic.AdministrativeMode -eq '1') -and ($nic.FailureReason -eq '1') -and ($nic.OperationalMode -eq '1')) { $newTeam.standby = $nic.Name }
                        }
                    }
                    $teams += $newTeam
                }

                If ($teams.Count -gt 0)
                {
                    [boolean]$pass = $true
                    $result.message = 'Network team count: '+ $teams.Count
                    ForEach ($team In $teams)
                    {
                        [string]$vlan = $check3[$check3.Team.IndexOf($team.name)].VlanID
                        If ($vlan -eq '') { $vlan = 'none' }
                        $result.data += '{0} (vlan: {1}): ' -f $team.name, $vlan

                        Switch ($team.tm)
                        {
                            '0' { $result.data += 'Static Teaming, '    ; $pass = $false }
                            '1' { $result.data += 'Static Independent, '                 }    # Default Config
                            '2' { $result.data += 'LACP, '              ; $pass = $false }
                        }

                        Switch ($team.lba)
                        {
                            '0' { $result.data += 'Address Hash, '                       }    # Default Config
                            '4' { $result.data += 'Hyper-V Port, '      ; $pass = $false }
                            '5' { $result.data += 'Dynamic, '           ; $pass = $false }
                        }

                        If ($team.standby -eq '')
                        {
                            $result.data += 'No standby NIC.#';
                            $pass = $false
                        }
                        Else
                        {
                            $result.data += $team.standby + '.#'
                        }
                    }

                    If ($pass -eq $true)
                    {
                        $result.result  = $script:lang['Pass']
                    }
                    Else
                    {
                        $result.result  = $script:lang['Fail'];
                        $result.message += ', Team configuration is not set correctly'
                    }
                }
                Else
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = 'There are no network teams configured on this server'
                    $result.data    = 'All phyiscal servers should have teamed network adapters'
                }
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Operating system not supported'
        $result.data    = '{0}' -f $check
    }
    Return $result
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
Function Check-HyperV
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}
c-net-07-network-teaming -serverName $serverName -resultPath $resultPath
}
$cnet08 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ManagementAdapterNames'] = ('Management', 'MGMT', 'MGT')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Management Adapter'
<#
    DESCRIPTION: 
        Check that a management network adapter exists.  This must always be present on a server and labelled correctly.

    REQUIRED-INPUTS:
        ManagementAdapterNames - List of names or partial names of Management network adapters

    DEFAULT-VALUES:
        ManagementAdapterNames = ('Management', 'MGMT', 'MGT')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Management network adapter found
        WARNING:
        FAIL:
            No management network adapter
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-net-08-management-adapter
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-08-management-adapter'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT NetConnectionID FROM Win32_NetworkAdapter WHERE NetConnectionID = ""'
        $script:appSettings['ManagementAdapterNames'] | ForEach { $query += ' OR NetConnectionID LIKE "%{0}%"' -f $_ }
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty NetConnectionID
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $result.result  = $script:lang['Fail']
    $result.message = 'No management network adapter'

    If ([string]::IsNullOrEmpty($check) -eq $false)
    {
        If ($check.Count -gt 0)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Management network adapter found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'No management network adapter'
    }

    Return $result
}
c-net-08-management-adapter -serverName $serverName -resultPath $resultPath
}
$cnet09 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['StaticRoute01'] = ('')
$script:appSettings['StaticRoute02'] = ('')
$script:appSettings['StaticRoute03'] = ('')
$script:appSettings['StaticRoute04'] = ('')
$script:appSettings['StaticRoute05'] = ('')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Static Routes'
<#
    DESCRIPTION:
        Checks to make sure the specified static routes have been added.  Add routes to check as: StaticRoute01 = ("source", "mask", "gateway").
        To check for no extra persistent routes, use: StaticRoute01 = ("None", "", "").  Up to 99 routes can be checked.
        You must edit the settings file manually for more than the currently configured.

    REQUIRED-INPUTS:
        StaticRoute01 - List of IPs for a single static route to check.  Order is: Source, Mask, Gateway|IPv4
        StaticRoute02 - List of IPs for a single static route to check.  Order is: Source, Mask, Gateway|IPv4
        StaticRoute03 - List of IPs for a single static route to check.  Order is: Source, Mask, Gateway|IPv4
        StaticRoute04 - List of IPs for a single static route to check.  Order is: Source, Mask, Gateway|IPv4
        StaticRoute05 - List of IPs for a single static route to check.  Order is: Source, Mask, Gateway|IPv4

    DEFAULT-VALUES:
        StaticRoute01 = ('', '', '')
        StaticRoute02 = ('', '', '')
        StaticRoute03 = ('', '', '')
        StaticRoute04 = ('', '', '')
        StaticRoute05 = ('', '', '')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All static routes are present
        WARNING:
        FAIL:
            One or more static routes are missing or incorrect
        MANUAL:
        NA:
            No static routes to check

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-net-09-static-routes
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-09-static-routes'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query1 = 'SELECT Destination, Mask, NextHop FROM Win32_IP4RouteTable'
        [object]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object Destination, Mask, NextHop
        
        [string]$query2 = 'SELECT Destination, Mask, NextHop FROM Win32_IP4PersistedRouteTable'
        [object]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Select-Object Destination, Mask, NextHop
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    [boolean]$noneEntry     = $false
    [boolean]$RoutesToCheck = $false
    Try
    {
        For ($i = 1; $i -le 99; $i++)
        {
            [string[]]$routeEntry = $script:appSettings["StaticRoute$(($i -as [string]).PadLeft(2, '0'))"]
            If ([string]::IsNullOrEmpty($routeEntry[0]) -eq $false) { $RoutesToCheck = $true; Break }
        }
        If (($script:appSettings['StaticRoute01'][0]) -eq 'None') { $noneEntry = $true }
    }
    Catch {}

    If (([string]::IsNullOrEmpty($check1) -eq $true) -and ([string]::IsNullOrEmpty($check2) -eq $true))
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'No static routes present'
    }
    ElseIf ($RoutesToCheck -eq $false)
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'No static routes to check'
        Return $result
    }
    ElseIf ($noneEntry -eq 'None')
    {
        If ([string]::IsNullOrEmpty($check2) -eq $false)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Static routes are present, they need removing'
            $result.data    = 'Dest: {0}, Mask: {1}, Gateway: {2},#' -f $check2.Destination, $check2.Mask, $check2.NextHop
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'No static routes are present'
        }
    }
    Else
    {
        For ($i = 1; $i -le 99; $i++)
        {
            [string[]]$routeEntry = $script:appSettings["StaticRoute$(($i -as [string]).PadLeft(2, '0'))"]
            If ([string]::IsNullOrEmpty($routeEntry) -eq $false)
            {
                If ([string]::IsNullOrEmpty($routeEntry[0]) -eq $false)
                {
                    [boolean]$found = $false
                    ForEach ($item In $check2)
                    {
                        If ($item.Destination -eq $routeEntry[0])
                        {
                            $found = $true
                            If ($item.Mask    -ne $routeEntry[1]) { $result.data += '' + $routeEntry[0] + ' (Wrong Mask),#'    }
                            If ($item.NextHop -ne $routeEntry[2]) { $result.data += '' + $routeEntry[0] + ' (Wrong Gateway),#' }
                        }
                    }

                    If ($found -eq $false) { $result.data += '' + $routeEntry[0] + ' (Missing),#' }
                }
            }
            $routeEntry = $null
        }

        If ($result.data -eq '')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All static routes are present'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more static routes are missing or incorrect'
        }
    }

    Return $result
}
c-net-09-static-routes -serverName $serverName -resultPath $resultPath
}
$cnet10 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Power Management'
<#
    DESCRIPTION: 
        Check network interfaces have their power management switch disabled.
        
    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All adapters have power saving disabled
        WARNING:
        FAIL:
            One or more adapters have power saving enabled
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-net-10-power-management
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-10-power-management'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query1 = 'SELECT DeviceID, NetConnectionID, NetConnectionStatus FROM Win32_NetworkAdapter WHERE NetConnectionStatus = "2"'
        [object]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002bE10318}')

        ForEach ($adapter In $check1)
        {
            $regKey2 = $regKey.OpenSubKey($($adapter.DeviceID).Padleft(4, '0'))
            $keyVal = $regKey2.GetValue('PnPCapabilities')
            Try { $regKey2.Close() } Catch { }

            Switch ($keyVal)
            {
                 0 { $result.data += "$($adapter.NetConnectionID) (Unknown),#" }
                16 { $result.data += "$($adapter.NetConnectionID) (Enabled),#" }
                24 {  }    # Disabled value
            }
        }

        Try { $regKey.Close() } Catch { }
        $reg.Close()

        If (($result.data).Length -eq 0)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All adapters have power saving disabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more adapters have power saving enabled'
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Return $result
}
c-net-10-power-management -serverName $serverName -resultPath $resultPath
}
$cnet11 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['AllMustExist'] = 'True'
$script:appSettings['DNSServers'] = ('')
$script:appSettings['OrderSpecific'] = 'True'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'DNS Settings'
<#
    DESCRIPTION: 
        Checks that all DNS servers are configured, and if required, in the right order.

    REQUIRED-INPUTS:
        DNSServers    - List of DNS IP addresses that you want to check|IPv4
        OrderSpecific - "True|False" - Should the DNS order match exactly for a Pass.?  If the number of entries does not match the input list, this is set to "FALSE"
        AllMustExist  - "True|False" - Should all DNS entries exist for a Pass.?

    DEFAULT-VALUES:
        DNSServers    = ('')
        OrderSpecific = 'True'
        AllMustExist  = 'True'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All DNS servers configured (and in the right order)
        WARNING: 
        FAIL:
            DNS Server count mismatch
            Mismatched DNS servers
            DNS Server list is not in the required order
            No DNS servers are configured
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-net-11-dns-settings
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-11-dns-settings'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DNSServerSearchOrder FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled="TRUE"'
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object DNSServerSearchOrder
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        If ($check[0].DNSServerSearchOrder.Count -ne ($script:appSettings['DNSServers'].Count))
        {
            If ($script:appSettings['AllMustExist'] -eq 'TRUE')
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'DNS Server count mismatch'
                $result.data    = "Configured: $($check -join ', '),#Looking For: $($script:appSettings['DNSServers'] -join ', ')"
            }
            Else
            {
                $script:appSettings['OrderSpecific'] = 'FALSE'
            }
        }

        # Set OrderSpecific to FALSE if required
        If (($script:appSettings['OrderSpecific']) -eq 'TRUE')
        {
            # Check OrderSpecific list
            For ($i=0; $i -le ($check[0].DNSServerSearchOrder.Count); $i++)
            {
                If ($check[0].DNSServerSearchOrder[$i] -ne $script:appSettings['DNSServers'][$i]) { $result.message = 'DNS Server list is not in the required order'; Break }
            }

            If (($result.message) -ne '')
            {
                $result.result = $script:lang['Fail']
                $result.data   = "Configured: $($check[0].DNSServerSearchOrder -join ', '),#Looking For: $($script:appSettings['DNSServers'] -join ', ')"
            }
            Else
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'All DNS servers configured and in the right order'
                $result.data    = ($check[0].DNSServerSearchOrder -join ', ')
            }
        }
        Else
        {
            # Check any ordered list
            ForEach ($itemC In $check[0].DNSServerSearchOrder)
            {
                [boolean]$Found = $false
                ForEach ($itemS In $script:appSettings['DNSServers']) { If ($itemC -eq $itemS) { $Found = $true; Break } }
                If ($Found -eq $false)
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = 'Mismatched DNS servers'
                    $result.data    = "Configured: $($check[0].DNSServerSearchOrder -join ', '),#Looking For: $($script:appSettings['DNSServers'] -join ', ')"
                }
            }

            If (($result.message) -eq '')
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'All DNS servers configured'
                $result.data    = ($check[0].DNSServerSearchOrder -join ', ')
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'No DNS servers are configured'
        $result.data    = ''
    }

    Return $result
}
c-net-11-dns-settings -serverName $serverName -resultPath $resultPath
}
$cnet12 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseAdapters'] = ('Production', 'PROD', 'PRD')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'File And Print Services'
<#
    DESCRIPTION: 
        Check that File And Print Services has been disabled on all adapters, except for those specified.

    REQUIRED-INPUTS:
        IgnoreTheseAdapters - List of names or partial names of network adapters to ignore

    DEFAULT-VALUES:
        IgnoreTheseAdapters = ('Production', 'PROD', 'PRD')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            File And Print Services are disabled correctly
        WARNING:
        FAIL:
            File And Print Services are enabled
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-net-12-fileprint-services
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-net-12-fileprint-services'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT NetConnectionID, GUID FROM Win32_NetworkAdapter WHERE (NetConnectionStatus="2" OR NetConnectionStatus="7")'
        $script:appSettings['IgnoreTheseAdapters'] | ForEach { $query += ' AND (NOT NetConnectionID LIKE "%{0}%")' -f $_ }
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object NetConnectionID, GUID

        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('System\CurrentControlSet\Services\LanmanServer\Linkage')
        If ($regKey) { [string[]]$BindList = $regKey.GetValue('Bind') }
        Try {$regKey.Close()} Catch {}
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    # Clean up and filter results
    [System.Collections.ArrayList]$arrBind = @()
    [System.Collections.ArrayList]$Enabled = @()
    ForEach ($item In $BindList) { If ($item.StartsWith('\Device\Tcpip_')) { $arrBind.Add($item.Split('_')[-1]) | Out-Null } }
    ForEach ($GUID In $check)    { If ($arrBind.Contains($GUID.GUID))      { $Enabled.Add($GUID)                | Out-Null } }

    If ($Enabled.Count -gt 0)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'File And Print Services are enabled'
        $Enabled | ForEach { $result.data += "$($_.NetConnectionID),#" }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'File And Print Services are disabled correctly'
    }

    Return $result
}
c-net-12-fileprint-services -serverName $serverName -resultPath $resultPath
}
$creg01 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Local Date/Time'
<#
    DESCRIPTION: 
        Check that the server time is correct.  If a valid source is used, the time is also checked against that source.
        Maximum time difference allowed is 10 seconds, any longer and the check fails.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Time source is set to a remote server, and is syncronsized correctly
        WARNING:
        FAIL:
            Time source is set to a remote server, and is not syncronsized correctly
            Time source is not set
            Time source is not set correctly
            Error getting required information
        MANUAL:
            Not a supported operating system for this check
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-reg-01-local-time
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-reg-01-local-time'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string] $query2 = "SELECT PartOfDomain FROM Win32_ComputerSystem"
        [boolean]$domain = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty PartOfDomain

        [string]  $query = 'SELECT Day, Month, Year, Hour, Minute, Second FROM Win32_LocalTime'
        [array]   $check = Get-WmiObject -ComputerName $serverName  -Query $query -Namespace ROOT\Cimv2 | Select  Day, Month, Year, Hour, Minute, Second
        [datetime]$rdt   = Get-Date -Year $check[0].Year -Month  $check[0].Month  -Day    $check[0].Day `
                                    -Hour $check[0].Hour -Minute $check[0].Minute -Second $check[0].Second

        Try
        {
            If ($domain -eq $true)
            {
                If ($serverName -eq $env:ComputerName) {
                    [string]$source = Invoke-Command                           -ScriptBlock { &"$env:SystemRoot\System32\w32tm.exe" /query /source } -ErrorAction SilentlyContinue
                }
                Else {
                    [string]$source = Invoke-Command -ComputerName $serverName -ScriptBlock { &"$env:SystemRoot\System32\w32tm.exe" /query /source } -ErrorAction SilentlyContinue
                }
                If ($source.Contains(',') -eq $true) { $source = ($source.Split(',')[0]) }
            }
            Else
            {
                $source = 'WORKGROUP'
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }
        
        If ([string]::IsNullOrEmpty($source) -eq $true)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Time source is not set'
        }
        ElseIf (($source -eq 'Local CMOS Clock') -or ($source -eq 'Free-running System Clock'))
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Time source is not set correctly'
            $result.data    = '{0},#Time is {1}' -f $source.ToLower(), $rdt
        }
        ElseIf ($source -like '*The following error*')
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Error getting required information'
            $result.data    = '{0},#Time is {1}' -f $source.ToLower(), $rdt
        }
        ElseIf ($source -like '*The command /query is unknown*')    # Windows 2003 server
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Not a supported operating system for this check'
            $result.data    = 'Time is {0}' -f $rdt
        }
        ElseIf ($source -eq 'WORKGROUP')
        {
            $result.result   = $script:lang['Warning']
            $result.message += 'This is a workgroup server'
            $result.data    += 'Time is {0}' -f $rdt
        }
        Else
        {
            $offSet = (Get-NtpTime -NTPServer $source.Trim() -InputDateTime $rdt)
            If ($offSet -lt 10)
            {
                $result.result   = $script:lang['Pass']
                $result.message += 'Time source is set to a remote server, and is syncronsized correctly'
                $result.data    += 'Source: {0},#Time is about {1} seconds adrift' -f $source.Trim().ToLower(), $offSet
            }
            Else
            {
                $result.result   = $script:lang['Fail']
                $result.message += 'Time source is set to a remote server, and is not syncronsized correctly'
                $result.data    += 'Source: {0},#Time is about {1} seconds adrift' -f $source.Trim().ToLower(), $offSet
            }
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Return $result
}

Function Get-NtpTime {
    Param ([string]$NTPServer, [datetime]$InputDateTime)
    $StartOfEpoch=New-Object DateTime(1900,1,1,0,0,0,[DateTimeKind]::Utc)   
    Function OffsetToLocal($Offset) { $StartOfEpoch.AddMilliseconds($Offset).ToUniversalTime() }
    [Byte[]]$NtpData = ,0 * 48
    $NtpData[0]      = 0x1B

    $Socket = New-Object Net.Sockets.Socket([Net.Sockets.AddressFamily]::InterNetwork, [Net.Sockets.SocketType]::Dgram, [Net.Sockets.ProtocolType]::Udp)
    $Socket.SendTimeOut    = 2000
    $Socket.ReceiveTimeOut = 2000
    Try { $Socket.Connect($NTPServer, 123) } Catch { Return 'Failed to connect to server' }
    Try { [Void]$Socket.Send($NtpData); [Void]$Socket.Receive($NtpData) } Catch { Return 'Failed to communicate with server' }
    $Socket.Shutdown('Both')
    $Socket.Close()

    $IntPart  = [System.BitConverter]::ToUInt32($NtpData[35..32],0)
    $FracPart = [System.BitConverter]::ToUInt32($NtpData[39..36],0)
    $CalcPart = $IntPart * 1000 + ($FracPart * 1000 / 0x100000000)
    $Offset =  ($CalcPart - ($InputDateTime.ToUniversalTime() - $StartOfEpoch).TotalMilliseconds)

    Return [Math]::Round($Offset/1000, 3)
}
c-reg-01-local-time -serverName $serverName -resultPath $resultPath
}
$creg02 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['TimeZoneNames'] = ('(UTC) Dublin, Edinburgh, Lisbon, London', '(GMT) Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London', '(UTC+00:00) Dublin, Edinburgh, Lisbon, London')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Local Timezone'
<#
    DESCRIPTION: 
        Check that the server timezone is correct.  Default setting is "(GMT) Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London"
        For Windows 2003, check is "(UTC) Dublin, Edinburgh, Lisbon, London"

    REQUIRED-INPUTS:
        TimeZoneNames - List of time zone strings to check against.  Different OS versions use different strings.

    DEFAULT-VALUES:
        TimeZoneNames = ('(UTC) Dublin, Edinburgh, Lisbon, London', '(GMT) Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London', '(UTC+00:00) Dublin, Edinburgh, Lisbon, London')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Server timezone set correctly
        WARNING:
        FAIL:
            Server timezone is incorrect and should be set to {string}
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-reg-02-timezone
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-reg-02-timezone'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'Select Caption FROM Win32_TimeZone'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($script:appSettings['TimeZoneNames'] -contains $check )
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Server timezone set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Server timezone is incorrect and should be set to {0}' -f $script:appSettings['TimeZoneNames']
    }
    $result.data = $check

    Return $result
}
c-reg-02-timezone -serverName $serverName -resultPath $resultPath
}
$creg03 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DefaultLocation'] = 'United Kingdom'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Region > Location'
<#
    DESCRIPTION: 
        Ensure the Region and Language > Location is set correctly.  Default setting is "United Kingdom".

    REQUIRED-INPUTS:
        DefaultLocation - Regional string name

    DEFAULT-VALUES:
        DefaultLocation = 'United Kingdom'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Regional location set correctly
        WARNING:
        FAIL:
            Regional location incorrectly set to {string}
            Registry setting not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-reg-03-location
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-reg-03-location'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('Users', $serverName)
        $regKey = $reg.OpenSubKey('.DEFAULT\Control Panel\International')
        If ($regKey) { $keyVal = $regKey.GetValue('sCountry') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq $script:appSettings['DefaultLocation'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Regional location set correctly'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Regional location incorrectly set to {0}' -f $keyVal
        }
        $result.data = $keyVal
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
c-reg-03-location -serverName $serverName -resultPath $resultPath
}
$creg04 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DefaultLanguage'] = '00000809'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Region > Language'
<#
    DESCRIPTION: 
        Ensure the Region and Language > keyboard and Languages is set correctly.  Default setting is "English (United Kingdom)".

    REQUIRED-INPUTS:
        DefaultLanguage - Numerical value of the correct keyboard to use

    DEFAULT-VALUES:
        DefaultLanguage = '00000809'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Keyboard layout is set correctly
        WARNING:
        FAIL:
            Keyboard layout is not set correctly
            Registry setting not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-reg-04-language
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-reg-04-language'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg     = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('Users', $serverName)
        $regKey1 = $reg.OpenSubKey('.DEFAULT\Keyboard Layout\Preload')
        If ($regKey1) { $keyVal1 = $regKey1.GetValue('1') }
        Try { $regKey1.Close() } Catch { }
        $reg.Close()

        If ([string]::IsNullOrEmpty($keyVal1) -eq $false)
        {
            $reg     = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey2 = $reg.OpenSubKey("SYSTEM\CurrentControlSet\Control\Keyboard Layouts\$keyVal1")
            If ($regKey2) { $keyVal2 = $regKey2.GetValue('Layout Text') }
            Try { $regKey2.Close() } Catch { }
            $reg.Close()
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal1) -eq $false)
    {
        If ($keyVal1 -eq $script:appSettings['DefaultLanguage'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Keyboard layout is set correctly'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Keyboard layout is not set correctly'
        }
        
        $result.data = $keyVal1
        If ([string]::IsNullOrEmpty($keyVal2) -eq $false) { $result.data += ",#$keyVal2" }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
c-reg-04-language -serverName $serverName -resultPath $resultPath
}
$csec01 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DisabledCiphers'] = ('DES 56/56', 'NULL', 'RC2 128/128', 'RC2 40/128', 'RC2 56/128', 'RC2 56/56', 'RC4 128/128', 'RC4 40/128', 'RC4 56/128', 'RC4 64/128')
$script:appSettings['EnabledCiphers'] = ('AES 128/128', 'AES 256/256', 'Triple DES 168/168')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Security Settings 1: Ciphers'
<#
    DESCRIPTION: 
        Ensure security ciphers are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings.

    REQUIRED-INPUTS:
        EnabledCiphers  - List of Ciphers that should be enabled
        DisabledCiphers - List of Ciphers that should be disabled

    DEFAULT-VALUES:
        EnabledCiphers  = ('AES 128/128', 'AES 256/256', 'Triple DES 168/168')
        DisabledCiphers = ('DES 56/56', 'NULL', 'RC2 128/128', 'RC2 40/128', 'RC2 56/128', 'RC2 56/56', 'RC4 128/128', 'RC4 40/128', 'RC4 56/128', 'RC4 64/128')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All ciphers set correctly
        WARNING:
        FAIL:
            One or more ciphers set incorrectly
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-01-schannel-p1-ciphers
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-01-schannel-p1-ciphers'

    #... CHECK STARTS HERE ...#

    Try
    {
        $disabled = $true
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)

        For ($i = 0; $i -lt 2; $i++)
        {
            If ($i -eq 0) { $regPathCheck = $script:appSettings['EnabledCiphers'];  $regValue = 0xFFFFFFFF; $regResult = 'Enabled'  }
            If ($i -eq 1) { $regPathCheck = $script:appSettings['DisabledCiphers']; $regValue = 0;          $regResult = 'Disabled' }

            ForEach ($key In $regPathCheck)
            {
                $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Ciphers\' + $key)
                If ([string]::IsNullOrEmpty($keyKey) -eq $false)
                {
                    $keyVal = $regKey.GetValue('Enabled')
                    If ($keyVal -ne $regValue)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Should be {1}),#' -f $key, $regResult
                    }        
                }
                Else
                {
                    # Only show MISSING for ciphers that should be disabled
                    If ($i -eq 1)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Missing, should be {1}),#' -f $key, $regResult
                    }
                }
                Try { $regKey.Close() } Catch { }
            }
        }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($disabled -eq $true)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All ciphers set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'One or more ciphers set incorrectly'
    }

    Return $result
}
c-sec-01-schannel-p1-ciphers -serverName $serverName -resultPath $resultPath
}
$csec02 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DisabledHashes'] = ('MD5')
$script:appSettings['EnabledHashes'] = ('SHA', 'SHA256', 'SHA384', 'SHA512')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Security Settings 2: Hashes'
<#
    DESCRIPTION: 
        Ensure hashes are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings.

    REQUIRED-INPUTS:
        EnabledHashes  - List of hashes that should be enabled
        DisabledHashes - List of hashes that should be disabled

    DEFAULT-VALUES:
        EnabledHashes  = ('SHA', 'SHA256', 'SHA384', 'SHA512')
        DisabledHashes = ('MD5')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All hashes set correctly
        WARNING:
        FAIL:
            One or more hashes set incorrectly
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-02-schannel-p2-hashes
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-02-schannel-p2-hashes'

    #... CHECK STARTS HERE ...#

    Try
    {
        $disabled = $true
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)

        For ($i = 0; $i -lt 2; $i++)
        {
            If ($i -eq 0) { $regPathCheck = $script:appSettings['EnabledHashes'];  $regValue = 0xFFFFFFFF; $regResult = 'Enabled'  }
            If ($i -eq 1) { $regPathCheck = $script:appSettings['DisabledHashes']; $regValue = 0;          $regResult = 'Disabled' }

            ForEach ($key In $regPathCheck)
            {
                $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Hashes\' + $key)
                If ($regKey -ne $null)
                {
                    $keyVal = $regKey.GetValue('Enabled')
                    If ($keyVal -ne $regValue)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Should be {1}),#' -f $key, $regResult
                    }        
                }
                Else
                {
                    # Only show MISSING for hashes that should be disabled
                    If ($i -eq 1)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Missing, should be {1}),#' -f $key, $regResult
                    }
                }
                Try { $regKey.Close() } Catch { }
            }
        }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($disabled -eq $true)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All hashes set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'One or more hashes set incorrectly'
    }

    Return $result
}
c-sec-02-schannel-p2-hashes -serverName $serverName -resultPath $resultPath
}
$csec03 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['KeyExchangeAlgorithms'] = ('Diffie-Hellman', 'ECDH', 'PKCS')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Security Settings 3: Key Exchange Algorithms'
<#
    DESCRIPTION:
        Ensure key exchange algorithms are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings.

    REQUIRED-INPUTS:
        KeyExchangeAlgorithms - List of Key Exchange Algorithms that should be used

    DEFAULT-VALUES:
        KeyExchangeAlgorithms = ('Diffie-Hellman', 'ECDH', 'PKCS')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All key exchange algorithms set correctly
        WARNING:
        FAIL:
            One or more key exchange algorithms set incorrectly
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-03-schannel-p3-keyexchangealgorithms
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-03-schannel-p3-keyexchangealgorithms'

    #... CHECK STARTS HERE ...#

    Try
    {
        $disabled = $true
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        ForEach ($key In $script:appSettings['KeyExchangeAlgorithms'])
        {
            $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\KeyExchangeAlgorithms\' + $key)
            If ([string]::IsNullOrEmpty($regKey) -eq $false)
            {
                $keyVal = $regKey.GetValue('Enabled')
                If ($keyval -eq $null)
                {
                    $disabled     = $false
                    $result.data += '{0} (Value not explicitly set),#' -f $key
                }
                ElseIf ($keyVal -ne 0xFFFFFFFF)
                {
                    $disabled     = $false
                    $result.data += '{0} (Incorrect),#' -f $key
                }
            }
            Else
            {
                # $result.data += '{0} (Key not explicitly set),#' -f $key
            }
            Try { $regKey.Close() } Catch { }
        }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($disabled -eq $true)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All key exchange algorithms set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'One or more key exchange algorithms set incorrectly'
    }

    Return $result
}
c-sec-03-schannel-p3-keyexchangealgorithms -serverName $serverName -resultPath $resultPath
}
$csec04 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DisabledProtocols'] = ('Multi-Protocol Unified Hello', 'PCT 1.0', 'SSL 2.0', 'SSL 3.0', 'TLS 1.0')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Security Settings 4: Protocols'
<#
    DESCRIPTION: 
        Ensure protocols are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings.

    REQUIRED-INPUTS:
        DisabledProtocols - List of protocols that should be disabled

    DEFAULT-VALUES:
        DisabledProtocols = ('Multi-Protocol Unified Hello', 'PCT 1.0', 'SSL 2.0', 'SSL 3.0', 'TLS 1.0')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All protocols set correctly
        WARNING:
        FAIL:
            One or more protocols set incorrectly
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-04-schannel-p4-protocols
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-04-schannel-p4-protocols'

    #... CHECK STARTS HERE ...#

    Try
    {
        $disabled = $true
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        ForEach ($k In $script:appSettings['DisabledProtocols'])
        {
            For ($i = 0; $i -lt 2; $i++)
            {
                If ($i -eq 0) { $key = $k + '\Server' } Else { $key = $k + '\Client' }

                $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\' + $key)
                If ([string]::IsNullOrEmpty($regKey) -eq $false)
                {
                    If ($i -eq 0) { $keyVal = $regKey.GetValue('Enabled') } Else { $keyVal = $regKey.GetValue('DisabledByDefault') }
                    If ($keyval -eq $null)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Value Missing),#' -f $key
                    }
                    ElseIf ($keyVal -ne $i)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Incorrect),#' -f $key
                    }        
                }
                Else
                {
                    $disabled     = $false
                    $result.data += '{0} (Key Missing),#' -f $key
                }
                Try { $regKey.Close() } Catch { }
            }
        }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($disabled -eq $true)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All protocols set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'One or more protocols set incorrectly'
    }

    Return $result
}
c-sec-04-schannel-p4-protocols -serverName $serverName -resultPath $resultPath
}
$csec05 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['CipherSuiteOrder'] = 'TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P521,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P521,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P521,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P256,TLS_RSA_WITH_AES_256_GCM_SHA384,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_3DES_EDE_CBC_SHA'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Security Settings 5: Cipher Suite Order'
<#
    DESCRIPTION: 
        Ensure the security cipher order is set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings.

    REQUIRED-INPUTS:
        CipherSuiteOrder - "LARGE" - Single comma seperated string list of cipher suites in the order that they should be used in

    DEFAULT-VALUES:
        CipherSuiteOrder = 'TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P521,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P521,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P521,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P256,TLS_RSA_WITH_AES_256_GCM_SHA384,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_3DES_EDE_CBC_SHA'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Cipher suite order set correctly
        WARNING:
        FAIL:
            Cipher suite order not set correctly
            Cipher suite order set to the default value
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-05-schannel-p5-cipher-order
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-05-schannel-p5-cipher-order'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SOFTWARE\Policies\Microsoft\Cryptography\Configuration\SSL\00010002')
        If ($regKey) { $keyVal = $regKey.GetValue('Functions') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()

    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq $script:appSettings['CipherSuiteOrder'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Cipher suite order set correctly'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Cipher suite order not set correctly'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Cipher suite order set to the default value'
    }

    Return $result
}
c-sec-05-schannel-p5-cipher-order -serverName $serverName -resultPath $resultPath
}
$csec06 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Reject Annonymous Account Enumeration'
<#
    DESCRIPTION: 
        Ensure the system is set to reject attempts to enumerate accounts in the SAM by anonymous users.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Reject annonymous account enumeration is enabled
        WARNING:
        FAIL:
            Reject annonymous account enumeration is disabled
            Registry setting not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-06-reject-enumerate-accounts
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-06-reject-enumerate-accounts'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Lsa')
        If ($regKey) { $keyVal = $regKey.GetValue('restrictanonymousSAM') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq '1')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Reject annonymous account enumeration is enabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Reject annonymous account enumeration is disabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
c-sec-06-reject-enumerate-accounts -serverName $serverName -resultPath $resultPath
}
$csec07 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Reject Annonymous Share Enumeration'
<#
    DESCRIPTION: 
        Ensure the system is set to reject attempts to enumerate shares in the SAM by anonymous users. 

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Reject annonymous share enumeration is enabled
        WARNING:
        FAIL:
            Reject annonymous share enumeration is disabled
            Registry setting not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-07-reject-enumerate-shares
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-07-reject-enumerate-shares'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Lsa')
        If ($regKey) { $keyVal = $regKey.GetValue('restrictanonymous') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }
 
    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq '1')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Reject annonymous share enumeration is enabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Reject annonymous share enumeration is disabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
c-sec-07-reject-enumerate-shares -serverName $serverName -resultPath $resultPath
}
$csec08 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Domain Credential Caching'
<#
    DESCRIPTION: 
        Check system is not caching domain credentials.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Domain credential caching is disabled
        WARNING:
        FAIL:
            Domain credential caching is enabled
            Registry setting not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-08-domain-credential-caching
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-08-domain-credential-caching'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon')
        If ($regKey) { $keyVal = $regKey.GetValue('CachedLogonsCount') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }
    
    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq '0')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Domain credential caching is disabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Domain credential caching is enabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
c-sec-08-domain-credential-caching -serverName $serverName -resultPath $resultPath
}
$csec09 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ElevatePromptForAdminCredentials'] = ('1', '3')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Elevate Prompt For Admin Credentials'
<#
    DESCRIPTION: 
        Ensure the system is set to request administrative credentials before granting an application elevated privileges. 
        Default setting is either "(1):Prompt for credentials on the secure desktop" or "(3):Prompt for credentials"
        Values and meanings can be seen here - https://msdn.microsoft.com/en-us/library/cc232761.aspx

    REQUIRED-INPUTS:
        ElevatePromptForAdminCredentials - "0,1,2,3,4,5" - List of settings to check for

    DEFAULT-VALUES:
        ElevatePromptForAdminCredentials = ('1', '3')

    DEFAULT-STATE:
        Enabled

    INPUT-DESCRIPTION:
        0: No elevated prompt
        1: Prompt for password on a secure desktop
        2: Show Permit/Deny on a secure desktop
        3: Prompt for password on a normal desktop
        4: Show Permit/Deny on a normal desktop
        5: Permit/Deny for non-Windows binaries on a secure desktop

    RESULTS:
        PASS:
            Prompt for credentials is enabled
        WARNING:
        FAIL:
            System is not set to "Prompt for credentials" when launching an application with elevated privileges
            Registry setting not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-09-request-admin-elevated
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-09-request-admin-elevated'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System')
        If ($regKey) { $keyVal = $regKey.GetValue('ConsentPromptBehaviorAdmin') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($script:appSettings['ElevatePromptForAdminCredentials'] -contains $keyVal)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Prompt for credentials is enabled'
            $result.data    = ''
        }
        Else
        {
            $result.data = 'Current setting: '
            Switch ($keyVal)
            {
                0 { $result.data += 'Elevate without prompting'                    }
                1 { $result.data += 'Prompt for credentials on the secure desktop' }    # Default Setting
                2 { $result.data += 'Prompt for consent on the secure desktop'     }
                3 { $result.data += 'Prompt for credentials'                       }    # Default Setting
                4 { $result.data += 'Prompt for consent'                           }
                5 { $result.data += 'Prompt for consent for non-Windows binaries'  }
            }
        
            $result.result  = $script:lang['Fail']
            $result.message = 'System is not set to "Prompt for credentials" when launching an application with elevated privileges'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
c-sec-09-request-admin-elevated -serverName $serverName -resultPath $resultPath
}
$csec10 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Reject Annonymous Pipe/Share Access'
<#
    DESCRIPTION: 
        Ensure the system is set to restrict anonymous access to named pipes

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Restrict annonymous pipe/share access is enabled
        WARNING:
        FAIL:
            Restrict annonymous pipe/share access is disabled
            Registry setting not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-10-anonymous-pipe-share-access
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-10-anonymous-pipe-share-access'

    #... CHECK STARTS HERE ...#

    Try
    {    
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\LanManServer\Parameters')
        If ($regKey) { $keyVal = $regKey.GetValue('restrictnullsessaccess') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq '1')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Restrict annonymous pipe/share access is enabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Restrict annonymous pipe/share access is disabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
c-sec-10-anonymous-pipe-share-access -serverName $serverName -resultPath $resultPath
}
$csec11 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'IIS Default Page'
<#
    DESCRIPTION: 
        Checks to see if the default webpage is present in IIS, it should be removed.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            IIS Installed, "iisstart.htm" not listed in default documents
        WARNING:
        FAIL:
            IIS Installed, default document "iisstart.htm" configured
        MANUAL:
        NA:
            IIS not Installed

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-NameSpace
#>

Function c-sec-11-iis-default-page
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-11-iis-default-page'

    #... CHECK STARTS HERE ...#

    Try
    {
        If ((Check-NameSpace -ServerName $serverName -NameSpace 'ROOT\MicrosoftIISv2') -eq $true)
        {
            # IISv6
            [string]$query  = "SELECT DefaultDoc FROM IISWebServerSetting"
            [string]$chktmp = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\MicrosoftIISv2 | Select-Object -ExpandProperty DefaultDoc
            If ($chktmp -ne $null) { $check = $chktmp.Replace(',', ', ') }
        }
        ElseIf ((Check-NameSpace -ServerName $serverName -NameSpace 'ROOT\WebAdministration') -eq $true)
        {
            # IISv7
            [string]$query  = "SELECT Files FROM DefaultDocumentSection"
            [array] $chktmp = (Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\WebAdministration).Files.Files | Select-Object -ExpandProperty Value
            If ($chktmp -ne $null) { [string]$check = [string]::Join(', ', $chktmp) }
        }
        Else
        {
            [string]$check = $null    # IIS not installed
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = 'SCRIPT ERROR 1'
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($check) -eq $true)
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'IIS not Installed'
        $result.data    = ''
    }
    Else
    {
        $result.message = 'IIS Installed, '
        If ($check -like '*iisstart.htm*')
        {
            $result.result   = $script:lang['Fail']
            $result.message += 'default document "iisstart.htm" configured'
            $result.data     = '' + $check
        }
        Else
        {
            $result.result   = $script:lang['Pass']
            $result.message += '"iisstart.htm" not listed in default documents'
            $result.data     = '' + $check
        }
    }

    Return $result
}
Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-sec-11-iis-default-page -serverName $serverName -resultPath $resultPath
}
$csec12 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'SMB Signing On'
<#
    DESCRIPTION: 
        Ensure SMB signing is turned on. 

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            SMB Signing configured correctly
        WARNING:
        FAIL:
            SMB Signing not configured correctly
            Registry setting not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-12-smb-signing-on
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-12-smb-signing-on'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters')
        If ($regKey) { $keyVal1 = $regKey.GetValue('RequireSecuritySignature') }
        Try { $regKey.Close() } Catch { }

        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters')
        If ($regKey) { $keyVal2 = $regKey.GetValue('RequireSecuritySignature') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If (([string]::IsNullOrEmpty($keyVal1) -eq $false) -or ([string]::IsNullOrEmpty($keyVal2) -eq $false))
    {
        $missing = ''
        If ($keyVal1 -eq '1') { $missing  = '' } Else { $missing  = 'LanmanServer,#'    }
        If ($keyVal2 -eq '1') { $missing += '' } Else { $missing += 'LanmanWorkstation' }

        If ($missing -eq '')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'SMB Signing configured correctly'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'SMB Signing not configured correctly'
            $result.data    = 'The following sections are not configured correctly: {0}' -f $missing
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }

    Return $result
}
c-sec-12-smb-signing-on -serverName $serverName -resultPath $resultPath
}
$csec13 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductNames'] = ('RSA Authentication Manager', 'RSA Authentication Agent')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'RSA Monitoring Installed'
<#
    DESCRIPTION: 
        If server is Domain Controller or a Terminal Server ensure RSA authentication manager is installed and PIN is required to access server.

    REQUIRED-INPUTS:
        ProductNames - List of product names to search for

    DEFAULT-VALUES:
        ProductNames = ('RSA Authentication Manager', 'RSA Authentication Agent')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            {product} found
        WARNING:
        FAIL:
            RSA software not found
        MANUAL:
        NA:
            Not a domain controller or terminal services server

    APPLIES:
        Domain Controllers
        Terminal Servers

    REQUIRED-FUNCTIONS:
        Check-Software
        Check-DomainController
        Check-TerminalServer
#>

Function c-sec-13-rsa-authentication
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-13-rsa-authentication'

    #... CHECK STARTS HERE ...#

    If (((Check-DomainController $serverName) -eq $true) -or ((Check-TerminalServer $serverName) -eq $true))
    {
        Try
        {
            [boolean]$found = $false
            $script:appSettings['ProductNames'] | ForEach {
                [string]$verCheck = Check-Software -serverName $serverName -displayName $_
                If ($verCheck -eq '-1') { Throw 'Error opening registry key' }
                If ([string]::IsNullOrEmpty($verCheck) -eq $false)
                {
                    $found            = $true
                    [string]$prodName = $_
                    [string]$prodVer  = $verCheck
                }
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($found -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'RSA software found'
            $result.data    = '{0}, Version {1}' -f $prodName, $prodVer
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'RSA software not found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a domain controller or terminal services server'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Check-Software
{
    Param ([string]$ServerName, [string]$DisplayName)
    Try {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() } }
    Catch { Return '-1' }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } } }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Check-Software -ServerName $serverName -DisplayName $displayName }
            Else { $verCheck = $null } } }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Check-DomainController
{
    Param ([string]$ServerName)
    Try {
        $query = "SELECT DomainRole FROM Win32_ComputerSystem"
        $check = Get-WmiObject -ComputerName $ServerName -Query $query -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object DomainRole
        If ($check.DomainRole -eq 4 -or $check.DomainRole -eq 5) { Return $true } }
    Catch { Return $false }
    Return $false
}
Function Check-TerminalServer
{
    Param ([string]$ServerName)
    Try {
        If ((Check-NameSpace -serverName $ServerName -namespace 'ROOT\Cimv2\TerminalServices' -ErrorAction Stop) -eq $true) {
            If ((Get-WmiObject -ComputerName $ServerName -Namespace ROOT\Cimv2\TerminalServices -List 'Win32_TerminalServiceSetting' -ErrorAction Stop).Name -eq 'Win32_TerminalServiceSetting') {
                $query = "SELECT TerminalServerMode FROM Win32_TerminalServiceSetting"
                $check = Get-WmiObject -ComputerName $ServerName -Query $query -Namespace ROOT\Cimv2\TerminalServices -Authentication PacketPrivacy -Impersonation Impersonate -ErrorAction Stop | Select-Object TerminalServerMode
                If ($check.TerminalServerMode -eq 1) { Return $true }
        } } }
    Catch { Return $false }
    Return $false
}

Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-sec-13-rsa-authentication -serverName $serverName -resultPath $resultPath
}
$csec14 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseFirewallAppRules'] = ('MSExchange', 'Microsoft', 'McAfee', 'macmnsvc', 'System Center', 'nbwin', 'Java', 'Firefox', 'Chrome')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Additional Firewall Rules'
<#
    DESCRIPTION: 
        Checks to see if there are any addional firewall rules, and warns if there are any.  This ignores all default pre-configured rules, and netbackup ports rules (1556, 13724).

    REQUIRED-INPUTS:
        IgnoreTheseFirewallAppRules - List of known firewall rules to ignore

    DEFAULT-VALUES:
        IgnoreTheseFirewallAppRules = ('MSExchange', 'Microsoft', 'McAfee', 'macmnsvc', 'System Center', 'nbwin', 'Java', 'Firefox', 'Chrome')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No additional firewall rules exist
        WARNING:
            One or more additional firewall rules exist, check they are required
        FAIL:
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-14-firewall-rules
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-14-firewall-rules'

    #... CHECK STARTS HERE ...#

    Try
    {
        [array]$check  = @()
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('System\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\FirewallRules')
        If ($regKey)
        {
            ForEach ($key In $regKey.GetValueNames())
            {
                [PSObject]$HashProps = @{ Active=$null; AppPath=$null; Direction=$null; EmbedCtxt=$null; Name=$null; RemotePort=$null }
                ForEach  ($FireWallRule In ($regkey.GetValue($key) -split '\|'))
                {
                    Switch (($FireWallRule -split '=')[0])
                    {
                        'Active'    { [string]$HashProps.Active      = ($FireWallRule -split '=')[1] }
                        'App'       { [string]$HashProps.AppPath     = ($FireWallRule -split '=')[1] }
                        'Dir'       { [string]$HashProps.Direction   = ($FireWallRule -split '=')[1] }
                        'EmbedCtxt' { [string]$HashProps.EmbedCtxt   = ($FireWallRule -split '=')[1] }
                        'Name'      { [string]$HashProps.Name        = ($FireWallRule -split '=')[1] }
                        'RPort'     { [array] $HashProps.RemotePort += ($FireWallRule -split '=')[1] }
                    }
                }
                If ((($HashProps.Name       -notlike     '@*'  ) -or ($HashProps.EmbedCtxt  -notlike     '@*'   )) -and `
                    (($HashProps.RemotePort -notcontains '1556') -or ($HashProps.RemotePort -notcontains '13724'))) { $check += (New-Object -TypeName PSObject -Property $HashProps) }
            }
        }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($check) -eq $false)
    {
        [System.Collections.ArrayList]$check2 = @(); $check | ForEach { $check2 += $_ }
        $check2 = $check2 | Sort-Object Direction, Name
        If ($script:appSettings['IgnoreTheseFirewallAppRules'].Length -gt 1) {
            $check | ForEach-Object {
                ForEach ($exclude In $script:appSettings['IgnoreTheseFirewallAppRules']) {
                    If ($_.Name -match $exclude) { $check2.Remove($_) }
                }
            }
        }

        If ($check2.count -gt 0)
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'One or more additional firewall rules exist, check they are required'
            $check2 | ForEach-Object {
                If ($_.Active -eq 'False') {$act=' (Disabled)'} Else {$act=''}
                $result.data += '({0}) {1}{2},#' -f $_.Direction, $_.Name, $act }
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'No additional firewall rules exist'
        }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No additional firewall rules exist'
    }

    Return $result
}
c-sec-14-firewall-rules -serverName $serverName -resultPath $resultPath
}
$csec15 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DomainProfile'] = '0'
$script:appSettings['PublicProfile'] = '0'
$script:appSettings['StandardProfile'] = '0'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Check Firewall State'
<#
    DESCRIPTION: 
        Check if Windows firewall is enabled or disabled for each of the three profiles.  Set to "0" for off, and "1" for on

    REQUIRED-INPUTS:
        DomainProfile   - "0|1" - Domain firewall state (enabled / disabled)
        PublicProfile   - "0|1" - Public firewall state (enabled / disabled)
        StandardProfile - "0|1" - Standard (Home) firewall state (enabled / disabled)

    DEFAULT-VALUES:
        DomainProfile   = '0'
        PublicProfile   = '0'
        StandardProfile = '0'

    DEFAULT-STATE:
        Enabled

    INPUT-DESCRIPTION:
        0: Disabled
        1: Enabled

    RESULTS:
        PASS:
            Windows firewall is set correctly
        WARNING: 
        FAIL:
            Windows firewall is not set correctly
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-15-firewall-state
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-15-firewall-state'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        Try { [string]$regDP = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\DomainProfile'  ).GetValue('EnableFirewall') } Catch { [string]$regDP = 'Unknown' }
        Try { [string]$regSP = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile').GetValue('EnableFirewall') } Catch { [string]$regSP = 'Unknown' }
        Try { [string]$regPP = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\PublicProfile'  ).GetValue('EnableFirewall') } Catch { [string]$regPP = 'Unknown' }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $result.data = ''
    If ($regDP -ne $script:appSettings['DomainProfile']  ) { $result.data += (  'Domain profile is {0}, but should be {1},#' -f $regDP, $script:appSettings['DomainProfile']  ) }
    If ($regSP -ne $script:appSettings['StandardProfile']) { $result.data += ('Standard profile is {0}, but should be {1},#' -f $regSP, $script:appSettings['StandardProfile']) }
    If ($regPP -ne $script:appSettings['PublicProfile']  ) { $result.data += (  'Public profile is {0}, but should be {1},#' -f $regPP, $script:appSettings['PublicProfile']  ) }

    If ($result.data -eq '')
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Windows firewall is set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Windows firewall is not set correctly'
        $result.data    = ($result.data).Replace('0', 'disabled').Replace('1', 'enabled')
    }

    Return $result
}
c-sec-15-firewall-state -serverName $serverName -resultPath $resultPath
}
$csec16 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreThesePorts'] = ('5985', '5986', '8192')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Open Ports'
<#
    DESCRIPTION: 
        Returns a list of ports that are open, excluding anything lower than 1024 and within the dynamic port range.  Will also exclude other well known ports.
        !nIMPORTANT: THIS WORKS FOR LOCAL SERVERS ONLY

    REQUIRED-INPUTS:
        IgnoreThesePorts - List of port numbers to ignore|Integer

    DEFAULT-VALUES:
        IgnoreThesePorts = ('5985', '5986', '8192')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No extra ports are open
        WARNING:
        FAIL:
            One or more extra ports are open
        MANUAL:
        NA:
            This check is for local servers only

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-16-open-ports
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-16-open-ports'

    #... CHECK STARTS HERE ...#

    # List of well known exclusions
    $script:appSettings['IgnoreThesePorts'] += '47001'    # WinRM Listener - 5985 and 5986 are in settings file
    $script:appSettings['IgnoreThesePorts'] +=  '1311'    # Dell OpenManage Server Administrator
    $script:appSettings['IgnoreThesePorts'] +=  '1556'    # NetBackup Agent
    $script:appSettings['IgnoreThesePorts'] +=  '2381'    # HPE System Management Home Page
    $script:appSettings['IgnoreThesePorts'] +=  '4750'    # BladeLogic Agent
#   $script:appSettings['IgnoreThesePorts'] +=  '0000'    # 

    If ($serverName -like "$env:ComputerName*")
    {
        Try
        {
            $TCPProperties = [System.Net.NetworkInformation.IPGlobalProperties]::GetIPGlobalProperties()
            [System.Net.IPEndPoint[]]$Connections = $TCPProperties.GetActiveTcpListeners() | Sort-Object -Property Port

            [int]$portStart = -1; [int]$portCount = -1
            [string[]]$dynPorts = Invoke-Command -ScriptBlock { &"netsh.exe" int ipv4 show dynamicportrange tcp } -ErrorAction SilentlyContinue

            If ($dynPorts.Count -gt 0)
            {
                $portStart = ($dynPorts[3].Split(':')[1])
                $portCount = ($dynPorts[4].Split(':')[1])
            }

            If ($portStart -eq -1) { $portStart = 49152 }    # Default values for
            If ($portCount -eq -1) { $portCount = 16384 }    # dynamic port range
            [int]$portEnd   = ($portStart + $portCount)

            [array]$PortList = @()
            ForEach ($Port In $Connections.Port)
            {
                If (($script:appSettings['IgnoreThesePorts'] -notcontains $Port) -and ($Port -gt 1024) -and (($Port -lt $portStart) -or ($Port -gt $portEnd))) { $PortList += ($Port -as [string]) }
            }

            $PortList = ($PortList | Select-Object -Unique)    # Select Unique values only

            If ($PortList.Count -gt 0)
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'One or more extra ports are open'
                $result.data    = $($PortList -join ', ')
            }
            Else
            {
                $result.result   = $script:lang['Pass']
                $result.message += 'No extra ports are open'
            }

            $result.data += ',#Ignoring: 0-1024, '
            $script:appSettings['IgnoreThesePorts'] | Sort-Object | ForEach { $result.data += "$_, " }
            $result.data += "$portStart-$portEnd"
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }
    }
    Else
    {
        $result.result  = $script:lang['Manual']
        $result.message = 'This check is for local servers only'
        $result.data    = "Run 'NBTSTAT -A' on the remote server and check the results.  Ignore the following ports:,#0-1024, "
        $script:appSettings['IgnoreThesePorts'] | Sort-Object | ForEach { $result.data += "$_, " }
        $result.data   += "49152-65535"
    }

    Return $result
}
c-sec-16-open-ports -serverName $serverName -resultPath $resultPath
}
$csec17 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'SMBv1 Disabled'
<#
    DESCRIPTION: 
        Ensure SMBv1 is disabled. 

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            SMBv1 is disabled
        WARNING:
        FAIL:
            SMBv1 is enabled
            Registry setting not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sec-17-smb1-disabled
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sec-17-smb1-disabled'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters')
        If ($regKey) { $keyVal = $regKey.GetValue('SMB1') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq '0')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'SMBv1 is disabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'SMBv1 is enabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = 'HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters,#DWORD: SMBv1, Value: 0'
    }

    Return $result
}
c-sec-17-smb1-disabled -serverName $serverName -resultPath $resultPath
}
$csys01 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Pending Reboot'
<#
    DESCRIPTION: 
        Check for a pending reboot.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Server is not waiting for a reboot
        WARNING:
        FAIL:
            Server is waiting for a reboot
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-01-pending-reboot
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-01-pending-reboot'
    
    #... CHECK STARTS HERE ...#

    Try {
        $result.data = ''
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)

        Try {
            $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing')
            If ($regKey) { ForEach ($regVal In $regKey) { If ($regVal -contains 'RebootPending') { $result.data += 'Pending trusted installer operations,#'; Break } } }
            Try { $regKey.Close() } Catch { }
        } Catch { }

        Try {
            $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update')
            If ($regKey) { ForEach ($regVal In $regKey.GetSubKeyNames()) { If ($regVal -contains 'RebootRequired') { $result.data += 'Pending windows updates,#'; Break } } }
            Try { $regKey.Close() } Catch { }
        } Catch { }

        Try {
            $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Session Manager')
            If ($regKey.GetValue('PendingFileRenameOperations') -ne $null)
            {
                ForEach ($pfro In $regKey.GetValue('PendingFileRenameOperations'))
                { If (($pfro -ne '') -and ($pfro -notlike '*VMwareDnD*')) { $result.data += 'Pending file rename operations,#'; Break } }
            }
            Try { $regKey.Close() } Catch { }
        } Catch { }

        Try {
            $regKey1 = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName\')
            $regKey2 = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName\')
            If ($regKey1.GetValue('ComputerName') -ne $regKey2.GetValue('ComputerName')) { $result.data += 'Pending computer rename,#' }
            Try { $regKey1.Close(); $regKey2.Close() } Catch { }
        } Catch { }

        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($result.data -eq '')
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Server is not waiting for a reboot'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Server is waiting for a reboot'
    }

    Return $result
}
c-sys-01-pending-reboot -serverName $serverName -resultPath $resultPath
}
$csys02 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Windows License'
<#
    DESCRIPTION: 
        Check windows is licensed.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Windows is licenced, Port 1688 open to KMS Server {server}
        WARNING:
        FAIL:
            Windows is licenced, Port 1688 not open to KMS Server {server}
            Windows licence check failed
            Windows not licenced
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-Port
#>

Function c-sys-02-windows-license
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-02-windows-license'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        If ((Get-WmiObject -ComputerName $serverName -Namespace ROOT\Cimv2 -List 'SoftwareLicensingProduct').Name -eq 'SoftwareLicensingProduct')
        {
            [string]$query1 = 'SELECT LicenseStatus FROM SoftwareLicensingProduct WHERE ApplicationID="55c92734-d682-4d71-983e-d6ec3f16059f" AND NOT LicenseStatus = "0"'
            [array] $check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty LicenseStatus
        }

        If ((Get-WmiObject -ComputerName $serverName -Namespace ROOT\Cimv2 -List 'SoftwareLicensingService').Name -eq 'SoftwareLicensingService')
        {
            [string]$query2 = "SELECT KeyManagementServiceMachine, DiscoveredKeyManagementServiceMachineName FROM SoftwareLicensingService"
            [object]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Select KeyManagementServiceMachine, DiscoveredKeyManagementServiceMachineName
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    [string]$kms    = ''
    [string]$status = ''
    If ($check1.Count -gt 0)
    {
        Switch ($check1[0])
        {
                  1 { $status = 'Licensed';                      Break }    # <-- Requried for PASS
                  2 { $status = 'Out-Of-Box Grace Period';       Break }
                  3 { $status = 'Out-Of-Tolerance Grace Period'; Break }
                  4 { $status = 'Non-Genuine Grace Period';      Break }
                  5 { $status = 'Notification';                  Break }
                  6 { $status = 'Extended Grace';                Break }
            Default { $status = 'Unknown'                              }
        }
    }
    Else
    {
        $status = 'Not Licensed'
    }    

    If ($check2.DiscoveredKeyManagementServiceMachineName -ne '') { $kms = $check2.DiscoveredKeyManagementServiceMachineName }
    If ($check2.KeyManagementServiceMachine               -ne '') { $kms = $check2.KeyManagementServiceMachine               }

    If ($kms -ne '')
    {
        [boolean]$portTest = Check-Port -serverName $kms -Port 1688
        If ($portTest -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.data    = ('Port 1688 open to KMS Server {0}' -f $kms.ToLower())
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.data    = ('Port 1688 not open to KMS Server {0}' -f $kms.ToLower())
        }
    }
    Else
    {
        $result.result  = $script:lang['Warning']
        $result.data    = 'Not using a KMS server'
    }

    If ($status -eq 'Licensed')
    {
        $result.message = 'Windows is licenced'
    }
    ElseIf ($status -eq '')
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Windows licence check failed'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Windows not licenced'
        $result.data    = ('Status: {0},#{1}' -f $status, $result.data)
    }

    Return $result
}
Function Check-Port
{
    Param ([string]$ServerName, [string]$Port)
    Try {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($ServerName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
    } } Catch { Return $false }
}
c-sys-02-windows-license -serverName $serverName -resultPath $resultPath
}
$csys03 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseServices'] = ('NetBackup Bare Metal Restore Boot Server', 'NetBackup SAN Client Fibre Transport Service', 'Microsoft .NET Framework NGEN', 'Software Protection', 'Volume Shadow Copy')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Services Not Started'
<#
    DESCRIPTION: 
        Check services and ensure all services set to start automatically are running (NetBackup Bare Metal Restore Boot Server, 
        NetBackup SAN Client Fibre Transport Service and .NET4.0 are all expected to be Automatic but not running).

    REQUIRED-INPUTS:
        IgnoreTheseServices - List of known services that can ignored when set to automatic and not started

    DEFAULT-VALUES:
        IgnoreTheseServices = ('NetBackup Bare Metal Restore Boot Server', 'NetBackup SAN Client Fibre Transport Service', 'Microsoft .NET Framework NGEN', 'Software Protection', 'Volume Shadow Copy')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All auto-start services are running
        WARNING:
        FAIL:
            An auto-start service was found not running
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-03-services-not-started
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-03-services-not-started'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Name, DisplayName FROM Win32_Service WHERE StartMode="Auto" AND Started="False"'
        $script:appSettings['IgnoreTheseServices'] | ForEach { $query += ' AND NOT DisplayName LIKE "%{0}%"' -f $_ }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, DisplayName
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        ForEach ($service In $check)
        {
            Try
            {
                # Check for and ignore "Trigger Start" services
                $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
                $regKey = $reg.OpenSubKey("SYSTEM\CurrentControlSet\Services\$($service.Name)\TriggerInfo\0")
                Try { $regKey.Close() } Catch { }
                $reg.Close()
            }
            Catch { }

            If (-not $regKey)
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'An auto-start service was found not running'
                $result.data   += '{0},#' -f $($service.DisplayName)
            }
            Else { }    # Automatic trigger started serivce that is stopped - Ignore it.
        }
    }

    If ($result.message -eq '')
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All auto-start services are running'
        $result.data    = ''
    }
    
    Return $result
}
c-sys-03-services-not-started -serverName $serverName -resultPath $resultPath
}
$csys04 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['CheckTheseServices'] = ('')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Services Not Stopped'
<#
    DESCRIPTION: 
        Check services and ensure all listed services are set to disabled and are stopped.

    REQUIRED-INPUTS:
        CheckTheseServices - List of known serivces that should be in a disabled state

    DEFAULT-VALUES:
        CheckTheseServices = ('')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All services are configured correctly
        WARNING:
        FAIL:
            One or more services are configured incorrectly
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-04-services-not-stopped
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-04-services-not-stopped'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DisplayName, StartMode, State FROM Win32_Service WHERE DisplayName = "null"'
        $script:appSettings['CheckTheseServices'] | ForEach { $query += ' OR DisplayName = "{0}"' -f $_ }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object DisplayName, StartMode, State
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        ForEach ($service In $check)
        {
            $st = ''; $sm = ''
            If ($service.State     -ne 'Stopped' ) { $st = $service.State     }
            If ($service.StartMode -ne 'Disabled') { $sm = $service.StartMode }
            If (($st -ne '') -or ($sm -ne ''))     { $result.data += '{0} ({1}/{2}),#' -f $service.DisplayName, $sm, $st }
        }

        If ($result.data.Length -gt 1)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more services are configured incorrectly'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All services are configured correctly'
        }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All services are configured correctly'
    }
    
    Return $result
}
c-sys-04-services-not-stopped -serverName $serverName -resultPath $resultPath
}
$csys05 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['EventLogMaxSize'] = '16'
$script:appSettings['EventLogRetentionType'] = 'Overwrite'
$script:appSettings['GetLatestEntriesAge'] = '14'
$script:appSettings['GetLatestEntriesCount'] = '15'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'System Event Log Errors And Configuration'
<#
    DESCRIPTION: 
        Check System Event Log and ensure no errors are present in the last x days.  If found, will return the latest y entries

    REQUIRED-INPUTS:
        EventLogMaxSize       - Maximum size in MB of this event log (default is 16)
        EventLogRetentionType - "Overwrite|Archive|Manual" - When the maximum log size is reached
        GetLatestEntriesAge   - Return all entries for this number of days|Integer
        GetLatestEntriesCount - Return this number of entries|Integer

    DEFAULT-VALUES:
        EventLogMaxSize       = '16'
        EventLogRetentionType = 'Overwrite'
        GetLatestEntriesAge   = '14'
        GetLatestEntriesCount = '15'

    DEFAULT-STATE:
        Enabled

    INPUT-DESCRIPTION:
        Overwrite: Overwrite as needed (oldest first)
        Archive: Archive log when full
        Manual: Do not overwrite (clear manually)

    RESULTS:
        PASS:
            No errors found in system event log
        WARNING:
            Errors were found in the system event log
        FAIL:
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-05-system-event-log
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-05-system-event-log'

    #... CHECK STARTS HERE ...#

    Try
    {
        # Get size and retention
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey("SYSTEM\CurrentControlSet\Services\EventLog\System")
        If ($regKey)
        {
            [int64] $keyValMS = $regKey.GetValue('MaxSize')               # Size in bytes
            [string]$keyValR1 = $regKey.GetValue('Retention')             # Either '0' or '-1'
            [string]$keyValR2 = $regKey.GetValue('AutoBackupLogFiles')    # Either '0' or '1'
        }
        Try { $regKey.Close() } Catch { }
        $reg.Close()

        # Get log entries
        If ($PSVersionTable.PSVersion.Major -ge 4)
        {
            [double]$timeOffSet = ($script:appSettings['GetLatestEntriesAge'] -as [int]) * 60 * 60 * 24 * 1000    # Convert 'days' into 'miliseconds'
            [xml]   $xml        = '<QueryList><Query Id="0" Path="System"     ><Select Path="System"     >*[System[(Level=1 or Level=2) and TimeCreated[timediff(@SystemTime) &lt;= {0}]]]</Select></Query></QueryList>' -f $timeOffSet
            [object]$check      = Get-WinEvent -ComputerName $serverName -MaxEvents $script:appSettings['GetLatestEntriesCount'] -FilterXml $xml -ErrorAction SilentlyContinue | Select LevelDisplayName, TimeCreated, Id, ProviderName, Message
        }
        Else
        {
            $check = Get-EventLog -ComputerName $serverName -LogName System      -EntryType Error -Newest $script:appSettings['GetLatestEntriesCount'] -After (Get-Date).AddDays(-($script:appSettings['GetLatestEntriesAge'])) -ErrorAction SilentlyContinue
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $result.message = ''
    $result.data    = ''

    # Check max size
    $keyValMS = ($keyValMS / (1024*1024))    # Convert B to MB
    If ($keyValMS -ne $script:appSettings['EventLogMaxSize'])
    {
        $result.result   = $script:lang['Fail']
        $result.message += 'Event log max size is not set correctly,#'
        $result.data    += ('Current Max Size: {0},#' -f $keyValMS)
    }

    # Check retension type
    Switch ($script:appSettings['EventLogRetentionType'])
    {                 #       Retention                 AutoBackupLogFiles
        'Overwrite' { [string]$checkValR1 =  '0';[string]$checkValR2 = '0'; Break }
        'Archive'   { [string]$checkValR1 = '-1';[string]$checkValR2 = '1'; Break }
        'Manual'    { [string]$checkValR1 = '-1';[string]$checkValR2 = '0'; Break }
        Default     { Break }
    }

    If (($keyValR1 -ne $checkValR1) -or ($keyValR2 -ne $checkValR2))
    {
        [string]$currRetention = 'Unknown'
        If ($keyValR1 -eq 0) { $currRetention = 'Overwrite' } Else { If ($keyValR2 -eq 0) { $currRetention = 'Manual' } Else { $currRetention = 'Archive' } }
        $result.result   = $script:lang['Fail']
        $result.message += 'Retention method is not set correctly,#'
        $result.data    += ('Current method: {0},#' -f $currRetention)
    }

    # Check event logs
    If ($check.Length -gt 0)
    {
        If ((Test-Path -Path ('{0}EventLogs' -f $resultPath)) -eq $false) { Try { New-Item -Path ('{0}EventLogs' -f $resultPath) -ItemType Directory -Force | Out-Null } Catch {} }
        [string]$outFile = '{0}EventLogs\{1}-Error-Events-System.csv' -f $resultPath, $serverName.ToUpper()
        $check | Export-Csv $outFile -NoTypeInformation

        $result.message += 'Errors were found in the system event log'
        $result.data    += (Split-Path -Path $outFile -Leaf)
    }

    # Pass or fail check
    If ($result.message -ne '')
    {
        $result.result   = $script:lang['Fail']
    }
    Else
    {
        $result.result   = $script:lang['Pass']
        $result.message += 'No errors found in system event log or its configuration'
    }
    
    Return $result
}
c-sys-05-system-event-log -serverName $serverName -resultPath $resultPath
}
$csys06 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['EventLogMaxSize'] = '16'
$script:appSettings['EventLogRetentionType'] = 'Overwrite'
$script:appSettings['GetLatestEntriesAge'] = '14'
$script:appSettings['GetLatestEntriesCount'] = '15'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Application Event Log Errors And Configuration'
<#
    DESCRIPTION: 
        Check Application Event Log and ensure no errors are present in the last x days.  If found, will return the latest y entries

    REQUIRED-INPUTS:
        EventLogMaxSize       - Maximum size in MB of this event log (default is 16)
        EventLogRetentionType - "Overwrite|Archive|Manual" - When the maximum log size is reached
        GetLatestEntriesAge   - Return all entries for this number of days|Integer
        GetLatestEntriesCount - Return this number of entries|Integer

    DEFAULT-VALUES:
        EventLogMaxSize       = '16'
        EventLogRetentionType = 'Overwrite'
        GetLatestEntriesAge   = '14'
        GetLatestEntriesCount = '15'

    DEFAULT-STATE:
        Enabled

    INPUT-DESCRIPTION:
        Overwrite: Overwrite as needed (oldest first)
        Archive: Archive log when full
        Manual: Do not overwrite (clear manually)

    RESULTS:
        PASS:
            No errors found in application event log
        WARNING:
            Errors were found in the application event log
        FAIL:
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-06-application-event-log
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-06-application-event-log'

    #... CHECK STARTS HERE ...#

    Try
    {
        # Get size and retention
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey("SYSTEM\CurrentControlSet\Services\EventLog\Application")
        If ($regKey)
        {
            [int64] $keyValMS = $regKey.GetValue('MaxSize')               # Size in bytes
            [string]$keyValR1 = $regKey.GetValue('Retention')             # Either '0' or '-1'
            [string]$keyValR2 = $regKey.GetValue('AutoBackupLogFiles')    # Either '0' or '1'
        }
        Try { $regKey.Close() } Catch { }
        $reg.Close()

        # Get log entries
        If ($PSVersionTable.PSVersion.Major -ge 4)
        {
            [double]$timeOffSet = ($script:appSettings['GetLatestEntriesAge'] -as [int]) * 60 * 60 * 24 * 1000    # Convert 'days' into 'miliseconds'
            [xml]   $xml        = '<QueryList><Query Id="0" Path="Application"><Select Path="Application">*[System[(Level=1 or Level=2) and TimeCreated[timediff(@SystemTime) &lt;= {0}]]]</Select></Query></QueryList>' -f $timeOffSet
            [object]$check      = Get-WinEvent -ComputerName $serverName -MaxEvents $script:appSettings['GetLatestEntriesCount'] -FilterXml $xml -ErrorAction SilentlyContinue | Select LevelDisplayName, TimeCreated, Id, ProviderName, Message
        }
        Else
        {
            $check = Get-EventLog -ComputerName $serverName -LogName Application -EntryType Error -Newest $script:appSettings['GetLatestEntriesCount'] -After (Get-Date).AddDays(-($script:appSettings['GetLatestEntriesAge'])) -ErrorAction SilentlyContinue
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $result.message = ''
    $result.data    = ''

    # Check max size
    $keyValMS = ($keyValMS / (1024*1024))    # Convert B to MB
    If ($keyValMS -ne $script:appSettings['EventLogMaxSize'])
    {
        $result.result   = $script:lang['Fail']
        $result.message += 'Event log max size is not set correctly,#'
        $result.data    += ('Current Max Size: {0},#' -f $keyValMS)
    }

    # Check retension type
    Switch ($script:appSettings['EventLogRetentionType'])
    {                 #       Retention                 AutoBackupLogFiles
        'Overwrite' { [string]$checkValR1 =  '0';[string]$checkValR2 = '0'; Break }
        'Archive'   { [string]$checkValR1 = '-1';[string]$checkValR2 = '1'; Break }
        'Manual'    { [string]$checkValR1 = '-1';[string]$checkValR2 = '0'; Break }
        Default     { Break }
    }

    If (($keyValR1 -ne $checkValR1) -or ($keyValR2 -ne $checkValR2))
    {
        [string]$currRetention = 'Unknown'
        If ($keyValR1 -eq 0) { $currRetention = 'Overwrite' } Else { If ($keyValR2 -eq 0) { $currRetention = 'Manual' } Else { $currRetention = 'Archive' } }
        $result.result   = $script:lang['Fail']
        $result.message += 'Retention method is not set correctly,#'
        $result.data    += ('Current method: {0},#' -f $currRetention)
    }

    # Check event logs
    If ($check.Length -gt 0)
    {
        If ((Test-Path -Path ('{0}EventLogs' -f $resultPath)) -eq $false) { Try { New-Item -Path ('{0}EventLogs' -f $resultPath) -ItemType Directory -Force | Out-Null } Catch {} }
        [string]$outFile = '{0}EventLogs\{1}-Error-Events-Application.csv' -f $resultPath, $serverName.ToUpper()
        $check | Export-Csv $outFile -NoTypeInformation

        $result.message += 'Errors were found in the application event log'
        $result.data    += (Split-Path -Path $outFile -Leaf)
    }

    # Pass or fail check
    If ($result.message -ne '')
    {
        $result.result   = $script:lang['Fail']
    }
    Else
    {
        $result.result   = $script:lang['Pass']
        $result.message += 'No errors found in application event log or its configuration'
    }
    
    Return $result
}
c-sys-06-application-event-log -serverName $serverName -resultPath $resultPath
}
$csys07 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseDeviceNames'] = ('')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Device Errors'
<#
    DESCRIPTION: 
        Checks Device Manager to ensure there are no unknown devices, conflicts or errors.
        
    REQUIRED-INPUTS:
        IgnoreTheseDeviceNames - List of known devices that can be ignored

    DEFAULT-VALUES:
        IgnoreTheseDeviceNames = ('')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No device errors found
        WARNING:
        FAIL:
            Device errors found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-07-devices-status
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-07-devices-status'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        # Excludes Working (0) and Disabled (22)
        [string]$query = 'SELECT Name, ConfigManagerErrorCode FROM Win32_PnPEntity WHERE NOT ConfigManagerErrorCode = 0 AND NOT ConfigManagerErrorCode = 22'
        $script:appSettings['IgnoreTheseDeviceNames'] | ForEach { $query += ' AND NOT Name = "{0}"' -f $_ }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Device errors found'
        $check | ForEach { $result.data += '{0},#' -f $_ }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No device errors found'
    }
    
    Return $result
}
c-sys-07-devices-status -serverName $serverName -resultPath $resultPath
}
$csys09 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseScheduledTasks'] = ('SQM data sender', 'SystemSoundsService', 'StartComponentCleanup', 'Automatic-Workplace-Join', 'ReplaceOMCert', 'Optimize Start Menu Cache Files')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Scheduled Tasks'
<#
    DESCRIPTION: 
        Check to see if any non standard scheduled tasks exist on  the server (Any application specific scheduled tasks should be documented with a designated contact point specified).
        This check automatically ignores any Microsoft labelled specific tasks.
   
    REQUIRED-INPUTS:
        IgnoreTheseScheduledTasks - List of scheduled tasks that can be ignored

    DEFAULT-VALUES:
        IgnoreTheseScheduledTasks = ('SQM data sender', 'SystemSoundsService', 'StartComponentCleanup', 'Automatic-Workplace-Join', 'ReplaceOMCert', 'Optimize Start Menu Cache Files')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No additional scheduled tasks found
        WARNING:
            Additional scheduled tasks found - make sure these are documented
        FAIL:
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-09-scheduled-tasks
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-09-scheduled-tasks'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Caption FROM Win32_OperatingSystem'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption

        If ($check -notlike '*2003*')
        {
            $schedule = New-Object -ComObject('Schedule.Service')
            $schedule.Connect($serverName) 
            $tasks = Get-Tasks($schedule.GetFolder('\'))
        }
        Else
        {
            # Windows 2003 Servers
            $result.result  = $script:lang['Warning']
            $result.message = 'Operating system not supported by check'
            $result.data    = ''
            Return $result
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $tasksOut = ''
    $tasks | ForEach {
        [xml]   $xml    = $_.Xml
        [string]$author = $xml.Task.RegistrationInfo.Author
        If (($Author -notlike '*Microsoft*') -and ($Author -notlike '*SystemRoot*'))
        {
            If (($_.Name).Contains('-S-1-5-21-')) { [string]$NewName = $($_.Name).Split('-')[0] } Else { [string]$NewName = $_.Name }
            If ($script:appSettings['IgnoreTheseScheduledTasks'] -notcontains $NewName) { [string]$tasksOut += '{0} ({1}),#' -f $_.Name, $author }
        }
    }

    If ($tasksOut -eq '')
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No additional scheduled tasks found'
    }
    Else
    {
        $result.result  = $script:lang['Warning']
        $result.message = 'Additional scheduled tasks found - make sure these are documented'
        $result.data    = $tasksOut
    }
        
    Return $result
}

# Checks all task subfolders, not just root...
Function Get-Tasks
{
    Param ( [Object]$taskFolder )
    $tasks = $taskFolder.GetTasks(0)
    $tasks | ForEach-Object { $_ }
    Try {
        $taskFolders = $taskFolder.GetFolders(0)
        $taskFolders | ForEach-Object { Get-Tasks $_ $true } }
    Catch { }
}
c-sys-09-scheduled-tasks -serverName $serverName -resultPath $resultPath
}
$csys10 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreThesePrinterNames'] = ('Send To OneNote', 'PDFCreator', 'Microsoft XPS Document Writer', 'Fax', 'WebEx Document Loader', 'Microsoft Print To PDF')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Print Spool Directory'
<#
    DESCRIPTION: 
        Check to see if any printers exist on the server. If printers exist, ensure the spooler directory is not stored on the system drive.

    REQUIRED-INPUTS:
        IgnoreThesePrinterNames - List of known printer names to ignore

    DEFAULT-VALUES:
        IgnoreThesePrinterNames = ('Send To OneNote', 'PDFCreator', 'Microsoft XPS Document Writer', 'Fax', 'WebEx Document Loader', 'Microsoft Print To PDF')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Printers found, and spool directory is not set to default path
        WARNING:
        FAIL:
            Spool directory is set to the default path and needs to be changed, Registry setting not found
        MANUAL:
        NA:
            No printers found
            Print Spooler service is not running

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-10-print-spooler
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-10-print-spooler'

    #... CHECK STARTS HERE ...#

    Try
    {
        $svc = Get-Service -ComputerName $serverName -DisplayName 'Print Spooler' | Select-Object -ExpandProperty Status
        If ($svc -eq 'Running')
        {
            [string]$query = 'SELECT Name FROM Win32_Printer WHERE NOT Name="null"'
            $script:appSettings['IgnoreThesePrinterNames'] | ForEach { $query += ' AND NOT Name="{0}"' -f $_ }
            [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
        }
        Else
        {
            [array]$check = 'STOPPED'
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check -eq 'STOPPED')
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Print Spooler service is not running'
    }
    ElseIf (($check -ne $null) -and ($check.Count -gt 0))
    {
        $check | ForEach { $result.data += '{0},#' -f $_ }        

        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Print\Printers')
        If ($regKey) { $keyVal = $regKey.GetValue('DefaultSpoolDirectory') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()

        If ([string]::IsNullOrEmpty($keyVal) -eq $false)
        {
            If ($keyVal -eq $("$env:SystemDrive\Windows\system32\spool\PRINTERS"))
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Spool directory is set to the default path and needs to be changed'
                $result.data    = 'Location: {0},#{1}' -f $keyVal, $result.data
            }
            Else 
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'Printers found, and spool directory is not set to default path'
                $result.data    = 'Location: {0},#{1}' -f $keyVal, $result.data
            }
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Registry setting not found'
            $result.data    = ''
        }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No printers found'
    }

    Return $result
}
c-sys-10-print-spooler -serverName $serverName -resultPath $resultPath
}
$csys11 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Drive Autorun'
<#
    DESCRIPTION: 
        Ensure autorun is disabled.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Autorun is disabled
        WARNING:
        FAIL:
            Autorun is enabled
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-11-autorun-disabled
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-11-autorun-disabled'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer')
        If ($regKey) { $keyVal = $regKey.GetValue('NoDriveTypeAutoRun') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }
 
    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq '255')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Autorun is disabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Autorun is enabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Autorun is enabled'
    }

    Return $result
}
c-sys-11-autorun-disabled -serverName $serverName -resultPath $resultPath
}
$csys12 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'SNMP Configuration'
<#
    DESCRIPTION: 
        Check if SNMP role is install on the server.  If so, ensure the SNMP community strings follow the secure password policy.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            SNMP Service installed, but disabled
        WARNING:
        FAIL:
            SNMP Service installed, no communities configured
        MANUAL:
            SNMP Service installed, communities listed
        NA:
            SNMP Service not installed

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-12-snmp-configuration
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-12-snmp-configuration'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DisplayName, StartMode FROM Win32_Service WHERE DisplayName="SNMP Service"'
        [object]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object DisplayName, StartMode
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($check) -eq $false)
    {
        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\services\SNMP\Parameters\ValidCommunities')
            If ($regKey) { [array]$keyVal = $regKey.GetValueNames() }
            Try { $regKey.Close() } Catch { }
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If (($regKey) -and ($keyVal.Count -gt 0))
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'SNMP Service installed, communities listed'

            ForEach ($key In $keyVal)
            {
                $keyVal_ = $regKey.GetValue($key)
                If ($keyVal_ -eq '4') { $result.data += $key + ' (readonly),#'  }
                If ($keyVal_ -eq '8') { $result.data += $key + ' (readwrite),#' }
            }
        }
        Else
        {
            If ($check.StartMode -eq 'Disabled')
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'SNMP Service installed, but disabled'
            }
            Else
            {
                $result.result  = $script:lang['Warning']
                $result.message = 'SNMP Service installed, no communities configured'
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'SNMP Service not installed'
    }

    Return $result
}
c-sys-12-snmp-configuration -serverName $serverName -resultPath $resultPath
}
$csys13 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Domain Member'
<#
    DESCRIPTION: 
        Checks that the server is a member of the domain.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Server is a domain member
        WARNING:
            This is a workgroup server, is this correct.?
        FAIL:    
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-13-domain-member
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-13-domain-member'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query  = "SELECT PartOfDomain, Domain FROM Win32_ComputerSystem"
        [object]$check  = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object PartOfDomain, Domain
        [string]$domain = ($check.Domain -split '\.')[0]
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.PartOfDomain -eq $true)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Server is a domain member'
        $result.data    = ($check.Domain)
    }
    Else
    {
        $result.result  = $script:lang['Warning']
        $result.message = 'This is a workgroup server, is this correct.?'
        $result.data    = 'Workgroup: {0}' -f $domain
    }

    Return $result
}
c-sys-13-domain-member -serverName $serverName -resultPath $resultPath
}
$csys14 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Power Plan'
<#
    DESCRIPTION: 
        Check power plan is set to High Performance.
        
    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Power plan is set correctly
        WARNING:
        FAIL:
            Power plan is not set correctly
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-NameSpace
#>

Function c-sys-14-power-plan
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-14-power-plan'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        If ((Check-NameSpace -ServerName $serverName -NameSpace 'ROOT\Cimv2\Power') -eq $true)
        {
            [string]$query = 'SELECT ElementName FROM Win32_PowerPlan WHERE IsActive="True"'
            [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2\Power -Authentication PacketPrivacy -Impersonation Impersonate | Select-Object -ExpandProperty ElementName
        }
        If ($check -eq '') { $check = '(Unknown)' }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check -eq 'High Performance')
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Power plan is set correctly'
        $result.data    = $check
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Power plan is not set correctly'
        $result.data    = $check
    }

    Return $result
}
Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-sys-14-power-plan -serverName $serverName -resultPath $resultPath
}
$csys15 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Hibernation'
<#
    DESCRIPTION: 
        Check hibernation is turned off.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Hibernation is currently disabled
        WARNING:
        FAIL:
            Hibernation is currently enabled
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-15-hibernation
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-15-hibernation'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query1 = 'SELECT SystemDrive FROM Win32_OperatingSystem'
        [string]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty SystemDrive
        If ([string]::IsNullOrEmpty($check1) -eq $false)
        {
            # Dev Note: Do not change " to ', it will break this check
            [string]$query2 = "Associators of {Win32_Directory.Name='" + $check1 + "\'} WHERE ResultClass=CIM_DataFile"
            [string]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Where-Object {$_.name -match 'hiberfil.sys'} | Select-Object -ExpandProperty Name
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check2 -like '*hiberfil.sys')
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Hibernation is currently enabled'
        $result.data    = $check2
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Hibernation is currently disabled'
        $result.data    = $check2
    }

    Return $result
}
c-sys-15-hibernation -serverName $serverName -resultPath $resultPath
}
$csys16 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Remote Desktop'
<#
    DESCRIPTION: 
        Check that remote desktop is enabled and that Network Level Authentication (NLA) is set.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Secure remote desktop and NLA enabled
        WARNING:
            Network Level Authentication is not set
        FAIL:
            Secure remote desktop disabled
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-NameSpace
#>

Function c-sys-16-remote-desktop
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-16-remote-desktop'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        If ((Check-NameSpace -ServerName $serverName -NameSpace 'ROOT\Cimv2\TerminalServices') -eq $true)
        {
            [string]$query1 = 'Select AllowTSConnections FROM Win32_TerminalServiceSetting'
            [string]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2\TerminalServices -Authentication PacketPrivacy -Impersonation Impersonate | Select-Object -ExpandProperty AllowTSConnections

            [string]$query2 = 'Select UserAuthenticationRequired FROM Win32_TSGeneralSetting'
            [string]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2\TerminalServices -Authentication PacketPrivacy -Impersonation Impersonate | Select-Object -ExpandProperty UserAuthenticationRequired
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If (($check1 -eq '1') -and ($check2 -eq '1'))
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Secure remote desktop enabled'
    }
    Else
    {
        If ($check1 -eq '0')
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Secure remote desktop disabled'
        }
        Else
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'Secure remote desktop enabled'
            $result.data    = 'Network Level Authentication is not set'
        }
    }

    Return $result
}
Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-sys-16-remote-desktop -serverName $serverName -resultPath $resultPath
}
$csys17 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Terminal Services Licenced'
<#
    DESCRIPTION: 
        If server is a Terminal Services Server ensure it has a licence server set.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Terminal services server is licenced
        WARNING:
        FAIL:
            Terminal services server is not licenced
        MANUAL:
        NA:
            Not a terminal services server

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        Check-TerminalServer
#>

Function c-sys-17-terminal-services-licenced
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-17-terminal-services-licenced'

    #... CHECK STARTS HERE ...#

    If ((Check-TerminalServer $serverName) -eq $true)
    {
        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\TermService\Parameters\LicenseServers')
            If ($regKey) { $keyVal = $regKey.GetValue('SpecifiedLicenseServers') }
            Try { $regKey.Close() } Catch { }
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ([string]::IsNullOrEmpty($keyVal) -eq $false)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Terminal services server is licenced'
            $result.data    = '' + $keyVal
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Terminal services server is not licenced'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a terminal services server'
    }

    Return $result
}
Function Check-TerminalServer
{
    Param ([string]$ServerName)
    Try {
        If ((Check-NameSpace -serverName $ServerName -namespace 'ROOT\Cimv2\TerminalServices' -ErrorAction Stop) -eq $true) {
            If ((Get-WmiObject -ComputerName $ServerName -Namespace ROOT\Cimv2\TerminalServices -List 'Win32_TerminalServiceSetting' -ErrorAction Stop).Name -eq 'Win32_TerminalServiceSetting') {
                $query = "SELECT TerminalServerMode FROM Win32_TerminalServiceSetting"
                $check = Get-WmiObject -ComputerName $ServerName -Query $query -Namespace ROOT\Cimv2\TerminalServices -Authentication PacketPrivacy -Impersonation Impersonate -ErrorAction Stop | Select-Object TerminalServerMode
                If ($check.TerminalServerMode -eq 1) { Return $true }
        } } }
    Catch { Return $false }
    Return $false
}

Function Check-NameSpace
{
    Param ([string]$ServerName, [string]$NameSpace)
    $NameSpace = $NameSpace.Trim('\')
    ForEach ($leaf In $NameSpace.Split('\')) {
        [string]$path += $leaf + '\'
        Try { [string]$wmio = Get-WmiObject -ComputerName $ServerName -Namespace $path.TrimEnd('\') -Class '__Namespace' -ErrorAction Stop | Select-Object -ExcludeProperty Name } Catch { }
        If ($wmio -eq '') { Return $false } Else { $wmio = '' } }
    Return $true
}
c-sys-17-terminal-services-licenced -serverName $serverName -resultPath $resultPath
}
$csys18 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['NoInTheseOUs'] = ('cn=Computers', 'ou=Quarantine')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Check Server OU Location'
<#
    DESCRIPTION: 
        Check that the current server OU path is not in the default location(s).  The list of OUs should contain at least the default "Computers" OU, and must be the full distinguished name of the locations.

    REQUIRED-INPUTS:
        NoInTheseOUs - List of full-path OU names that the servers should not be located in.

    DEFAULT-VALUES:
        NoInTheseOUs = ('cn=Computers', 'ou=Quarantine')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Server not in default location
        WARNING:
        FAIL:
            Server is in default location
        MANUAL:
        NA:
            Not a domain joined server

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-18-check-current-ou
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-18-check-current-ou'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string] $query  = "SELECT PartOfDomain FROM Win32_ComputerSystem"
        [boolean]$check  = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty PartOfDomain

        If ($check -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Server not located in a default OU location'

            $objDomain   = New-Object System.DirectoryServices.DirectoryEntry
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher
            $strFilter   = "(&(objectCategory=computer)(name=$serverName))"
            $objSearcher.SearchRoot = $objDomain
            $objSearcher.Filter     = $strFilter
            [string]$strPath = ($objSearcher.FindOne().Path).ToLower()
            If ([string]::IsNullOrEmpty($strPath) -eq $true) { Throw 'Failed to get OU path from Active Directory' }

                    $strPath   = ($strPath -split "ldap://cn=$($serverName.ToLower()),")[1]    # Remove Computer Name
            [string]$CurrentOU = ($strPath -split ',DC=')[0]                                   # Remove Domain Name

            ForEach ($OU In $script:appSettings['NoInTheseOUs'])
            {
                If ($CurrentOU -like "*$OU")
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = 'Server found in a default OU location'
                    Break
                }
            }

            [string]$splitPath1, $splitPath2 = ($strPath -split ',dc=', 2)
            $result.data   += "$splitPath1,#dc=$splitPath2"
        }
        Else
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'Not a domain joined server'
            $result.data    = ''
        }

        Return $result
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }
}
c-sys-18-check-current-ou -serverName $serverName -resultPath $resultPath
}
$csys19 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['MinimumVersion'] = '7.6'
$script:appSettings['ServiceState'] = 'Disabled'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Check HP SMH Version'
<#
    DESCRIPTION: 
        Check the state of the HPe System Management Homepage service and version

    REQUIRED-INPUTS:
        MinimumVersion - Minimum installed version number allowed|Decimal
        ServiceState   - "Automatic|Manual|Disabled" - Default state of the service

    DEFAULT-VALUES:
        MinimumVersion = '7.6'
        ServiceState   = 'Disabled'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Service state and version are correct
        WARNING:
        FAIL:
            Service state is not correct
            Installed version is below the minimum set
            HPe SMH not installed
        MANUAL:
        NA:
            Not a HPe physical server

    APPLIES:
        All HPe Physical Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-19-hp-smh-version
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-19-hp-smh-version'
    
    #... CHECK STARTS HERE ...#

    If (isHPServer -eq $true)
    {
        Try
        {
            [string]$state = (Get-WmiObject -ComputerName $serverName -Class Win32_Service -Property StartMode -Filter "DisplayName='HP System Management Homepage'") | Select-Object -ExpandProperty StartMode
        }
        Catch
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'HP System Management Homepage not installed'
            $result.data    = ''
            Return $result
        }

        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('SOFTWARE\Hewlett-Packard\System Management Homepage')
            If ($regKey) {
                [string]$keyVal1 = $regKey.GetValue('InstallPath')
                [string]$keyVal2 = $regKey.GetValue('Version')
            }
            Else
            {
                $regKey = $reg.OpenSubKey('SOFTWARE\Wow6432Node\Hewlett-Packard\System Management Homepage')
                If ($regKey) {
                    [string]$keyVal1 = $regKey.GetValue('InstallPath')
                    [string]$keyVal2 = $regKey.GetValue('Version')
                }
            }
            Try { $regKey.Close() } Catch { }
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        $result.result  = $script:lang['Pass']
        $result.message = ''

        If ($state -ne $script:appSettings['ServiceState'])
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Service state is not correct,#'
        }

        If (($keyVal2 -as [version]) -lt ($script:appSettings['MinimumVersion'] -as [version]))
        {
            $result.result   = $script:lang['Fail']
            $result.message += 'Installed version is below the minimum set'
        }

        $result.data = "Install location: $keyVal1,#Installed version: $keyVal2"
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a HPe physical server'
        $result.data    = ''
    }

    Return $result
}

Function isHPServer
{
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Manufacturer
    If ($wmiBIOS.Manufacturer -like 'HP*') { Return $true } Else { Return $false }
}
c-sys-19-hp-smh-version -serverName $serverName -resultPath $resultPath
}
$csys20 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['MinimumVersion'] = '8.4'
$script:appSettings['ServiceState'] = 'Disabled'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Check Dell OMA Version'
<#
    DESCRIPTION: 
        Check the state of the Dell OpenManage Administrator service and version

    REQUIRED-INPUTS:
        MinimumVersion - Minimum installed version number allowed|Decimal
        ServiceState   - "Automatic|Manual|Disabled" - Default state of the service

    DEFAULT-VALUES:
        MinimumVersion = '8.4'
        ServiceState   = 'Disabled'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Service state and version are correct
        WARNING:
        FAIL:
            Service state is not correct
            Installed version is below the minimum set
            Dell OMA not installed
        MANUAL:
        NA:
            Not a Dell physical server

    APPLIES:
        All Dell Physical Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-20-dell-oma-version
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-20-dell-oma-version'
    
    #... CHECK STARTS HERE ...#

    If (isDELLServer -eq $true)
    {
        Try
        {
            [string]$state = (Get-WmiObject -ComputerName $serverName -Class Win32_Service -Property StartMode -Filter "DisplayName='DSM SA Shared Services'") | Select-Object -ExpandProperty StartMode
        }
        Catch
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Dell OMA not installed'
            $result.data    = ''
            Return $result
        }

        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('SOFTWARE\Dell Computer Corporation\Dell OMA')
            If ($regKey) {
                [string]$keyVal1 = $regKey.GetValue('InstallPath')
                [string]$keyVal2 = $regKey.GetValue('Version')
            }
            Else
            {
                $regKey = $reg.OpenSubKey('SOFTWARE\Wow6432Node\Dell Computer Corporation\Dell OMA')
                If ($regKey) {
                    [string]$keyVal1 = $regKey.GetValue('InstallPath')
                    [string]$keyVal2 = $regKey.GetValue('Version')
                }
            }
            Try { $regKey.Close() } Catch { }
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        $result.result  = $script:lang['Pass']
        $result.message = ''

        If ($state -ne $script:appSettings['ServiceState'])
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Service state is not correct,#'
        }

        If (($keyVal2 -as [version]) -lt ($script:appSettings['MinimumVersion'] -as [version]))
        {
            $result.result   = $script:lang['Fail']
            $result.message += 'Installed version is below the minimum set'
        }

        $result.data = "Install location: $keyVal1,#Installed version: $keyVal2"
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Dell physical server'
        $result.data    = ''
    }

    Return $result
}

Function isDELLServer
{
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Manufacturer
    If ($wmiBIOS.Manufacturer -like 'Dell*') { Return $true } Else { Return $false }
}
c-sys-20-dell-oma-version -serverName $serverName -resultPath $resultPath
}
$csys21 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['Registry1Key'] = 'SOFTWARE\Microsoft\Windows NT\CurrentVersion\InstallDate'
$script:appSettings['Registry1Value'] = 'Report Only'
$script:appSettings['Registry2Key'] = ''
$script:appSettings['Registry2Value'] = ''
$script:appSettings['Registry3Key'] = ''
$script:appSettings['Registry3Value'] = ''
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Gold Image Check'
<#
    DESCRIPTION: 
        Allows you to checks a specific list of registry keys and values to see if your in-house gold image was used.
        Up to three registry keys and values can be checked.  Note: All keys must be in HKEY_LOCAL_MACHINE only

    REQUIRED-INPUTS:
        Registry1Key   - "LARGE" -Full path and name of a registry value to check.  "HKEY_LOCAL_MACHINE\" is automatically added.
        Registry1Value - Minimum value or string required for the registry value.  Enter "Report Only" to just show the value.
        Registry2Key   - "LARGE" -Full path and name of a registry value to check.  "HKEY_LOCAL_MACHINE\" is automatically added.
        Registry2Value - Minimum value or string required for the registry value.  Enter "Report Only" to just show the value.
        Registry3Key   - "LARGE" -Full path and name of a registry value to check.  "HKEY_LOCAL_MACHINE\" is automatically added.
        Registry3Value - Minimum value or string required for the registry value.  Enter "Report Only" to just show the value.

    DEFAULT-VALUES:
        Registry1Key   = 'SOFTWARE\Microsoft\Windows NT\CurrentVersion\InstallDate'
        Registry1Value = 'Report Only'
        Registry2Key   = ''
        Registry2Value = ''
        Registry3Key   = ''
        Registry3Value = ''

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All gold build checks were found and correct
        WARNING:
        FAIL:
            One or more gold build checks were below specified value
        MANUAL:
            One or more gold build checks were "Report Only"
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-21-gold-image
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-21-gold-image'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)

        # Registry Key 1
        If ($script:appSettings['Registry1Key'].Length -gt 0)
        {
            [string]$regK1 = ($script:appSettings['Registry1Key'].Split('\')[-1])
            [string]$regP1 = ($script:appSettings['Registry1Key'].SubString(0, $script:appSettings['Registry1Key'].Length - ($regK1.Length + 1)))

            $regKey1 = $reg.OpenSubKey($regP1)
            If ($regKey1) { [string]$keyVal1 = $regKey1.GetValue($regK1) }
            Try { $regKey1.Close() } Catch { }

            # Check to see if it's a date we can convert
            If ($regK1.ToLower().Contains('date')) { If ($keyVal1 -eq ([System.Convert]::ToInt64($keyVal1)))
            { $keyVal1 = ((Get-Date -Date '01/01/1970').AddSeconds(([System.Convert]::ToInt64($keyVal1)))) } }
        }

        # Registry Key 2
        If ($script:appSettings['Registry2Key'].Length -gt 0)
        {
            [string]$regK2 = ($script:appSettings['Registry2Key'].Split('\')[-1])
            [string]$regP2 = ($script:appSettings['Registry2Key'].SubString(0, $script:appSettings['Registry2Key'].Length - ($regK2.Length + 1)))

            $regKey2 = $reg.OpenSubKey($regP2)
            If ($regKey2) { [string]$keyVal2 = $regKey2.GetValue($regK2) }
            Try { $regKey2.Close() } Catch { }

            # Check to see if it's a date we can convert
            If ($regK2.ToLower().Contains('date')) { If ($keyVal2 -eq ([System.Convert]::ToInt64($keyVal2)))
            { $keyVal2 = ((Get-Date -Date '01/01/1970').AddSeconds(([System.Convert]::ToInt64($keyVal2)))) } }
        }

        # Registry Key 3
        If ($script:appSettings['Registry3Key'].Length -gt 0)
        {
            [string]$regK3 = ($script:appSettings['Registry3Key'].Split('\')[-1])
            [string]$regP3 = ($script:appSettings['Registry3Key'].SubString(0, $script:appSettings['Registry3Key'].Length - ($regK3.Length + 1)))

            $regKey3 = $reg.OpenSubKey($regP3)
            If ($regKey3) { [string]$keyVal3 = $regKey3.GetValue($regK3) }
            Try { $regKey3.Close() } Catch { }

            # Check to see if it's a date we can convert
            If ($regK3.ToLower().Contains('date')) { If ($keyVal3 -eq ([System.Convert]::ToInt64($keyVal3)))
            { $keyVal3 = ((Get-Date -Date '01/01/1970').AddSeconds(([System.Convert]::ToInt64($keyVal3)))) } }
        }

        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    # Check the values
    $result.result  = $script:lang['Pass']
    $result.message = 'All gold build checks were found and correct'
    $result.data    = ''

    If ($script:appSettings['Registry1Key'] -ne '')
    {
        $result.data += ('1: ({0}) {1}: {2},#' -f 'XXXX', $regK1, $keyval1)
        If ($script:appSettings['Registry1Value'] -ne 'Report Only') {
            If ($keyVal1 -ge $script:appSettings['Registry1Value']) { $result.data = $result.data.Replace('XXXX', 'Pass') } Else { $result.data = $result.data.Replace('XXXX', 'Fail') }
        } Else { $result.data = $result.data.Replace('XXXX', 'Report') }
    }

    If ($script:appSettings['Registry2Key'] -ne '')
    {
        $result.data += ('2: ({0}) {1}: {2},#' -f 'XXXX', $regK2, $keyval2)
        If ($script:appSettings['Registry2Value'] -ne 'Report Only') {
            If ($keyVal2 -ge $script:appSettings['Registry2Value']) { $result.data = $result.data.Replace('XXXX', 'Pass') } Else { $result.data = $result.data.Replace('XXXX', 'Fail') }
        } Else { $result.data = $result.data.Replace('XXXX', 'Report') }
    }

    If ($script:appSettings['Registry3Key'] -ne '')
    {
        $result.data += ('3: ({0}) {1}: {2},#' -f 'XXXX', $regK3, $keyval3)
        If ($script:appSettings['Registry3Value'] -ne 'Report Only') {
            If ($keyVal3 -ge $script:appSettings['Registry3Value']) { $result.data = $result.data.Replace('XXXX', 'Pass') } Else { $result.data = $result.data.Replace('XXXX', 'Fail') }
        } Else { $result.data = $result.data.Replace('XXXX', 'Report') }
    }

    If ($result.data.Contains(': (Fail)'))   { $result.result = $script:lang['Fail']  ; $result.message = 'One or more gold build checks were below the specified value' }
    If ($result.data.Contains(': (Report)')) { $result.result = $script:lang['Manual']; $result.message = 'One or more gold build checks were "Report Only"'             }

    Return $result
}
c-sys-21-gold-image -serverName $serverName -resultPath $resultPath
}
$csys22 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['AllMustExist'] = 'True'
$script:appSettings['SerivcesToCheck'] = ('')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Installed Services'
<#
    DESCRIPTION: 
        Check that a specific list of services exist on the target server.  The friendly display name should be used.

    REQUIRED-INPUTS:
        SerivcesToCheck - List of services to check.  Enter the display name of the service.
        AllMustExist    - "True|False" - Should all services exist for a Pass.?

    DEFAULT-VALUES:
        SerivcesToCheck = ('')
        AllMustExist    = 'True'

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All services were found
            One or more services were found
        WARNING:
        FAIL:
            One or more services were not found
        MANUAL:
        NA:

    APPLIES:
        All Servers

    REQUIRED-FUNCTIONS:
        None
#>

Function c-sys-22-installed-services
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-sys-22-installed-services'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DisplayName FROM Win32_Service WHERE DisplayName="dummyValue"'
        $script:appSettings['SerivcesToCheck'] | ForEach { $query += ' OR DisplayName="{0}"' -f $_ }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, DisplayName
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        ForEach ($service In $check)
        {
            


        }
    }

    If ($result.message -eq '')
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All auto-start services are running'
        $result.data    = ''
    }
    
    Return $result
}
c-sys-22-installed-services -serverName $serverName -resultPath $resultPath
}
$cvmw01 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'HyperV/VMware Tools Version'
<#
    DESCRIPTION: 
        Check that the latest VMware tools or Microsoft integration services are installed.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            VMware tools are up to date
        WARNING:
        FAIL:
            Integration services not installed
            VMware tools can be upgraded
        MANUAL:
            Integration services found
            Unable to check the VMware Tools upgrade status
        NA:
            Not a virtual machine

    APPLIES:
        Virtual Servers

    REQUIRED-FUNCTIONS:
        Check-HyperV
        Check-VMware
#>

Function c-vmw-01-tools-version
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-vmw-01-tools-version'

    #... CHECK STARTS HERE ...#

    If ((Check-HyperV $serverName) -eq $true)
    {
        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Virtual Machine\Auto')
            If ($regKey) { [string]$keyVal = $regKey.GetValue('IntegrationServicesVersion') }
            Try { $regKey.Close() } Catch { }
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ([string]::IsNullOrEmpty($keyVal) -eq $false)
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Integration services found'
            $result.data    = ('Version: {0}' -f $keyVal)
        }
        Else
        {
            $result.result  = $script:lang['fail']
            $result.message = 'Integration services not installed'
        }
    }
    
    ElseIf ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$versi = ''
            [string]$check = ''
            If ($serverName -eq $env:ComputerName)
            {
                $versi = Invoke-Command                           -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" -v   } -ErrorAction SilentlyContinue
                $check = Invoke-Command                           -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" help } -ErrorAction SilentlyContinue
            }
            Else
            {
                $versi = Invoke-Command -ComputerName $serverName -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" -v   } -ErrorAction SilentlyContinue
                $check = Invoke-Command -ComputerName $serverName -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" help } -ErrorAction SilentlyContinue
            }

            If ($check -like '*upgrade*')
            {
                If ($serverName -eq $env:ComputerName) { $check = Invoke-Command                           -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" upgrade status } -ErrorAction SilentlyContinue }
                Else                                   { $check = Invoke-Command -ComputerName $serverName -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" upgrade status } -ErrorAction SilentlyContinue }
            }
        }
        Catch { }

        If ($check -like 'VMware Tools are up-to-date*')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'VMware tools are up to date'
            $result.data    = 'Current Version: {0}' -f $versi
        }
        ElseIf ($check -like 'A new version of VMware Tools is available*')
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'VMware tools can be upgraded'
            $result.data    = 'Current Version: {0}' -f $versi
        }
        ElseIf ($check.StartsWith('Usage:') -eq $true)    # 'UPGRADE' option not available
        {                                                 # Older versions and some OSes.
            $result.result  = $script:lang['Manual']
            $result.message = 'Unable to check the VMware Tools upgrade status'
            $result.data    = 'Current version: {0}.  Open vSphere client, locate "{1}", check to see if the VMware tools can be upgraded, and do so if needed' -f $versi, $serverName
        }
        Else
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Unable to check the VMware Tools version or upgrade status'
            $result.data    = 'Open vSphere client, locate "{0}", check to see if the VMware tools can be upgraded, and do so if needed' -f $serverName
        }
    }

    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-HyperV
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
c-vmw-01-tools-version -serverName $serverName -resultPath $resultPath
}
$cvmw02 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'VMware Time Sync'
<#
    DESCRIPTION: 
        Check that VMware Host Time Sync is disabled.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            VMware tools time sync is disabled
        WARNING:
        FAIL:
            VMware tools time sync is enabled
        MANUAL:
            Unable to check the VMware time sync status
        NA:
            Not a virtual machine

    APPLIES:
        Virtual Servers

    REQUIRED-FUNCTIONS:
        Check-VMware
#>

Function c-vmw-02-time-sync
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-vmw-02-time-sync'

    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$check = ''

            If ($serverName -eq $env:ComputerName)
            {
                $check = Invoke-Command                           -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" timesync status } -ErrorAction SilentlyContinue
            }
            Else
            {
                $check = Invoke-Command -ComputerName $serverName -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" timesync status } -ErrorAction SilentlyContinue
            }
        }
        Catch { }

        If ($check -like '*Disabled*')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'VMware tools time sync is disabled'
        }
        ElseIf ($check -like '*Enabled*')
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'VMware tools time sync is enabled'
        }
        Else
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Unable to check the VMware time sync status'
            $result.data    = 'Open vSphere client, locatate "{0}", select Edit Settings, Options tab, Select VMware Tools, make sure "Synchronize guest time with host" is not enabled' -f $serverName
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
c-vmw-02-time-sync -serverName $serverName -resultPath $resultPath
}
$cvmw03 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'VMware NIC Type'
<#
    DESCRIPTION: 
        Check all virtual servers have network cards that are configured as VMXNET3.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            All active NICS configured correctly
        WARNING:
            No network adapters found
        FAIL:
            One or more active NICs were found not to be VMXNET3
        MANUAL:
        NA:
            Not a virtual machine

    APPLIES:
        Virtual Servers

    REQUIRED-FUNCTIONS:
        Check-VMware
#>

Function c-vmw-03-nic-type
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-vmw-03-nic-type'
    
    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$query = 'SELECT Description FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled = "True"'
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Description
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ([string]::IsNullOrEmpty($check) -eq $true)
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'No network adapters found'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All active NICS configured correctly'
            $check | ForEach { If ($_ -notlike ('*VMXNET3*')) { $result.data += '{0},#' -f $_ } }
        
            If ([string]::IsNullOrEmpty($result.data) -eq $false)
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'One or more active NICs were found not to be VMXNET3'
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
c-vmw-03-nic-type -serverName $serverName -resultPath $resultPath
}
$cvmw04 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DiskControllerDeviceType'] = 'LSI_SAS'
$script:appSettings['IgnoreTheseControllerTypes'] = ('spaceport', 'vhdmp')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'VMware Disk Controller'
<#
    DESCRIPTION: 
        Check Windows disk controller is set correctly.  Default setting is "LSI logic SAS".

    REQUIRED-INPUTS:
        DiskControllerDeviceType   - VMware ESX default disk controller name
        IgnoreTheseControllerTypes - List of controller types to ignore

    DEFAULT-VALUES:
        DiskControllerDeviceType   = 'LSI_SAS'
        IgnoreTheseControllerTypes = ('spaceport', 'vhdmp')

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            Disk controller set correctly
        WARNING:
        FAIL:
            No SCSI controllers found
            Disk controller not set correctly
        MANUAL:
        NA:
            Not a virtual machine

    APPLIES:
        Virtual Servers

    REQUIRED-FUNCTIONS:
        Check-VMware
#>

Function c-vmw-04-lsi-sas-controller
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-vmw-04-lsi-sas-controller'

    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$query = 'SELECT DriverName, Name FROM Win32_SCSIController WHERE NOT DriverName = ""'
            $script:appSettings['IgnoreTheseControllerTypes'] | ForEach { $query += ' AND NOT DriverName LIKE "%{0}%"' -f $_ }
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty DriverName 
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check.Count -gt 0)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Disk controller set correctly'

            $check | ForEach { If ($_ -ne $script:appSettings['DiskControllerDeviceType']) { $result.data += '{0},#' -f $_ } }
            If ([string]::IsNullOrEmpty($result.data) -eq $false)
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Disk controller not set correctly'
            }
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'No SCSI controllers found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
c-vmw-04-lsi-sas-controller -serverName $serverName -resultPath $resultPath
}
$cvmw05 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'VMware SCSI Drive Count'
<#
    DESCRIPTION: 
        Checks to see if there are are more than 8 drives attached to the same SCSI adapter.
        
    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            More than 7 drives exist, but on different SCSI adapters
        WARNING:
        FAIL:
            More than 7 drives exist on one SCSI adapter
        MANUAL:
        NA:
            Not a virtual machine
            There are less than 8 drives attached to server

    APPLIES:
        Virtual Servers

    REQUIRED-FUNCTIONS:
        Check-VMware
#>

Function c-vmw-05-scsi-drive-count
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-vmw-05-scsi-drive-count'

    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$query = "SELECT SCSIPort, SCSITargetID FROM Win32_DiskDrive WHERE Caption <> 'Microsoft Virtual Disk'"
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object SCSIPort, SCSITargetID
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check.Count -gt 7)
        {
            [boolean]$found = $false
            [array]$group = $check | Group-Object -Property SCSIPort -NoElement | Sort-Object SCSIPort
            $group | ForEach { $result.data += 'Adapter: {0}: Drive count: {1},#' -f $_.Name, $_.Count; If ($_.Count -gt 7) { $found = $true } }

            If ($found -eq $true)
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'More than 7 drives exist on one SCSI adapter'
            }
            Else
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'More than 7 drives exist, but on different SCSI adapters'
            }
        }
        Else
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'There are less than 8 drives attached to server'
            $result.data    = 'Count: ' + $check.Count
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
c-vmw-05-scsi-drive-count -serverName $serverName -resultPath $resultPath
}
$cvmw06 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Total VM Size'
<#
    DESCRIPTION: 
        Checks to see if the total VM size is less than 1TB.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            VM is smaller than 1TB
        WARNING:
            VM is larger than 1TB.  Make sure there is an engineering exception in place for this
        FAIL:
        MANUAL:
        NA:
            Not a virtual machine

    APPLIES:
        Virtual Servers

    REQUIRED-FUNCTIONS:
        Check-HyperV
        Check-VMware
#>

Function c-vmw-06-total-vm-size
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-vmw-06-total-vm-size'

    #... CHECK STARTS HERE ...#

    If (((Check-VMware $serverName) -eq $true) -or ((Check-HyperV $serverName) -eq $true))
    {
        Try
        {
            [string]$query = "SELECT Size FROM Win32_LogicalDisk WHERE DriveType = '3'"
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Size
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        [int]$size = 0
        $check | ForEach { $size += ($_ / 1GB) }
        If ($size -gt '1023')
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'VM is larger than 1TB.  Make sure there is an engineering exception in place for this'
            $result.data    = $size.ToString() + ' GB'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'VM is smaller than 1TB'
            $result.data    = $size.ToString() + ' GB'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-HyperV
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
c-vmw-06-total-vm-size -serverName $serverName -resultPath $resultPath
}
$cvmw07 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Mounted Drives'
<#
    DESCRIPTION: 
        Checks for any mounted CD/DVD or floppy drives.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Enabled

    RESULTS:
        PASS:
            No CD/ROM or floppy drives are mounted
        WARNING:
        FAIL:
            One or more CD/ROM or floppy drives are mounted
        MANUAL:
        NA:
            Not a virtual machine

    APPLIES:
        Virtual Servers

    REQUIRED-FUNCTIONS:
        Check-VMware
#>

Function c-vmw-07-cd-dvd-floppy-mounted
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-vmw-07-cd-dvd-floppy-mounted'
 
    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$query = "SELECT Name, VolumeName, Size FROM Win32_LogicalDisk WHERE DriveType='2' OR DriveType='5'"    # Filter on DriveType=2/5 (Removable and CD/DVD)
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, VolumeName, Size
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        $check | ForEach { If ($_.size -ne $null) { $result.data += '{0} ({1}),#' -f $_.Name, $_.VolumeName } }

        If ([string]::IsNullOrEmpty($result.data) -eq $false)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more CD/ROM or floppy drives are mounted'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'No CD/ROM or floppy drives are mounted'
            $result.data    = ''
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
c-vmw-07-cd-dvd-floppy-mounted -serverName $serverName -resultPath $resultPath
}
$cvmw08 = {
Param ($serverName,$resultPath)
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Failover Clustering'
<#
    DESCRIPTION: 
        Check that Failover Clustering is not be installed on virtual servers.

    REQUIRED-INPUTS:
        None

    DEFAULT-VALUES:
        None

    DEFAULT-STATE:
        Disabled

    RESULTS:
        PASS:
            Failover clustering is not installed
        WARNING:
        FAIL:
            Failover clustering is installed
        MANUAL:
        NA:
            Not a virtual server

    APPLIES:
        Virtual Servers

    REQUIRED-FUNCTIONS:
        Check-HyperV
        Check-VMware
#>

Function c-vmw-08-failover-clustering
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-vmw-08-failover-clustering'
 
    #... CHECK STARTS HERE ...#

    If (((Check-HyperV $serverName) -eq $true) -or ((Check-VMware $serverName) -eq $true))
    {
        Try
        {
            [string]$queryOS = 'SELECT Caption FROM Win32_OperatingSystem'
            [string]$checkOS = Get-WmiObject -ComputerName $serverName -Query $queryOS -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption

            If ($check -like '*2008')        # 2008
            {
                [string]$query = "SELECT Name FROM Win32_ServerFeature WHERE Name='Failover Clustering'"
                [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
            }
            ElseIf ($check -like '*201*')    # 2012, 2016
            {
                [string]$check = (Get-WindowsFeature -Name 'Failover-Clustering').InstallState    # Returns: 'Available' or 'Installed'
            }
            Else
            {
                Throw 'Operating system not supported'
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If (($check -eq 'Installed') -or ($check -eq 'Failover Clustering'))
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Failover clustering is installed'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Failover clustering is not installed'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual server'
    }

    Return $result
}
Function Check-HyperV
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}
Function Check-VMware
{
    Param ([string]$ServerName)
    $wmiBIOS = Get-WmiObject -ComputerName $ServerName -Class Win32_BIOS -Namespace ROOT\Cimv2 -ErrorAction Stop | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
c-vmw-08-failover-clustering -serverName $serverName -resultPath $resultPath
}
##############################################################################################################################################################################################
$script:qahelp['acc01']='<xml><description>Check all local users to ensure that no non-standard accounts exist.  Unless the server is not in a domain, there should be no additional user accounts.Example standard accounts include "ASPNET", "__VMware"</description><requiredinputs>IgnoreTheseUsers - List of know user or groups accounts to ignore!n</requiredinputs><pass>No additional local accounts exist!n</pass><fail>One or more local accounts exist!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['acc02']='<xml><description>Checks to see if the default local "Administrator" and "Guest" accounts have been renamed.</description><requiredinputs>InvalidAdminNames - List of names that should not be used!n</requiredinputs><pass>All local accounts have been renamed!n</pass><fail>A local account was found that needs to be renamed!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['acc03']='<xml><description>Check the local administrators group to ensure no non-standard accounts exist.If there is a specific application requirement for local administration access then these need to be well documented.</description><requiredinputs>IgnoreTheseUsers - List of know user or groups accounts to ignore!n</requiredinputs><pass>No local administrators found!n</pass><warning>This is a workgroup server, is this correct.?!n</warning><fail>One or more local administrator accounts exist!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['acc04']='<xml><description>Check all local groups and ensure no additional groups exist. If there is a specific application requirement for local groups then these need to be documented with a designated team specified as the owner.If you use specific role groups, make sure they are excluded in the settings file.</description><requiredinputs>IgnoreTheseUsers - List of known user or groups accounts to ignore!n</requiredinputs><pass>No additional local accounts!n</pass><fail>One or more local groups exist!n</fail><na>Server is a domain controller!n</na><applies>All Servers!n</applies></xml>'
$script:qahelp['acc05']='<xml><description>Checks all services to ensure no user accounts are assigned.If specific application service accounts are required then they should be domain level accounts (not local) and restricted from interactice access by policy.</description><requiredinputs>IgnoreTheseUsers - List of known user or groups accounts to ignore!n</requiredinputs><pass>No services found running under a local accounts!n</pass><fail>One or more services was found to be running under local accounts!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['acc06']='<xml><description>Checks to make sure that the guest user account has been disabled.  The guest account is located via the well known SID.</description><pass>Guest account is disabled!n</pass><fail>Guest account has not been disabled!n</fail><na>Guest account does not exist!n</na><applies>All Servers!n</applies></xml>'
$script:qahelp['acc07']='<xml><description>Checks the builtin group memberships to make sure specific users or groups are members.  If there is only one entry in "GroupMembers", then "AllMustExist" will be set to "TRUE".!nThis is check 1 of 3 that can be used to check different groups.</description><requiredinputs>AllMustExist - "True|False" - Do all group members need to exist for a "Pass"!nGroupMembers - List of users or groups that should listed as a member!nGroupName    - Local group name to check!n</requiredinputs><pass>No additional users exist!nAdditional users exist!n</pass><warning>Invalid group name!n</warning><fail>Additional users exist!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['acc08']='<xml><description>Checks the builtin group memberships to make sure specific users or groups are members.  If there is only one entry in "GroupMembers", then "AllMustExist" will be set to "TRUE".!nThis is check 2 of 3 that can be used to check different groups.</description><requiredinputs>AllMustExist - "True|False" - Do all group members need to exist for a "Pass"!nGroupMembers - List of users or groups that should listed as a member!nGroupName    - Local group name to check!n</requiredinputs><pass>No additional users exist!nAdditional users exist!n</pass><warning>Invalid group name!n</warning><fail>Additional users exist!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['acc09']='<xml><description>Checks the builtin group memberships to make sure specific users or groups are members.  If there is only one entry in "GroupMembers", then "AllMustExist" will be set to "TRUE".!nThis is check 3 of 3 that can be used to check different groups.</description><requiredinputs>AllMustExist - "True|False" - Do all group members need to exist for a "Pass"!nGroupMembers - List of users or groups that should listed as a member!nGroupName    - Local group name to check!n</requiredinputs><pass>No additional users exist!nAdditional users exist!n</pass><warning>Invalid group name!n</warning><fail>Additional users exist!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['com01']='<xml><description>Check that McAfee anti-virus is installed and virus definitions are up to date.</description><requiredinputs>MaximumDATAgeAllowed - Maximum number of days that DATs are allowed to be out of date|Integer!nProductName          - Full name of the McAfee product!nProductVersion       - Current version of the product that you are using|Decimal!n</requiredinputs><pass>McAfee product found, DATs are OK!n</pass><fail>McAfee product not found, install required!nDATs are not up-to-date!nNo DAT version found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['com02']='<xml><description>Check relevant monitoring tool agent is installed and that the correct port is open to the management server.</description><requiredinputs>ProductNames - List of SCOM agent product names to search for!n</requiredinputs><pass>{product} found, Port {port} open to {server}!n</pass><fail>Monitoring software not found, install required!n{product} found, agent not configured with port and/or servername!n{product} found, port {port} not open to {server}!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['com03']='<xml><description>Check relevant SCCM agent process is running, and that the correct port is open to the management server.</description><pass>SCCM agent found, port {port} open to {server}!n</pass><fail>SCCM agent found, agent not configured with port and/or servername!nSCCM agent found, port {port} not open to {server}!nSCCM agent not found, install required!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['com04']='<xml><description>Check NetBackup agent is installed and that the correct port is open to the management server.Only applies to physical servers, or virtual servers with a list of known software installed.</description><requiredinputs>ProductName         - Full name of the product to look for!nRequiredServerRoles - List of known software to check if installed!n</requiredinputs><pass>{product} found, Port 1556 open to {server}!n</pass><fail>{product} not found!nPort 1556 not open to {server}!nBackup agent software not found, but this server has {role} installed which requires it!nBackup agent software not found, but this server is a domain controller which requires it!n</fail><manual>Is this server backed up via VADP.?  Manually check vCenter annotations, and look for "NetBackup.!n</manual><applies>All Servers!n</applies></xml>'
$script:qahelp['com05']='<xml><description>Check server is compliant with patch policy (must be patched to latest released patch level for this customer).Check date of last patch and return WARNING if not within specified number of days, and FAIL if not within number of days *2.</description><requiredinputs>MaximumLastPatchAgeAllowed - Mamimum number of days that patching is allowed to be out of date|Integer!n</requiredinputs><pass>Windows patches applied!n</pass><warning>Server not patched within the last {num} days!nOperating system not supported by check!n</warning><fail>Server not patched within the last {num} days!nNo last patch date - server has never been updated!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['com06']='<xml><description>Check that a WSUS server has been specified and that the correct port is open to the management server.</description><pass>WSUS server configured, port {port} open to {server}!n</pass><fail>WSUS server configured, port {port} not open to {server}!nWSUS server has not been configured!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['com07']='<xml><description>Check sentinel monitoring agent is installed, and that the correct port is open to the management server.</description><pass>Sentinel agent found, port {port} open to {server}!n</pass><fail>Sentinel agent found, port {port} not open to {server}!nSentinel agent not found, install required!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['com08']='<xml><description>Check BladeLogic monitoring agent is installed, and that the correct port is listening.Also check that the USERS.LOCAL file is configured correctly.</description><requiredinputs>ListeningPort - Port number that the agent listens on|Integer!nCustomerCode  - Customer name found in USERS.!n</requiredinputs><pass>BladeLogic agent found, and file confgiured!n</pass><fail>BladeLogic agent not found, install required!nRequired port not listening!nUSERS.LOCAL not configured!nUSERS.LOCAL not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['com09']='<xml><description>Check that Trend anti-virus is installed and virus definitions are up to date.</description><requiredinputs>MaximumDATAgeAllowed - Maximum number of days that DATs are allowed to be out of date|Integer!nProductName          - Full name of the Trend product!nProductVersion       - Current version of the product that you are using|Decimal!nDATPathLocation      - Full path location of the DAT location|File!n</requiredinputs><pass>Trend product found, DATs are OK!n</pass><fail>Trend product not found, install required!nDATs are not up-to-date!nNo DAT version found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['drv01']='<xml><description>Check the system drive is a minimum size of 50gb for Windows 2008+ servers (some are reporting 49gb).</description><requiredinputs>MinimumSystemDriveSize - Minimum size of the system drive|Integer!n</requiredinputs><pass>System drive ({letter}) meets minimum required size!n</pass><fail>System drive ({letter}) is too small, should be {size}gb!n</fail><manual>Unable to get drive size, please check manually!n</manual><applies>All Servers!n</applies></xml>'
$script:qahelp['drv02']='<xml><description>Ensure all drives have a minimum amount of free space.  Measured as a percentage.</description><requiredinputs>IgnoreTheseDrives       - List of drive letters to ignore!nMinimumDrivePercentFree - Minimum free space available on each drive as a percentage|Integer!n</requiredinputs><pass>All drives have the required minimum free space of {size}%!n</pass><fail>One or more drives were found with less than {size}% free space!n</fail><manual>Unable to get drive information, please check manually!n</manual><applies>All Servers!n</applies></xml>'
$script:qahelp['drv03']='<xml><description>Check the page file is located on the system drive and is a fixed size.  The default setting is 4096MB (4GB).If the page file is larger a document detailing the tuning process used must exist and should follow Microsoft best tuning practices (http://support.microsoft.com/kb/2021748).</description><requiredinputs>FixedPageFileSize - Fixed size in MB of the page file|Integer!nPageFileLocation  - Drive location of the page file!n</requiredinputs><pass>Pagefile is set correctly!n</pass><fail>Pagefile is system managed!nPagefile is not set correctly!n</fail><manual>Unable to get page file information, please check manually!n</manual><applies>All Servers!n</applies></xml>'
$script:qahelp['drv04']='<xml><description>If a CD/DVD drive is present on the server confirm it is configured as "</description><requiredinputs>DVDDriveLetter - Drive letter of the CD/DVD drive!n</requiredinputs><pass>CD/DVD drive set correctly!n</pass><fail>CD/DVD drive found, but not configured as {letter}!n</fail><na>No CD/DVD drives found!n</na><applies>All Servers!n</applies></xml>'
$script:qahelp['drv05']='<xml><description>Check shared folders to ensure no additional shares are present.  Shared folders should be documented with a designated team specified as the owner.</description><requiredinputs>IgnoreTheseShares - List of share names that can be ignored!n</requiredinputs><pass>No additional shares found!n</pass><warning>Shared folders found, check against documentation!n</warning><applies>All Servers!n</applies></xml>'
$script:qahelp['drv06']='<xml><description>Where SAN storage is used, ensure multipathing software is installed and Dual Paths are present and functioning.This only checks that known software is installed.  A manual check must be done to ensure it is configured correctly.</description><requiredinputs>ProductNames - List of software to check if installed!n</requiredinputs><fail>SAN storage software not found, install required!n</fail><manual>{product} found!n</manual><na>Not a physical machine!n</na><applies>Physical Servers!n</applies></xml>'
$script:qahelp['drv07']='<xml><description>Check local disk array management agent is installed on the server.This only checks that known software is installed.  A manual check must be done to ensure it is configured correctly.</description><requiredinputs>ProductNames - List of sofware to check if installed!n</requiredinputs><fail>Disk management software not found, install required!n</fail><manual>{product} found!n</manual><na>Not a physical machine!n</na><applies>Physical Servers!n</applies></xml>'
$script:qahelp['drv08']='<xml><description>Ensure all drives are formatted as NTFS.</description><pass>All drives are formatted as NTFS!n</pass><fail>One or more drives were found not formatted as NTFS!n</fail><manual>Unable to get drive information, please check manually!n</manual><applies>All Servers!n</applies></xml>'
$script:qahelp['drv09']='<xml><description>Ensure all drives types are set to BASIC and with a partition style of MBR.</description><requiredinputs>IgnoreOffline - "True|False" - Ignore any drives that are marked as offline!n</requiredinputs><pass>All drive types are BASIC, with partition styles of MBR!n</pass><fail>One or more partition styles are not MBR!nOne or more drives types are not BASIC!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['hvh01']='<xml><description>Check Hyper-V is installed on Windows Server Core.</description><pass>Hyper-V is using Windows Server Core!n</pass><fail>Hyper-V is not using Windows Server Core!n</fail><na>Not a Hyper-V server!n</na><applies>Hyper-V Host Servers!n</applies></xml>'
$script:qahelp['hvh02']='<xml><description>Check Hyper-V is the only one installed.  See this list for IDs: https://msdn.microsoft.com/en-us/library/cc280268(v=vs.85).aspx</description><requiredinputs>IgnoreTheseRoleIDs - List of IDs that can be ignored|Integer!n</requiredinputs><pass>No extra server roles or features exist!n</pass><fail>One or more extra server roles or features exist!n</fail><na>Not a Hyper-V server!n</na><applies>Hyper-V Host Servers!n</applies></xml>'
$script:qahelp['hvh03']='<xml><description>Check all VMs are running from a non-system drive.</description><pass>No virtual machines are using the system drive!n</pass><fail>One or more virtual machines are using the system drive!n</fail><na>Not a Hyper-V server!nNo virtual machines exist on this host!n</na><applies>Hyper-V Host Servers!n</applies></xml>'
$script:qahelp['hvh04']='<xml><description>Check the version of the Integration Services installed on all VMs</description><pass>All VMs are up to date!n</pass><fail>One or more VMs are not up to date, or do not have the integration services installed!n</fail><na>No VMs are located on this host!nNot a Hyper-V server!n</na><applies>Hyper-V Host Servers!n</applies></xml>'
$script:qahelp['hvh05']='<xml><description>Check the network adapter jumbo frame setting.  Should be set to 9000 or more.</description><requiredinputs>IgnoreTheseAdapters - List of adapters to ignore this setting for!n</requiredinputs><pass>All network adapters configured correctly!n</pass><fail>One or more network adapters are not using Jumbo Frames!nNo network adapters found or enabled!n</fail><applies>Hyper-V Host Servers!n</applies></xml>'
$script:qahelp['hvh06']='<xml><description>Check that all Windows 2012+ VMs are built as generation 2 VMs</description><pass>All VMs are the correct generation type!n</pass><fail>One or more Windows 2012+ VMs are not generation 2 VMs!n</fail><na>No VMs are located on this host!nNot a Hyper-V server!n</na><applies>Hyper-V Host Servers!n</applies></xml>'
$script:qahelp['net01']='<xml><description>Check the global IPv6 setting and of status of each NIC.</description><requiredinputs>IPv6State - "Enabled|Disabled" - State of the IPv6 protocol for each network adapter!n</requiredinputs><applies>All Servers!n</applies></xml>'
$script:qahelp['net02']='<xml><description>Check there are no unused Network interfaces on the server.  We define "not in use" by showing any ENABLED NICs that are set to DHCP.All NICs should have a statically assigned IP address.</description><pass>No DHCP enabled adapters found!n</pass><fail>DHCP enabled adapters found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['net03']='<xml><description>Check network interfaces are labelled so their purpose is easily identifiable.  FAIL if any adapter names are "Local Area Connection x" or "Ethernet x".</description><pass>All adapters renamed from default!n</pass><fail>An adapter was found with the default name!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['net04']='<xml><description>Check binding order is set correctly for "Production" as the primary network adapter then as applicable for other interfaces.If no "Production" adapter is found, then "Management" should be first.</description><requiredinputs>ManagementAdapterNames - List of names or partial names of Management network adapters!nProductionAdapterNames - List of names or partial names of Production network adapters!n</requiredinputs><pass>Binding order correctly set!n</pass><fail>No network adapters found!nProduction or management adapters not listed!nBinding order incorrect, {name} should be first!nRegistry setting not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['net05']='<xml><description>Check the network adapter speed and duplex settings.  Should be set to "Full Duplex" and "Auto".</description><pass>All network adapters configured correctly!n</pass><warning>One or more network adapters configured incorrectly!n</warning><fail>No network adapters found or enabled!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['net06']='<xml><description>Check local network management agent is installed on the server.  This only checks that known software is installed.</description><requiredinputs>ProductNames - List of software to check if installed!n</requiredinputs><pass>{product} found!n</pass><fail>Network management software not found, install required!n</fail><na>Not a physical machine!n</na><applies>Physical Servers!n</applies></xml>'
$script:qahelp['net07']='<xml><description>Check network interfaces for known teaming names, manually check they are configured correctly.  Fail if no teams found or if server is a virtual.  Checked configuration is:Teaming Mode: "Static Independent";  Load Balancing Mode: "Address Hash";  Standby Adapter: (set).</description><requiredinputs>NetworkTeamNames - List of network teaming adapters!n</requiredinputs><pass>Network team count: {number}!n</pass><fail>No teamed network adapter(s) found!nThere are no network teams configured on this server!nNative teaming enabled on virtual machine!nTeam configuration is not set correctly!n</fail><manual>Teamed network adpater(s) found, check they are configured correctly!n</manual><na>Not a physical server!nOperating system not supported!n</na><applies>Physical Servers!n</applies></xml>'
$script:qahelp['net08']='<xml><description>Check that a management network adapter exists.  This must always be present on a server and labelled correctly.</description><requiredinputs>ManagementAdapterNames - List of names or partial names of Management network adapters!n</requiredinputs><pass>Management network adapter found!n</pass><fail>No management network adapter!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['net09']='<xml><description>Checks to make sure the specified static routes have been added.  Add routes to check as: StaticRoute01 = ("source", "mask", "gateway").To check for no extra persistent routes, use: StaticRoute01 = ("None", "", "").  Up to 99 routes can be checked.You must edit the settings file manually for more than the currently configured.</description><requiredinputs>StaticRoute01 - List of IPs for a single static route to check.  Order is: Source, Mask, Gateway|IPv4!nStaticRoute02 - List of IPs for a single static route to check.  Order is: Source, Mask, Gateway|IPv4!nStaticRoute03 - List of IPs for a single static route to check.  Order is: Source, Mask, Gateway|IPv4!nStaticRoute04 - List of IPs for a single static route to check.  Order is: Source, Mask, Gateway|IPv4!nStaticRoute05 - List of IPs for a single static route to check.  Order is: Source, Mask, Gateway|IPv4!n</requiredinputs><pass>All static routes are present!n</pass><fail>One or more static routes are missing or incorrect!n</fail><na>No static routes to check!n</na><applies>All Servers!n</applies></xml>'
$script:qahelp['net10']='<xml><description>Check network interfaces have their power management switch disabled.</description><pass>All adapters have power saving disabled!n</pass><fail>One or more adapters have power saving enabled!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['net11']='<xml><description>Checks that all DNS servers are configured, and if required, in the right order.</description><requiredinputs>DNSServers    - List of DNS IP addresses that you want to check|IPv4!nOrderSpecific - "True|False" - Should the DNS order match exactly for a Pass.?  If the number of entries does not match the input list, this is set to "FALSE"!nAllMustExist  - "True|False" - Should all DNS entries exist for a Pass.?!n</requiredinputs><pass>All DNS servers configured (and in the right order)!n</pass><fail>DNS Server count mismatch!nMismatched DNS servers!nDNS Server list is not in the required order!nNo DNS servers are configured!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['net12']='<xml><description>Check that File And Print Services has been disabled on all adapters, except for those specified.</description><requiredinputs>IgnoreTheseAdapters - List of names or partial names of network adapters to ignore!n</requiredinputs><pass>File And Print Services are disabled correctly!n</pass><fail>File And Print Services are enabled!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['reg01']='<xml><description>Check that the server time is correct.  If a valid source is used, the time is also checked against that source.Maximum time difference allowed is 10 seconds, any longer and the check fails.</description><pass>Time source is set to a remote server, and is syncronsized correctly!n</pass><fail>Time source is set to a remote server, and is not syncronsized correctly!nTime source is not set!nTime source is not set correctly!nError getting required information!n</fail><manual>Not a supported operating system for this check!n</manual><applies>All Servers!n</applies></xml>'
$script:qahelp['reg02']='<xml><description>Check that the server timezone is correct.  Default setting is "(GMT) Greenwich Mean Time</description><requiredinputs>TimeZoneNames - List of time zone strings to check against.  Different OS versions use different strings.!n</requiredinputs><pass>Server timezone set correctly!n</pass><fail>Server timezone is incorrect and should be set to {string}!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['reg03']='<xml><description>Ensure the Region and Language > Location is set correctly.  Default setting is "United Kingdom".</description><requiredinputs>DefaultLocation - Regional string name!n</requiredinputs><pass>Regional location set correctly!n</pass><fail>Regional location incorrectly set to {string}!nRegistry setting not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['reg04']='<xml><description>Ensure the Region and Language > keyboard and Languages is set correctly.  Default setting is "English (United Kingdom)".</description><requiredinputs>DefaultLanguage - Numerical value of the correct keyboard to use!n</requiredinputs><pass>Keyboard layout is set correctly!n</pass><fail>Keyboard layout is not set correctly!nRegistry setting not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec01']='<xml><description>Ensure security ciphers are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings.</description><requiredinputs>EnabledCiphers  - List of Ciphers that should be enabled!nDisabledCiphers - List of Ciphers that should be disabled!n</requiredinputs><pass>All ciphers set correctly!n</pass><fail>One or more ciphers set incorrectly!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec02']='<xml><description>Ensure hashes are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings.</description><requiredinputs>EnabledHashes  - List of hashes that should be enabled!nDisabledHashes - List of hashes that should be disabled!n</requiredinputs><pass>All hashes set correctly!n</pass><fail>One or more hashes set incorrectly!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec03']='<xml><description>Ensure key exchange algorithms are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings.</description><requiredinputs>KeyExchangeAlgorithms - List of Key Exchange Algorithms that should be used!n</requiredinputs><pass>All key exchange algorithms set correctly!n</pass><fail>One or more key exchange algorithms set incorrectly!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec04']='<xml><description>Ensure protocols are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings.</description><requiredinputs>DisabledProtocols - List of protocols that should be disabled!n</requiredinputs><pass>All protocols set correctly!n</pass><fail>One or more protocols set incorrectly!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec05']='<xml><description>Ensure the security cipher order is set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings.</description><requiredinputs>CipherSuiteOrder - "LARGE" - Single comma seperated string list of cipher suites in the order that they should be used in!n</requiredinputs><pass>Cipher suite order set correctly!n</pass><fail>Cipher suite order not set correctly!nCipher suite order set to the default value!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec06']='<xml><description>Ensure the system is set to reject attempts to enumerate accounts in the SAM by anonymous users.</description><pass>Reject annonymous account enumeration is enabled!n</pass><fail>Reject annonymous account enumeration is disabled!nRegistry setting not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec07']='<xml><description>Ensure the system is set to reject attempts to enumerate shares in the SAM by anonymous users.</description><pass>Reject annonymous share enumeration is enabled!n</pass><fail>Reject annonymous share enumeration is disabled!nRegistry setting not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec08']='<xml><description>Check system is not caching domain credentials.</description><pass>Domain credential caching is disabled!n</pass><fail>Domain credential caching is enabled!nRegistry setting not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec09']='<xml><description>Ensure the system is set to request administrative credentials before granting an application elevated privileges.Default setting is either "(1):Prompt for credentials on the secure desktop" or "(3):Prompt for credentials"Values and meanings can be seen here - https://msdn.microsoft.com/en-us/library/cc232761.aspx</description><requiredinputs>ElevatePromptForAdminCredentials - "0,1,2,3,4,5" - List of settings to check for!n</requiredinputs><pass>Prompt for credentials is enabled!n</pass><fail>System is not set to "Prompt for credentials" when launching an application with elevated privileges!nRegistry setting not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec10']='<xml><description>Ensure the system is set to restrict anonymous access to named pipes</description><pass>Restrict annonymous pipe/share access is enabled!n</pass><fail>Restrict annonymous pipe/share access is disabled!nRegistry setting not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec11']='<xml><description>Checks to see if the default webpage is present in IIS, it should be removed.</description><pass>IIS Installed, "iisstart.htm" not listed in default documents!n</pass><fail>IIS Installed, default document "iisstart.htm" configured!n</fail><na>IIS not Installed!n</na><applies>All Servers!n</applies></xml>'
$script:qahelp['sec12']='<xml><description>Ensure SMB signing is turned on.</description><pass>SMB Signing configured correctly!n</pass><fail>SMB Signing not configured correctly!nRegistry setting not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec13']='<xml><description>If server is Domain Controller or a Terminal Server ensure RSA authentication manager is installed and PIN is required to access server.</description><requiredinputs>ProductNames - List of product names to search for!n</requiredinputs><pass>{product} found!n</pass><fail>RSA software not found!n</fail><na>Not a domain controller or terminal services server!n</na><applies>Domain Controllers!nTerminal Servers!n</applies></xml>'
$script:qahelp['sec14']='<xml><description>Checks to see if there are any addional firewall rules, and warns if there are any.  This ignores all default pre-configured rules, and netbackup ports rules (1556, 13724).</description><requiredinputs>IgnoreTheseFirewallAppRules - List of known firewall rules to ignore!n</requiredinputs><pass>No additional firewall rules exist!n</pass><warning>One or more additional firewall rules exist, check they are required!n</warning><applies>All Servers!n</applies></xml>'
$script:qahelp['sec15']='<xml><description>Check if Windows firewall is enabled or disabled for each of the three profiles.  Set to "0" for off, and "1" for on</description><requiredinputs>DomainProfile   - "0|1" - Domain firewall state (enabled / disabled)!nPublicProfile   - "0|1" - Public firewall state (enabled / disabled)!nStandardProfile - "0|1" - Standard (Home) firewall state (enabled / disabled)!n</requiredinputs><pass>Windows firewall is set correctly!n</pass><fail>Windows firewall is not set correctly!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sec16']='<xml><description>Returns a list of ports that are open, excluding anything lower than 1024 and within the dynamic port range.  Will also exclude other well known ports.!n</description><requiredinputs>IgnoreThesePorts - List of port numbers to ignore|Integer!n</requiredinputs><pass>No extra ports are open!n</pass><fail>One or more extra ports are open!n</fail><na>This check is for local servers only!n</na><applies>All Servers!n</applies></xml>'
$script:qahelp['sec17']='<xml><description>Ensure SMBv1 is disabled.</description><pass>SMBv1 is disabled!n</pass><fail>SMBv1 is enabled!nRegistry setting not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sys01']='<xml><description>Check for a pending reboot.</description><pass>Server is not waiting for a reboot!n</pass><fail>Server is waiting for a reboot!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sys02']='<xml><description>Check windows is licensed.</description><pass>Windows is licenced, Port 1688 open to KMS Server {server}!n</pass><fail>Windows is licenced, Port 1688 not open to KMS Server {server}!nWindows licence check failed!nWindows not licenced!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sys03']='<xml><description>Check services and ensure all services set to start automatically are running (NetBackup Bare Metal Restore Boot Server,NetBackup SAN Client Fibre Transport Service and .NET4.0 are all expected to be Automatic but not running).</description><requiredinputs>IgnoreTheseServices - List of known services that can ignored when set to automatic and not started!n</requiredinputs><pass>All auto-start services are running!n</pass><fail>An auto-start service was found not running!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sys04']='<xml><description>Check services and ensure all listed services are set to disabled and are stopped.</description><requiredinputs>CheckTheseServices - List of known serivces that should be in a disabled state!n</requiredinputs><pass>All services are configured correctly!n</pass><fail>One or more services are configured incorrectly!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sys05']='<xml><description>Check System Event Log and ensure no errors are present in the last x days.  If found, will return the latest y entries</description><requiredinputs>EventLogMaxSize       - Maximum size in MB of this event log (default is 16)!nEventLogRetentionType - "Overwrite|Archive|Manual" - When the maximum log size is reached!nGetLatestEntriesAge   - Return all entries for this number of days|Integer!nGetLatestEntriesCount - Return this number of entries|Integer!n</requiredinputs><pass>No errors found in system event log!n</pass><warning>Errors were found in the system event log!n</warning><applies>All Servers!n</applies></xml>'
$script:qahelp['sys06']='<xml><description>Check Application Event Log and ensure no errors are present in the last x days.  If found, will return the latest y entries</description><requiredinputs>EventLogMaxSize       - Maximum size in MB of this event log (default is 16)!nEventLogRetentionType - "Overwrite|Archive|Manual" - When the maximum log size is reached!nGetLatestEntriesAge   - Return all entries for this number of days|Integer!nGetLatestEntriesCount - Return this number of entries|Integer!n</requiredinputs><pass>No errors found in application event log!n</pass><warning>Errors were found in the application event log!n</warning><applies>All Servers!n</applies></xml>'
$script:qahelp['sys07']='<xml><description>Checks Device Manager to ensure there are no unknown devices, conflicts or errors.</description><requiredinputs>IgnoreTheseDeviceNames - List of known devices that can be ignored!n</requiredinputs><pass>No device errors found!n</pass><fail>Device errors found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sys09']='<xml><description>Check to see if any non standard scheduled tasks exist on  the server (Any application specific scheduled tasks should be documented with a designated contact point specified).This check automatically ignores any Microsoft labelled specific tasks.</description><requiredinputs>IgnoreTheseScheduledTasks - List of scheduled tasks that can be ignored!n</requiredinputs><pass>No additional scheduled tasks found!n</pass><warning>Additional scheduled tasks found - make sure these are documented!n</warning><applies>All Servers!n</applies></xml>'
$script:qahelp['sys10']='<xml><description>Check to see if any printers exist on the server. If printers exist, ensure the spooler directory is not stored on the system drive.</description><requiredinputs>IgnoreThesePrinterNames - List of known printer names to ignore!n</requiredinputs><pass>Printers found, and spool directory is not set to default path!n</pass><fail>Spool directory is set to the default path and needs to be changed, Registry setting not found!n</fail><na>No printers found!nPrint Spooler service is not running!n</na><applies>All Servers!n</applies></xml>'
$script:qahelp['sys11']='<xml><description>Ensure autorun is disabled.</description><pass>Autorun is disabled!n</pass><fail>Autorun is enabled!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sys12']='<xml><description>Check if SNMP role is install on the server.  If so, ensure the SNMP community strings follow the secure password policy.</description><pass>SNMP Service installed, but disabled!n</pass><fail>SNMP Service installed, no communities configured!n</fail><manual>SNMP Service installed, communities listed!n</manual><na>SNMP Service not installed!n</na><applies>All Servers!n</applies></xml>'
$script:qahelp['sys13']='<xml><description>Checks that the server is a member of the domain.</description><pass>Server is a domain member!n</pass><warning>This is a workgroup server, is this correct.?!n</warning><applies>All Servers!n</applies></xml>'
$script:qahelp['sys14']='<xml><description>Check power plan is set to High Performance.</description><pass>Power plan is set correctly!n</pass><fail>Power plan is not set correctly!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sys15']='<xml><description>Check hibernation is turned off.</description><pass>Hibernation is currently disabled!n</pass><fail>Hibernation is currently enabled!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sys16']='<xml><description>Check that remote desktop is enabled and that Network Level Authentication (NLA) is set.</description><pass>Secure remote desktop and NLA enabled!n</pass><warning>Network Level Authentication is not set!n</warning><fail>Secure remote desktop disabled!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['sys17']='<xml><description>If server is a Terminal Services Server ensure it has a licence server set.</description><pass>Terminal services server is licenced!n</pass><fail>Terminal services server is not licenced!n</fail><na>Not a terminal services server!n</na><applies>All Servers!n</applies></xml>'
$script:qahelp['sys18']='<xml><description>Check that the current server OU path is not in the default location(s).  The list of OUs should contain at least the default "Computers" OU, and must be the full distinguished name of the locations.</description><requiredinputs>NoInTheseOUs - List of full-path OU names that the servers should not be located in.!n</requiredinputs><pass>Server not in default location!n</pass><fail>Server is in default location!n</fail><na>Not a domain joined server!n</na><applies>All Servers!n</applies></xml>'
$script:qahelp['sys19']='<xml><description>Check the state of the HPe System Management Homepage service and version</description><requiredinputs>MinimumVersion - Minimum installed version number allowed|Decimal!nServiceState   - "Automatic|Manual|Disabled" - Default state of the service!n</requiredinputs><pass>Service state and version are correct!n</pass><fail>Service state is not correct!nInstalled version is below the minimum set!nHPe SMH not installed!n</fail><na>Not a HPe physical server!n</na><applies>All HPe Physical Servers!n</applies></xml>'
$script:qahelp['sys20']='<xml><description>Check the state of the Dell OpenManage Administrator service and version</description><requiredinputs>MinimumVersion - Minimum installed version number allowed|Decimal!nServiceState   - "Automatic|Manual|Disabled" - Default state of the service!n</requiredinputs><pass>Service state and version are correct!n</pass><fail>Service state is not correct!nInstalled version is below the minimum set!nDell OMA not installed!n</fail><na>Not a Dell physical server!n</na><applies>All Dell Physical Servers!n</applies></xml>'
$script:qahelp['sys21']='<xml><description>Allows you to checks a specific list of registry keys and values to see if your in-house gold image was used.Up to three registry keys and values can be checked.  Note: All keys must be in HKEY_LOCAL_MACHINE only</description><requiredinputs>Registry1Key   - "LARGE" -Full path and name of a registry value to check.  "HKEY_LOCAL_MACHINE\" is automatically added.!nRegistry1Value - Minimum value or string required for the registry value.  Enter "Report Only" to just show the value.!nRegistry2Key   - "LARGE" -Full path and name of a registry value to check.  "HKEY_LOCAL_MACHINE\" is automatically added.!nRegistry2Value - Minimum value or string required for the registry value.  Enter "Report Only" to just show the value.!nRegistry3Key   - "LARGE" -Full path and name of a registry value to check.  "HKEY_LOCAL_MACHINE\" is automatically added.!nRegistry3Value - Minimum value or string required for the registry value.  Enter "Report Only" to just show the value.!n</requiredinputs><pass>All gold build checks were found and correct!n</pass><fail>One or more gold build checks were below specified value!n</fail><manual>One or more gold build checks were "Report Only"!n</manual><applies>All Servers!n</applies></xml>'
$script:qahelp['sys22']='<xml><description>Check that a specific list of services exist on the target server.  The friendly display name should be used.</description><requiredinputs>SerivcesToCheck - List of services to check.  Enter the display name of the service.!nAllMustExist    - "True|False" - Should all services exist for a Pass.?!n</requiredinputs><pass>All services were found!nOne or more services were found!n</pass><fail>One or more services were not found!n</fail><applies>All Servers!n</applies></xml>'
$script:qahelp['vmw01']='<xml><description>Check that the latest VMware tools or Microsoft integration services are installed.</description><pass>VMware tools are up to date!n</pass><fail>Integration services not installed!nVMware tools can be upgraded!n</fail><manual>Integration services found!nUnable to check the VMware Tools upgrade status!n</manual><na>Not a virtual machine!n</na><applies>Virtual Servers!n</applies></xml>'
$script:qahelp['vmw02']='<xml><description>Check that VMware Host Time Sync is disabled.</description><pass>VMware tools time sync is disabled!n</pass><fail>VMware tools time sync is enabled!n</fail><manual>Unable to check the VMware time sync status!n</manual><na>Not a virtual machine!n</na><applies>Virtual Servers!n</applies></xml>'
$script:qahelp['vmw03']='<xml><description>Check all virtual servers have network cards that are configured as VMXNET3.</description><pass>All active NICS configured correctly!n</pass><warning>No network adapters found!n</warning><fail>One or more active NICs were found not to be VMXNET3!n</fail><na>Not a virtual machine!n</na><applies>Virtual Servers!n</applies></xml>'
$script:qahelp['vmw04']='<xml><description>Check Windows disk controller is set correctly.  Default setting is "LSI logic SAS".</description><requiredinputs>DiskControllerDeviceType   - VMware ESX default disk controller name!nIgnoreTheseControllerTypes - List of controller types to ignore!n</requiredinputs><pass>Disk controller set correctly!n</pass><fail>No SCSI controllers found!nDisk controller not set correctly!n</fail><na>Not a virtual machine!n</na><applies>Virtual Servers!n</applies></xml>'
$script:qahelp['vmw05']='<xml><description>Checks to see if there are are more than 8 drives attached to the same SCSI adapter.</description><pass>More than 7 drives exist, but on different SCSI adapters!n</pass><fail>More than 7 drives exist on one SCSI adapter!n</fail><na>Not a virtual machine!nThere are less than 8 drives attached to server!n</na><applies>Virtual Servers!n</applies></xml>'
$script:qahelp['vmw06']='<xml><description>Checks to see if the total VM size is less than 1TB.</description><pass>VM is smaller than 1TB!n</pass><warning>VM is larger than 1TB.  Make sure there is an engineering exception in place for this!n</warning><na>Not a virtual machine!n</na><applies>Virtual Servers!n</applies></xml>'
$script:qahelp['vmw07']='<xml><description>Checks for any mounted CD/DVD or floppy drives.</description><pass>No CD/ROM or floppy drives are mounted!n</pass><fail>One or more CD/ROM or floppy drives are mounted!n</fail><na>Not a virtual machine!n</na><applies>Virtual Servers!n</applies></xml>'
$script:qahelp['vmw08']='<xml><description>Check that Failover Clustering is not be installed on virtual servers.</description><pass>Failover clustering is not installed!n</pass><fail>Failover clustering is installed!n</fail><na>Not a virtual server!n</na><applies>Virtual Servers!n</applies></xml>'

##############################################################################################################################################################################################
$script:lang['Accounts'] = 'Accounts'                 # User and group accounts
$script:lang['AD-Message'] = 'ACCESS DENIED'
$script:lang['Admin-Warn_1'] = 'You are not running this script as an administrator'
$script:lang['Admin-Warn_2'] = 'Restart PowerShell with the "Run as Administrator" option'
$script:lang['AD-Write-Host'] = 'ACCESS DENIED - Skipping all scripts for server'
$script:lang['Applies-To'] = 'Applies To'              # Part of the HTML hover help.
$script:lang['CF-Message'] = 'CONNECTION FAILURE while contacting the server, check that the server switched on and working'
$script:lang['CF-Write-Host'] = 'CONNECTION FAILURE - Skipping all scripts for server'
$script:lang['Checked'] = 'Checked'                 #
$script:lang['Compliance'] = 'Compliance'               # Tooling agent checks (AV, SCOM, SCCM, etc)
$script:lang['Drives'] = 'Drives'                   # Local disk drive information
$script:lang['Error'] = 'Error'                   #
$script:lang['Fail'] = 'Fail'                    #
$script:lang['Failed'] = 'Failed'                  #
$script:lang['FD-Message'] = 'Job failed to run or the remote server was disconnected'
$script:lang['FD-Write-Host'] = 'JOB FAILED/DISCONNECTED - Skipping all scripts for server'
$script:lang['Generated-By'] = 'Generated by'            # Generated By (username) on (date)
$script:lang['Header'] = 'Starting QA Procedure'
$script:lang['Help_01'] = 'Usage Information'
$script:lang['Help_02'] = 'Quick Usage:'
$script:lang['Help_03'] = 'Examples:'
$script:lang['Help_04'] = 'Local Server Only:'
$script:lang['Help_05'] = 'Use a period (.) to indicate the localhost, or use the servername:'
$script:lang['Help_06'] = 'Multiple Servers:'
$script:lang['Help_07'] = 'Using commas (,) to separate, add each server to the command line:'
$script:lang['Help_08'] = 'Using a text file, with each server on a separate line:'
$script:lang['Help_09'] = 'Please Note:'
$script:lang['Help_10'] = 'The script connects using the same credentials as the powershell window.'
$script:lang['Help_11'] = 'To connect using different credentials, Shift + Right-click the PowerShell'
$script:lang['Help_12'] = 'icon in the Start Menu and select "Run as different user".  Enter the user'
$script:lang['Help_13'] = 'details required and then re-run the script.'
$script:lang['Help_14'] = ''
$script:lang['Help_15'] = ''
$script:lang['Help_16'] = ''
$script:lang['Help_17'] = ''
$script:lang['Help_18'] = ''
$script:lang['Help_19'] = ''
$script:lang['Help_20'] = ''
$script:lang['HTML_Check'] = 'Check'                   # The check code (ACC-01)
$script:lang['HTML_Data'] = 'Data'                    # The informational data returned
$script:lang['HTML_Message'] = 'Message'                 # The message retuned to the user
$script:lang['HTML_Name'] = 'Name'                    # The short name of the check
$script:lang['HTML_Result'] = 'Result'                  # The check result (Pass, Fail, ...)
$script:lang['HyperV-Host'] = 'HyperV Host'              # Microsoft Hyper-V host systems (not guests)
$script:lang['Manual'] = 'Manual'                  #
$script:lang['ND-Message'] = 'Error while running, job returned no data'
$script:lang['ND-Name'] = 'NO DATA'
$script:lang['Network'] = 'Network'                  # Local area networking information
$script:lang['Not-Applicable'] = 'N/A'                     #
$script:lang['On'] = 'on'                      #
$script:lang['Pass'] = 'Pass'                    #
$script:lang['Passed'] = 'Passed'                  #
$script:lang['QA-Results'] = 'QA Results'              # Page header
$script:lang['Regional'] = 'Regional'                 # Localised keyboard/language settings
$script:lang['ReportsLocated'] = 'Reports Located In:'     #
$script:lang['RPC-Message'] = 'RPC FAILURE while communicating with the server, check the firewall ports are opened correctly'
$script:lang['RPC-Write-Host'] = 'RPC FAILURE - Skipping all scripts for server'
$script:lang['Scan-Head_1'] = 'There are {0} checks to perform, with a maximum of {1} running concurrently'
$script:lang['Scan-Head_2'] = 'Each has a timeout limit of {0} seconds.  Progress bar legend:'
$script:lang['Script-Version'] = 'Script Version:'         # Script Version: (version)
$script:lang['Security'] = 'Security'                 # Security and firewall checks
$script:lang['ServerCount'] = 'Scanning {0} servers'    #
$script:lang['Servers'] = 'servers'
$script:lang['Skipped'] = 'Skipped'                 #
$script:lang['System'] = 'System'                   # Local computer system checks
$script:lang['TimeTaken'] = 'Approx Time Taken :'     #
$script:lang['TO-Message'] = 'Job failed to finish within the timeout period, job cancelled'
$script:lang['TO-Name'] = 'TIMEOUT'
$script:lang['TotalCount_1'] = 'Total Server Counts'     # Total count of the number of servers scanned
$script:lang['TotalCount_2'] = 'Total Script Results'    # Total count of the script results (Passed, Failed, ...)
$script:lang['Verbose-Info'] = 'Verbose information:'
$script:lang['VMs-HyperV'] = 'VMs: HyperV'              # Computers that are Hyper-V guests (not hosts)
$script:lang['VMs-VMware'] = 'VMs: VMware'              # Computers that are VMware ESX guests (not hosts)
$script:lang['Warning'] = 'Warning'                 #
##############################################################################################################################################################################################
Function Show-HelpScreen
{
    Clear-Host
    Write-Header -Message $($script:lang['Help_01']) -Width $script:screenwidth
    Write-Host ' '$($script:lang['Help_02'])                                               -ForegroundColor Cyan
    Write-Colr '    QA.ps1 [-ComputerName] ','server01','[, server02, server03, ...]'      -Colour          Yellow, Yellow, Gray, Yellow, Gray
    Write-Colr '    QA.ps1 [-ComputerName] ','(Get-Content -Path x:\path\list.txt)'        -Colour          Yellow, Yellow, Gray, Yellow
    Write-Host ''
    Write-Host ''
    Write-Host ' '$($script:lang['Help_03'])                                               -ForegroundColor Cyan
    Write-Host '   '$($script:lang['Help_04'])                                             -ForegroundColor Cyan
    Write-Colr '      ', $($script:lang['Help_05'])                                        -Colour          Cyan, White
    Write-Colr '        QA.ps1 [-ComputerName] ','.'                                       -Colour          Yellow, Yellow, Gray, Yellow
    Write-Colr '        QA.ps1 [-ComputerName] ','server01'                                -Colour          Yellow, Yellow, Gray, Yellow
    Write-Host ''
    Write-Host '   '$($script:lang['Help_06'])                                             -ForegroundColor Cyan
    Write-Colr '      ', $($script:lang['Help_07'])                                        -Colour          Cyan, White
    Write-Colr '        QA.ps1 [-ComputerName] ','server01, server02, server03, ...'       -Colour          Yellow, Yellow, Gray, Yellow
    Write-Host ''
    Write-Colr '      ', $($script:lang['Help_08'])                                        -Colour          Cyan, White
    Write-Colr '        QA.ps1 [-ComputerName] ','(Get-Content -Path x:\path\list.txt)'    -Colour          Yellow, Yellow, Gray, Yellow
    Write-Host ''
    Write-Host ' '$script:lang['Help_09']                                                  -ForegroundColor Cyan

    [int]$iCnt = 10
    Do {
        If ([string]::IsNullOrEmpty($script:lang["Help_$iCnt"]) -eq $false) { Write-Host '   '$script:lang["Help_$iCnt"] -ForegroundColor White }
        $iCnt++
    } While ($iCnt -lt 20)

    Write-Host (DivLine -Width $script:screenwidth)                                        -ForegroundColor Yellow
    Write-Host ''
    Exit
}

###################################################################################################

Function Check-CommandLine
{
    If (Test-Path variable:help) { If ($Help -eq $true)
    {
        Show-HelpScreen
        Exit 
    } }

    # Resize window to be 132 wide and keep the height.
    # Also change the buffer size to be huge
    $gh = Get-Host
    $ws = $gh.UI.RawUI.WindowSize
    $wh = $ws.Height
    If ($ws.Width -le 120)
    {
        $ws.Height = 9999
        $ws.Width  =  120; $gh.UI.RawUI.Set_BufferSize($ws)
        $ws.Height =  $wh; $gh.UI.RawUI.Set_WindowSize($ws)
    }
    $script:screenwidth = ($ws.Width - 2)

    Clear-Host
    Write-Header -Message $script:lang['Header'] -Width $script:screenwidth

    [array]$serverFilter = @()
    If (Test-Path variable:ComputerName) { If ($ComputerName -ne $null) { $ComputerName | ForEach { If ($_.Length -gt 0) { $script:servers += $_.Trim() } } } }
    $script:servers | ForEach {
        If ($_ -eq '.') { $serverFilter += ${env:ComputerName}.ToLower() }
        Else { If ($_.Trim() -eq '-ComputerName') { $_ = '' }; If ($_.Trim().Length -gt 2) { $serverFilter += $_.Trim().ToLower() } }
    }
    $script:servers = ($serverFilter | Select-Object -Unique | Sort-Object)
    If ([string]::IsNullOrEmpty($script:servers) -eq $true) { Show-HelpScreen; Exit }

    # Check admin status
    If (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] 'Administrator'))
    {
        Write-Host ('  {0}' -f $script:lang['Admin-Warn_1']) -ForegroundColor Red
        Write-Host ('  {0}' -f $script:lang['Admin-Warn_2']) -ForegroundColor Red
        Write-Host ('')
        Break
    }
}

Function Start-QAProcess
{
    # Verbose information output
    [boolean]$verbose = ($PSCmdlet.MyInvocation.BoundParameters.ContainsKey('Verbose'))
    [boolean]$debug   = ($PSCmdlet.MyInvocation.BoundParameters.ContainsKey('DoNotPing'))
    If ($verbose -eq $true) { $script:ccTasks = 1 }

    # Write job information
    [int]$count = $script:qaChecks.Count
    Write-Host ($('  {0}' -f $script:lang['Scan-Head_1']) -f $count, $script:ccTasks) -ForegroundColor White
    Write-Host ($('  {0}' -f $script:lang['Scan-Head_2']) -f $script:checkTimeout   ) -ForegroundColor White

    # Progress bar legend
    [string]$lP = $script:lang['Passed']; [string]$lW = $script:lang['Warning']       ; [string]$lF = $script:lang['Failed']
    [string]$lM = $script:lang['Manual']; [string]$lN = $script:lang['Not-Applicable']; [string]$lE = $script:lang['Error']
    Write-Host ('')
    Write-Host ("     $M $lP") -NoNewline -ForegroundColor Green; Write-Host ("     $M $lW") -NoNewline -ForegroundColor Yellow
    Write-Host ("     $M $lF") -NoNewline -ForegroundColor Red  ; Write-Host ("     $M $lM") -NoNewline -ForegroundColor Cyan
    Write-Host ("     $M $lN") -NoNewline -ForegroundColor Gray ; Write-Host ("     $M $lE")            -ForegroundColor Magenta
    Write-Host (DivLine -Width $script:screenwidth)                                                     -ForegroundColor Yellow

    [string]$ServerCounts = ''
    [string]$DebugMessage = ''
    If ($script:servers.Count -gt 1) { $ServerCounts = '  '+($($script:lang['ServerCount']) -f $($script:servers.Count)) }
    If ($debug -eq $true)            { $DebugMessage = 'Debug Mode - Ignoring Server Connection Checks'                  }

    If (($ServerCounts -ne '') -or ($DebugMessage -ne ''))
    {
        Write-Host ('{0}{1}' -f $ServerCounts, $DebugMessage.PadLeft($script:screenwidth - $ServerCounts.Length)) -ForegroundColor White
        Write-Host (DivLine -Width $script:screenwidth)                                                           -ForegroundColor Yellow
    }

    # Create required output folders
    New-Item -ItemType Directory -Force -Path ($script:qaOutput) | Out-Null
    If ($verbose -eq $true) { $pBlock = $M } Else { $pBlock = $T }
    If ($GenerateCSV -eq $true) { If (Test-Path -Path ($script:qaOutput + 'QA_Results.csv')) { Try { Remove-Item ($script:qaOutput + 'QA_Results.csv') -Force } Catch {} } }
    If ($GenerateXML -eq $true) { If (Test-Path -Path ($script:qaOutput + 'QA_Results.xml')) { Try { Remove-Item ($script:qaOutput + 'QA_Results.xml') -Force } Catch {} } }

    # Master job loop
    [int]$CurrentServerNumber = 0
    ForEach ($server In $script:servers)
    {
        $CurrentServerNumber++
        [array]$serverresults = @()
        [int]   $Padding      = ($script:servers.Count -as [string]).Length
        [string]$CurrentCount = ('({0}/{1})' -f $CurrentServerNumber.ToString().PadLeft($Padding), ($script:servers.Count))
        Write-Host ''
        Write-Colr '  ', $server.PadRight($script:screenwidth - $CurrentCount.Length - 2), $CurrentCount -Colour White, White, Yellow
        Write-Host '   ' -NoNewline

        # Make sure the computer is reachable
        If (($debug -eq $true) -or ((Test-Connection -ComputerName $server -Quiet -Count 1) -eq $true))
        {
            # Use the Check-Port function to make sure that the RPC port is listening
            If (($debug -eq $true) -or ((Check-Port -ServerName $server -Port 135) -eq $true))
            {
                # Create runspace pool
                $RSCollection = New-Object System.Collections.ArrayList
                $RunspacePool = [RunspaceFactory]::CreateRunspacePool(1, $script:ccTasks, [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault(), $Host)
                $PowerShell   = [System.Management.Automation.PowerShell]::Create()
                $PowerShell.RunspacePool = $RunspacePool
                $RunspacePool.Open()

                ForEach ($check In $script:qaChecks)
                {
                    $PowerShell = [System.Management.Automation.PowerShell]::Create()
                    $PowerShell.RunspacePool = $RunspacePool

                    [scriptblock]$CheckName = Invoke-Expression "`$$($check.Substring(0,8).Replace('-', ''))"
                    $PowerShell.AddScript($CheckName).AddParameters(@{serverName = $server; resultPath = $script:qaOutput}) | Out-Null

                    $Handle = $PowerShell.BeginInvoke()
                    $TempRS = '' | Select PowerShell, Handle, StartTime, CheckTitle
                    $TempRS.PowerShell = $PowerShell
                    $TempRS.Handle     = $Handle
                    $TempRS.StartTime  = (Get-Date)
                    $TempRS.CheckTitle = $check
                    $RSCollection.Add($TempRS) | Out-Null

                    If ($verbose -eq $false) { Write-Host $B -ForegroundColor DarkGray -NoNewline }
                }

                If ($verbose -eq $true) { Write-Host $script:lang['Verbose-Info'] -ForegroundColor Yellow }
                Else { Write-Host ''; Write-Host '   ' -NoNewline }

                # Start monitoring the threads
                Do
                {
                    [boolean]$StillWorking = $false
                    ForEach ($Runspace in $RSCollection)
                    {
                        If ($Runspace.Handle.isCompleted)
                        {
                            $result = ($Runspace.PowerShell.EndInvoke($RunSpace.Handle))
                            $Runspace.PowerShell.Dispose()

                            If ($result -ne $null)
                            {
                                # add to results
                                $script:results += $result
                                $serverresults  += $result

                                # provide some pretty output on the console
                                If ($verbose -eq $true) { Write-Host '   '$($Result).check.ToString().PadRight($script:screenwidth - 9, '.')': ' -ForegroundColor Gray -NoNewline }
                                Switch ($($result).result)
                                {
                                    $script:lang['Pass']           { Write-Host $pBlock -ForegroundColor Green  -NoNewline; Break }
                                    $script:lang['Warning']        { Write-Host $pBlock -ForegroundColor Yellow -NoNewline; Break }
                                    $script:lang['Fail']           { Write-Host $pBlock -ForegroundColor Red    -NoNewline; Break }
                                    $script:lang['Manual']         { Write-Host $pBlock -ForegroundColor Cyan   -NoNewline; Break }
                                    $script:lang['Not-Applicable'] { Write-Host $pBlock -ForegroundColor Gray   -NoNewline; Break }
                                    $script:lang['Error']          { If ($result.data -like '*Access is denied*') {
                                                                         $result.message = $script:lang['AD-Message']    # ACCESS DENIED
                                                                         $script:failurecount++
                                                                         Write-Host ("$M " + $script:lang['AD-Write-Host']) -ForegroundColor Magenta -NoNewline }
                                                                     Else { Write-Host $F -ForegroundColor Magenta -NoNewline; Break }
                                                                   }
                                    Default                        { Write-Host $F -ForegroundColor DarkGray -NoNewline; Break }
                                }
                                If ($verbose -eq $true) { Write-Host '' }
                            }
                            Else
                            {
                                # Job returned no data
                                $result          = newResult
                                $result.server   = $server
                                $result.name     = $($Runspace.CheckTitle)
                                $result.check    = $($Runspace.CheckTitle).Substring(0, 8)
                                $result.result   = 'Error'
                                $result.message  = $script:lang['ND-Message']    # NO DATA
                                $result.data     = $script:lang['ND-Message']
                                $script:results += $result
                                $serverresults  += $result
                                Write-Host $F -ForegroundColor Magenta -NoNewline
                            }

                            $Runspace.Handle     = $null
                            $Runspace.StartTime  = $null
                            $Runspace.PowerShell = $null
                            $Runspace.CheckTitle = $null
                        }
                        ElseIf (($($Runspace.StartTime).AddSeconds($script:checkTimeout)) -lt (Get-Date))
                        {
                            $Runspace.PowerShell.Stop()
                            $Runspace.PowerShell.Dispose()

                            $result          = newResult
                            $result.server   = $server
                            $result.name     = $($Runspace.CheckTitle)
                            $result.check    = $($Runspace.CheckTitle).Substring(0, 8)
                            $result.result   = 'Error'
                            $result.message  = $script:lang['TO-Message']    # TIMEOUT
                            $result.data     = $script:lang['TO-Message']
                            $script:results += $result
                            $serverresults  += $result
                            Write-Host $F -ForegroundColor Magenta -NoNewline

                            $Runspace.Handle     = $null
                            $Runspace.StartTime  = $null
                            $Runspace.PowerShell = $null
                            $Runspace.CheckTitle = $null
                        }
                        ElseIf ($Runspace.Handle -ne $null)
                        {
                            $Runspace.StartTime = (Get-Date)    # Reset start time on checks not yet running
                            $StillWorking = $true
                        }
                    }

                    If ($StillWorking) { Start-Sleep -Milliseconds 100 }

                    # Clean out unused runspace jobs
                    $rsClone = $RSCollection.Clone()
                    $rsClone | Where { $_.Handle -eq $Null } | ForEach { $RSCollection.Remove($_) }
                }
                While ($StillWorking)

                $RSCollection.Clear()
                $RSCollection = $null
                # RunspacePool Complete
            }
            Else
            {
                # RPC not responding / erroring, unable to ping server
                $result          = newResult
                $result.server   = $server
                $result.name     = 'X'
                $result.check    = 'X'
                $result.result   = 'Error'
                $result.message  = $script:lang['RPC-Message']    # RPC FAILURE
                $script:results += $result
                $serverresults  += $result
                $script:failurecount++
                Write-Host ("$M " + $script:lang['RPC-Write-Host']) -ForegroundColor Magenta -NoNewline
            }
        }
        Else
        {
            # Unable to connect
            $result          = newResult
            $result.server   = $server
            $result.name     = 'X'
            $result.check    = 'X'
            $result.result   = 'Error'
            $result.message  = $script:lang['CF-Message']    # CONNECTION FAILURE
            $script:results += $result
            $serverresults  += $result
            $script:failurecount++
            Write-Host ("$M " + $script:lang['CF-Write-Host']) -ForegroundColor Magenta -NoNewline
        }

        Write-Host ''
        $origpos = $host.UI.RawUI.CursorPosition                                                # Set cursor position
        Write-Host '   Saving Check Results...' -ForegroundColor White -NoNewline               # and display message
        Export-Results -ResultsInput $serverresults -CurrentServerNumber $CurrentServerNumber
        $host.UI.RawUI.CursorPosition = $origpos; Write-Host ''.PadRight(30, ' ') -NoNewline    # then clear message

        # Show results counts
        $resultsplit = Get-ResultsSplit -serverName $server
        [int]$padding = ($script:qaChecks).Count - 19 - 30    # 19:??; 30:Message clearing above
        If ($padding -lt     3) { $padding = 3 }
        If ($verbose -eq $true) { $padding = ($script:screenwidth - 23) }    # 23: Length of results counters + 1
        Write-Colr ''.PadLeft($padding), $resultsplit.p.PadLeft(2), ', ', $resultsplit.w.PadLeft(2), ', ', $resultsplit.f.PadLeft(2), ', ', `
                                         $resultsplit.m.PadLeft(2), ', ', $resultsplit.n.PadLeft(2), ', ', $resultsplit.e.PadLeft(2) `
                     -Colour White, Green, White, Yellow, White, Red, White, Cyan, White, Gray, White, Magenta
    }
}

Function Get-ResultsSplit
{
    Param ( [string]$serverName )
    [string]$p = @($script:results | Where-Object  { $_.result -eq $script:lang['Pass']           -and $_.server -like $serverName }).Count.ToString()
    [string]$w = @($script:results | Where-Object  { $_.result -eq $script:lang['Warning']        -and $_.server -like $serverName }).Count.ToString()
    [string]$f = @($script:results | Where-Object  { $_.result -eq $script:lang['Fail']           -and $_.server -like $serverName }).Count.ToString()
    [string]$m = @($script:results | Where-Object  { $_.result -eq $script:lang['Manual']         -and $_.server -like $serverName }).Count.ToString()
    [string]$n = @($script:results | Where-Object  { $_.result -eq $script:lang['Not-Applicable'] -and $_.server -like $serverName }).Count.ToString()
    [string]$e = @($script:results | Where-Object  { $_.result -eq $script:lang['Error']          -and $_.server -like $serverName }).Count.ToString()

    [PSObject]$resultsplit = New-Object -TypeName PSObject -Property @{ 'p'=$p; 'w'=$w; 'f'=$f; 'm'=$m; 'n'=$n; 'e'=$e; }
    Return $resultsplit
}

Function Show-Results
{
    [string]$y = $script:failurecount
    [string]$x = (@($script:servers).Count - $y)
    $resultsplit = Get-ResultsSplit -serverName '*'
    [int]$w = $script:screenwidth - 2
    Write-Host ''
    Write-Host (DivLine -Width $script:screenwidth) -ForegroundColor Yellow

    [int]$rightPad = (($script:lang['Passed']).Length)
    If ((($script:lang['Warning']       ).Length) -gt $rightPad) { $rightPad = (($script:lang['Warning']       ).Length) }
    If ((($script:lang['Failed']        ).Length) -gt $rightPad) { $rightPad = (($script:lang['Failed']        ).Length) }
    If ((($script:lang['Manual']        ).Length) -gt $rightPad) { $rightPad = (($script:lang['Manual']        ).Length) }
    If ((($script:lang['Not-Applicable']).Length) -gt $rightPad) { $rightPad = (($script:lang['Not-Applicable']).Length) }
    If ((($script:lang['Error']         ).Length) -gt $rightPad) { $rightPad = (($script:lang['Error']         ).Length) }

    If ((($script:lang['Checked']).Length) -gt (($script:lang['Skipped']).Length)) { [int]$leftPad = (($script:lang['Checked']).Length) } Else { [int]$leftPad = (($script:lang['Skipped']).Length) }

    Write-Host ('  {0}{1}' -f ($script:lang['TotalCount_1']), (($script:lang['TotalCount_2']).PadLeft($w - (($script:lang['TotalCount_2']).Length)))) -ForegroundColor White
    Write-Host ('    {0}: {1}{2}:{3}' -f ($script:lang['Checked']).PadLeft($leftPad), $x.PadLeft(3), ($script:lang['Passed']        ).PadLeft($w - $rightPad - $leftPad - 7), ($resultsplit.p).PadLeft(4)) -ForegroundColor Green
    Write-Host ('    {0}: {1}{2}:{3}' -f ($script:lang['Skipped']).PadLeft($leftPad), $y.PadLeft(3), ($script:lang['Warning']       ).PadLeft($w - $rightPad - $leftPad - 7), ($resultsplit.w).PadLeft(4)) -ForegroundColor Yellow
    Write-Host (        '    {0}:{1}' -f                                                             ($script:lang['Failed']        ).PadLeft($w - $rightPad            - 2), ($resultsplit.f).PadLeft(4)) -ForegroundColor Red
    Write-Host (        '    {0}:{1}' -f                                                             ($script:lang['Manual']        ).PadLeft($w - $rightPad            - 2), ($resultsplit.m).PadLeft(4)) -ForegroundColor Cyan
    Write-Host (        '    {0}:{1}' -f                                                             ($script:lang['Not-Applicable']).PadLeft($w - $rightPad            - 2), ($resultsplit.n).PadLeft(4)) -ForegroundColor Gray
    Write-Host (        '    {0}:{1}' -f                                                             ($script:lang['Error']         ).PadLeft($w - $rightPad            - 2), ($resultsplit.e).PadLeft(4)) -ForegroundColor Magenta

    Write-Host (DivLine -Width $script:screenwidth) -ForegroundColor Yellow
    Remove-Variable x, y, w, resultsplit -ErrorAction SilentlyContinue
}

Function Export-Results
{
    Param ( [array]$ResultsInput, [int]$CurrentServerNumber )
    [string]$Head = @'
<style>
    @charset UTF-8;
    html body       { font-family: Verdana, Geneva, sans-serif; font-size: 12px; height: 100%; margin: 0; overflow: auto; }
    #header         { background: #0066a1; color: #ffffff; width: 100% }
    #headerTop      { padding: 10px; }

    .logo1          { float: left;  font-size: 25px; font-weight: bold; padding: 0 7px 0 0; }
    .logo2          { float: left;  font-size: 25px; }
    .logo3          { float: right; font-size: 12px; text-align: right; }

    .headerRow1     { background: #66a3c7; height: 5px; }
    .headerRow2     { background: #000000; height: 5px; }
    .serverRow      { background: #000000; color: #ffffff; font-size: 32px; padding: 10px; text-align: center; text-transform: uppercase; }
    .summary        { width: 100%; }
    .summaryName    { float: left; text-align: center; padding: 6px 0; width: 16.66%; }
    .summaryCount   { text-align: center; font-size: 45px; }

    .p { background: #b3ffbe!important; }
    .w { background: #ffdc89!important; }
    .f { background: #ff9787!important; }
    .m { background: #66a3c7!important; }
    .n { background: #c8c8c8!important; }
    .e { background: #c80000!important; color: #ffffff!important; }
    .x { background: #ffffff!important; }
    .s { background: #c8c8c8!important; }

    .note           { text-decoration: none; }
    .note div.help  { display: none; }
    .note:hover     { cursor: help; position: relative; }
    .note:hover div.help { background: #ffffdd; border: #000000 3px solid; display: block; left: 10px; margin: 10px; padding: 15px; position: fixed; text-align: left; text-decoration: none; top: 10px; width: 600px; z-index: 100; }
    .note li        { display: table-row-group; list-style: none; }
    .note li span   { display: table-cell; vertical-align: top; padding: 3px 0; }
    .note li span:first-child { text-align: right; min-width: 120px; max-width: 120px; font-weight: bold; padding-right: 7px; }
    .note li span:last-child  { padding-left: 7px; border-left: 1px solid #000000; }

    .sectionRow     { background: #0066a1; color: #ffffff; font-size: 13px; padding: 1px 15px!important; font-weight: bold; height: 25px!important; }
    table tr:hover td.sectionRow { background: #0066a1; }

    table           { background: #eaebec; border: #cccccc 1px solid; border-collapse: collapse; margin: 0; width: 100%; }
    table th        { background: #ededed; border-top: 1px solid #fafafa; border-bottom: 1px solid #e0e0e0; border-left: 1px solid #e0e0e0; height: 45px; min-width: 55px; padding: 0px 15px; text-transform: capitalize; }
    table tr        { text-align: center; padding-left: 15px; }
    table td        { background: #fafafa; border-top: 1px solid #ffffff; border-bottom: 1px solid #e0e0e0; border-left: 1px solid #e0e0e0; height: 55px; min-width: 55px; padding: 0px 10px; }
    table td:first-child   { min-width: 175px; width: 175px; text-align: left; }
    table tr:last-child td { border-bottom: 0; }
    table tr:hover td      { background: #f2f2f2; }
</style>
'@

    If ($SkipHTMLHelp -eq $true) { $Head = $Head.Replace('cursor: help;', 'cursor: default;') }

    [string]$dt1 = (Get-Date -Format 'yyyy/MM/dd HH:mm')
    [string]$dt2 = $dt1.Replace('/','.').Replace(' ','-').Replace(':','.')    # 'yyyy/MM/dd HH:mm'  -->  'yyyy.MM.dd-HH.mm'
    [string]$un  = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name.ToLower()

    [string]$server = $ResultsInput[0].server
    $resultsplit = Get-ResultsSplit -serverName $server
    [string]$body = @"
<div id="header">
    <div id="headerTop">
        <div class="logo1">$reportCompanyName</div>
        <div class="logo2">$($script:lang['QA-Results'])</div>
        <div class="logo3">$($script:lang['Script-Version']) <b>$version</b> ($settingsFile)
                      <br/>$($script:lang['Generated-By']) <b>$un</b> $($script:lang['On']) <b>$dt1</b></div>
        <div style="clear:both;"></div>
    </div>
    <div style="clear:both;"></div>
</div>
<div class="headerRow1"></div>
<div class="serverRow">$server</div>
<div class="summary">
    <div class="summaryName p"><b>$($script:lang['Passed']        )</b><br><span class="summaryCount">$($resultsplit.p)</span></div>
    <div class="summaryName w"><b>$($script:lang['Warning']       )</b><br><span class="summaryCount">$($resultsplit.w)</span></div>
    <div class="summaryName f"><b>$($script:lang['Failed']        )</b><br><span class="summaryCount">$($resultsplit.f)</span></div>
    <div class="summaryName m"><b>$($script:lang['Manual']        )</b><br><span class="summaryCount">$($resultsplit.m)</span></div>
    <div class="summaryName n"><b>$($script:lang['Not-Applicable'])</b><br><span class="summaryCount">$($resultsplit.n)</span></div>
    <div class="summaryName x"><b>$($script:lang['Error']         )</b><br><span class="summaryCount">$($resultsplit.e)</span></div>
</div>
<div style="clear:both;"></div>
<div class="headerRow2"></div>
"@

    [array] $core = @()
    [array] $cust = @()
    [string]$path = $script:qaOutput + $server + '_' + $dt2 + '.html'
    # Sort the results, adding the customer specific items at the end
    $ResultsInput | Select-Object name, check, result, message, data | ForEach-Object {
        If (($_.check) -eq 'X') { $core += $_ } Else { If ($script:sections.Keys -contains ($_.check).SubString(2,3)) { $core += $_ } Else { $cust += $_ } }
    }
    $core    = $core | Sort-Object check; $cust = $cust | Sort-Object check
    $outHTML = $core + $cust | ConvertTo-HTML -Head $Head -Title 'QA Results' -Body $Body

    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Pass'])           + '"') -InputObject $outHTML
    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Warning'])        + '"') -InputObject $outHTML
    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Fail'])           + '"') -InputObject $outHTML
    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Manual'])         + '"') -InputObject $outHTML
    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Not-Applicable']) + '"') -InputObject $outHTML
    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Error'])          + '"') -InputObject $outHTML -Row
    $outHTML = Format-HTMLOutput -InputObject $outHTML
    $outHTML | Out-File $path -Force -Encoding utf8

    # CSV Output
    If ($GenerateCSV -eq $true)
    {
        [string]$path   =  $script:qaOutput + 'QA_Results.csv'
        [array] $outCSV =  @()
        [array] $cnvCSV = ($ResultsInput | Select-Object server, name, check, datetime, result, message, data | Sort-Object check, server | ConvertTo-Csv -NoTypeInformation)
        If ($CurrentServerNumber -gt 1) { $cnvCSV  = ($cnvCSV | Select-Object -Skip 1) }    # Remove header info
        $cnvCSV | ForEach-Object { $outCSV += $_.Replace(',#',', ') }
        $outCSV | Out-File -FilePath $path -Encoding utf8 -Force -Append
    }

    # XML Output
    If ($GenerateXML -eq $true)
    {
        [string]$path = $script:qaOutput + 'QA_Results.xml'
        If ($CurrentServerNumber -eq 1) { '<?xml version="1.0" encoding="utf-8" ?><QAResultsFile></QAResultsFile>' | Out-File -FilePath $path -Encoding utf8 -Force }
        [string]$inXML  = (Get-Content -Path $path)
        [xml]   $cnvXML = ($ResultsInput | Select-Object server, name, check, datetime, result, message, data | Sort-Object check, server | ConvertTo-XML -NoTypeInformation)

        $inXML = $inXML -replace '</QAResultsFile>', "$($cnvXML.Objects.InnerXml)</QAResultsFile>"
        $inXML = $inXML.Replace(',#',', ')
        $inXML | Out-File -FilePath $path -Encoding utf8 -Force
    }
}

###################################################################################################

Function Format-HTMLOutput
{
    Param ( [Object[]]$InputObject )
    Begin { }
    Process
    {
        [string]$sectionNew = ''
        [string]$sectionOld = ''

        ForEach ($input In $InputObject)
        {
            [string]$line = $input
            If ($line.IndexOf('<tr><th') -ge 0)
            {
                [int]$count = 0
                [int]$func  = 0
                $search = $line | Select-String -Pattern '<th>(.*?)</th>' -AllMatches
                ForEach ($match in $search.Matches)
                {
                    If ($match.Groups[1].Value -eq 'check'  ) { $func  = $count }
                    $count++
                }
                If ($func -eq $search.Matches.Count) { Break }

                # Rename headers to language specific values
                $line = $line.Replace('<th>name</th>',    "<th>$($script:lang['HTML_Name']   )</th>")
                $line = $line.Replace('<th>check</th>',   "<th>$($script:lang['HTML_Check']  )</th>")
                $line = $line.Replace('<th>result</th>',  "<th>$($script:lang['HTML_Result'] )</th>")
                $line = $line.Replace('<th>message</th>', "<th>$($script:lang['HTML_Message'])</th>")
                $line = $line.Replace('<th>data</th>',    "<th>$($script:lang['HTML_Data']   )</th>")
            }

            [string]$sectionRow = ''
            If ($line -match '<tr><td')
            {
                $search = $line | Select-String -Pattern '<td(.*?)>(.*?)</td>' -AllMatches
                If ($search.Matches.Count -ne 0)
                {
                    Try
                    {
                        # Rename "check" names
                        [string]$old = $search.Matches[$func].Groups[2].Value
                        If (($old.StartsWith('c-') -eq $true) -or ($old.StartsWith('f-') -eq $true))
                        {
                            [string]$new = $old.Substring(0,8)
                            $line = $line.Replace($old, $new)
                        }

                        # Add line breaks for long lines in results - If the check supports it.
                        $line = $line.Replace(',#', ',<br/>')

                        # Add section headers
                        Try { $sectionNew = ($search.Matches[$func].Groups[2].Value).Substring(2, 3).Replace('-', '') } Catch { $sectionNew = '' }
                        If ($sectionNew -ne $sectionOld)
                        {
                            $sectionOld = $sectionNew
                            [string]$selctionName = $script:sections[$sectionNew]
                            $sectionRow = '<tr><td class="sectionRow" colspan="5">{0}</td></tr>' -f $selctionName
                        }
                        Else { $sectionRow = '' }
                    }
                    Catch { }
                }
            }
            ElseIf ($line.StartsWith('</table>') -eq $true) { $sectionRow = '<tr><td class="sectionRow" colspan="5">&nbsp;</td>' }

            Write-Output $sectionRow$line
         }
    }
    End { }
}

Function Set-CellColour
{
    Param ( [Object[]]$InputObject, [string]$Filter, [switch]$Row )
    Begin
    {
        $Property = ($Filter.Split(' ')[0])
        $Colour   = ($Filter.Split(' ')[2]).Substring(1,1).ToLower()

        If ($Filter.ToUpper().IndexOf($Property.ToUpper()) -ge 0)
        {
            $Filter = $Filter.ToUpper().Replace($Property.ToUpper(), '$value')
            Try { [scriptblock]$Filter = [scriptblock]::Create($Filter) } Catch { Exit }
        } Else { Exit }
    }
    
    Process
    {
        ForEach ($input In $InputObject)
        {
            [string]$line = $input
            If ($line.IndexOf('<tr><th') -ge 0)
            {
                [int]$index = 0
                [int]$count = 0
                [int]$func  = 0
                $search = $line | Select-String -Pattern '<th>(.*?)</th>' -AllMatches
                ForEach ($match in $search.Matches)
                {
                    If ($match.Groups[1].Value -eq 'check'  ) { $func  = $count }
                    If ($match.Groups[1].Value -eq $Property) { $index = $count }
                    $count++
                }
                If ($index -eq $search.Matches.Count) { Break }
            }

            If ($line -match '<tr><td')
            {
                $search = $line | Select-String -Pattern '<td>(.*?)</td>' -AllMatches
                If (($search -ne $null) -and ($search.Matches.Count -ne 0))
                {
                    Try { [string]$check = ($search.Matches[$func].Groups[1].Value).Substring(2, 6).Replace('-', '') } Catch { [string]$check = '' }
                    $value = $search.Matches[$index].Groups[1].Value -as [double]
                    If ($value -eq $null) { $value = $search.Matches[$index].Groups[1].Value }
                    If (Invoke-Command $Filter)
                    {
                        If ($Row -eq $true) { $line = $line.Replace('<td>', '<td class="e">') }    # There was an error with this server
                        Else
                        {
                            # Insert HTML hover help
                            [string]$note = '' + $value + '</td>'
                            If (-not $SkipHTMLHelp)
                            {
                                [string]$help = Add-HoverHelp -inputLine $line -check $check
                                If ($help -ne '') { $note = '<div class="help">{0}</div>{1}</td>' -f $help, $value }
                            }

                            # Change result status cell colour
                            $line = $line.Replace($search.Matches[$index].Value, ('<td class="{0} note">{1}' -f $Colour, $note))
                        }
                    }
                    Remove-Variable value -ErrorAction SilentlyContinue
                }
            }
            Write-Output $line
        }
    }
}

Function Add-HoverHelp
{
    Param ([string]$inputLine, [string]$check)
    [string]$help = ''
    If ($script:qahelp[$check])
    {
        Try
        {
            [xml]$xml  = $script:qahelp[$check]
                 $help = '<li><span>{0}<br/>{1}</span><span>{2}</span></li><br/>' -f $script:sections[$check.Substring(0,3)], $check.Substring(3, 2), $xml.xml.description
            If ($xml.xml.ChildNodes.ToString() -like '*pass*'   ) { $help += '<li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Pass'],           ($xml.xml.pass)    }
            If ($xml.xml.ChildNodes.ToString() -like '*warning*') { $help += '<li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Warning'],        ($xml.xml.warning) }
            If ($xml.xml.ChildNodes.ToString() -like '*fail*'   ) { $help += '<li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Fail'],           ($xml.xml.fail)    }
            If ($xml.xml.ChildNodes.ToString() -like '*manual*' ) { $help += '<li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Manual'],         ($xml.xml.manual)  }
            If ($xml.xml.ChildNodes.ToString() -like '*na*'     ) { $help += '<li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Not-Applicable'], ($xml.xml.na)      }
            $help += '<br/><li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Applies-To'], ($xml.xml.applies).Replace(', ','<br/>')
            $help = $help.Replace('!n', '<br/>')
        }
        Catch { $help = $($_.Exception.Message) }    # No help if XML is invalid
    }
    Return $help
}

###################################################################################################

Function Check-Port
{
    Param ([string]$ServerName, [string]$Port)
    Try {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($ServerName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
    } } Catch { Return $false }
}

[string]$F  = ([char]9608).ToString()
[string]$T  = ([char]9600).ToString()
[string]$B  = ([char]9604).ToString()
[string]$M  = ([char]9632).ToString()
[string]$L  = ([char]9472).ToString()

[string]$TL = ([char]9556).ToString()
[string]$TR = ([char]9559).ToString()
[string]$BL = ([char]9562).ToString()
[string]$V  = ([char]9553).ToString()
[string]$H  = ([char]9552).ToString()

Function Write-Colr
{
    Param ([String[]]$Text,[ConsoleColor[]]$Colour,[Switch]$NoNewline=$false)
    For ([int]$i = 0; $i -lt $Text.Length; $i++) { Write-Host $Text[$i] -Foreground $Colour[$i] -NoNewLine }
    If ($NoNewline -eq $false) { Write-Host '' }
}

Function Write-Header
{
    Param ([string]$Message,[int]$Width); $underline=''.PadLeft($Width-16,$L)
    $q=("$TL$H$H$H$H$H$H$H$H$H$H$H$TR    ",'','','',        "$V           $V    ",'','','',        "$V  ","$F$T$F $F$T$F","  $V    ",'',
        "$V  ","$F$B$F $F$T$F","  $V    ",'',        "$V  "," $T     ","  $V    ",'',        "$V  ",' CHECK ',"  $V","  $F$F",
        "$V  ",'       ',"  $V"," $F$F ",        "$V  ",'      ','',"$F$F$B $F$F  ",        "$BL$H$H$H$H$H$H$H$H",'',''," $T$F$F$T ")
    $s=('QA Script Engine','Written by Mike @ My Random Thoughts','support@myrandomthoughts.co.uk','','Runspaces - Proof Of Concept','',$Message,$version,$underline)
    [System.ConsoleColor[]]$c=('White','Gray','Gray','Red','Cyan','Red','Green','Yellow','Yellow');Write-Host ''
    For ($i=0;$i-lt$q.Length;$i+=4) { Write-Colr '  ',$q[$i],$q[$i+1],$q[$i+2],$q[$i+3],$s[$i/4].PadLeft($Width-19) -Colour Yellow,White,Cyan,White,Green,$c[$i/4] }
    Write-Host ''
}

Function DivLine { Param ([int]$Width); Return ' '.PadRight($Width + 1, $L) }

###################################################################################################

[string]   $reportCompanyName     = "ACME"
[string]   $script:qaOutput       = "$env:SystemDrive\QA\Results\"
[int]      $script:ccTasks        =   5
[int]      $script:checkTimeout   =  60

[int]      $script:waitTime       = 100    # Time to wait between starting new tasks (milliseconds)
[int]      $script:screenwidth    = 120    #
[int]      $script:failurecount   =   0    #
[array]    $script:results        = @()    #
[array]    $script:servers        = @()    #
[hashtable]$script:sections       = @{'acc' = $script:lang['Accounts'];       #
                                      'com' = $script:lang['Compliance'];      # 
                                      'drv' = $script:lang['Drives'];          # List of sections, matched
                                      'hvh' = $script:lang['HyperV-Host'];     # with the check short name
                                      'net' = $script:lang['Network'];         # 
                                      'reg' = $script:lang['Regional'];        # These are displayed in
                                      'sec' = $script:lang['Security'];        # the HTML report file
                                      'sys' = $script:lang['System'];          #
                                      'vmw' = $script:lang['Virtual'];        #
                                     }
$tt = [System.Diagnostics.StopWatch]::StartNew()
Check-CommandLine
Start-QAProcess
Show-Results

$tt.Stop()
Write-Host '  '$script:lang['TimeTaken'] $tt.Elapsed.Minutes 'min,' $tt.Elapsed.Seconds 'sec' -ForegroundColor White
Write-Host '  '$script:lang['ReportsLocated'] $script:qaOutput                                -ForegroundColor White
Write-Host (DivLine -Width $script:screenwidth)                                               -ForegroundColor Yellow
Write-Host ''
Write-Host ''
