#Requires -Version 2
<#
    QA MASTER SCRIPT

    DO NOT EDIT THIS FILE - ALL CHANGES WILL BE LOST
    THIS FILE IS AUTO-COMPILED FROM SEVERAL SOURCE FILES

    VERSION : v3.16.1028
    COMPILED: 2016/10/28 15:38
#> 

[CmdletBinding(DefaultParameterSetName = 'HLP')]
Param (
    [Parameter(ParameterSetName='QAC', Mandatory=$true, Position=1)][string[]]$ComputerName,
    [Parameter(ParameterSetName='QAC', Mandatory=$false           )][switch]  $SkipHTMLHelp,
    [Parameter(ParameterSetName='QAC', Mandatory=$false           )][switch]  $GenerateCSV,
    [Parameter(ParameterSetName='HLP', Mandatory=$false           )][switch]  $Help
)

Set-StrictMode -Version 2
 
[string]   $version               = "v3.16.1028"
[string]   $settingsFile          = "default-settings.ini"
[hashtable]$script:lang           = @{}
[hashtable]$script:qahelp         = @{}

Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }

[array]$script:qaChecks = ('c-acc-01-local-users','c-acc-02-local-account-names','c-acc-03-local-admins','c-acc-04-local-groups','c-acc-05-service-logon-accounts',
                           'c-acc-06-guest-account','c-com-01-mcafee-antivirus-installed','c-com-02-scom-monitoring-installed','c-com-03-sccm-installed','c-com-04-netbackup-agent-installed',
                           'c-com-05-last-patch-date','c-com-06-wsus-server','c-com-07-sentinel-agent-installed','c-drv-01-system-drive-size','c-drv-02-min-drive-freespace',
                           'c-drv-03-pagefile-size-location','c-drv-04-cd-dvd-drive','c-drv-05-shared-folders','c-drv-06-san-storage','c-drv-07-disk-management-agent',
                           'c-drv-08-drive-ntfs-format','c-hvh-01-server-core','c-hvh-02-no-other-server-roles','c-hvh-03-vm-location','c-hvh-04-integration-services',
                           'c-net-01-no-ipv6','c-net-02-unused-network-interfaces','c-net-03-network-adapter-labels','c-net-04-binding-order','c-net-05-network-speed-duplex',
                           'c-net-06-network-agent','c-net-07-network-teaming','c-net-08-management-adapter','c-net-09-static-routes','c-reg-01-local-time','c-reg-02-timezone',
                           'c-reg-03-location','c-reg-04-language','c-sec-01-schannel-p1-ciphers','c-sec-02-schannel-p2-hashes','c-sec-03-schannel-p3-keyexchangealgorithms',
                           'c-sec-04-schannel-p4-protocols','c-sec-05-schannel-p5-cipher-order','c-sec-06-reject-enumerate-accounts','c-sec-07-reject-enumerate-shares',
                           'c-sec-08-domain-credential-caching','c-sec-09-request-admin-elevated','c-sec-10-anonymous-pipe-share-access','c-sec-11-iis-default-page',
                           'c-sec-12-smb-signing-on','c-sec-13-rsa-authentication','c-sec-14-firewall-rules','c-sec-15-firewall-state','c-sys-01-pending-reboot',
                           'c-sys-02-windows-license','c-sys-03-services-not-started','c-sys-04-services-not-stopped','c-sys-05-system-event-log','c-sys-06-application-event-log',
                           'c-sys-07-devices-status','c-sys-09-scheduled-tasks','c-sys-10-print-spooler','c-sys-11-autorun-disabled','c-sys-12-snmp-configuration',
                           'c-sys-13-domain-user-logon','c-sys-14-power-plan','c-sys-15-hibernation','c-sys-16-remote-desktop','c-sys-17-terminal-services-licenced',
                           'c-vhv-01-tools-version','c-vmw-01-tools-version','c-vmw-02-time-sync','c-vmw-03-nic-type','c-vmw-04-lsi-sas-controller','c-vmw-05-scsi-drive-count',
                           'c-vmw-06-total-vm-size','c-vmw-07-cd-dvd-floppy-mounted')

##############################################################################################################################################################################################
# QA Check Script Blocks
$cacc01 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseUsers'] = ('Guest', 'ASPNET', '___VMware')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['A'] = 'One or more local accounts exist'
$script:lang['B'] = 'No additional local accounts'
$script:lang['C'] = 'This is a workgroup server, is this correct.?'
$script:lang['Name'] = 'Local Users'
<#
    DESCRIPTION: 
        Check all local users to ensure that no non-standard accounts exist.  Unless the server is not in a domain, there should be no additional user accounts.
        Example standard accounts include "ASPNET", "__VMware"


    PASS:    No additional local accounts exist
    WARNING:
    FAIL:    One or more local accounts exist
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-acc-01-local-users
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-01-local-users'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string] $query1 = "SELECT Name FROM Win32_UserAccount WHERE LocalAccount='True'"
        $script:appSettings['IgnoreTheseUsers'] | ForEach { $query1 += ' AND NOT Name LIKE "%{0}%"' -f $_ }
        [array]  $check  = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name

        [string] $query2 = "SELECT PartOfDomain FROM Win32_ComputerSystem"
        [boolean]$domain = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty PartOfDomain
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($domain -eq $true)
    {
        If ($check.Count -gt 0)
        {
            $result.result  = $script:lang['Fail']
            $result.message = $script:lang['A']
            $check | ForEach { $result.data += '{0},#' -f $_ }
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = $script:lang['B']
        }
    }
    Else
    {
        $result.result  = $script:lang['Warning']
        $result.message = $script:lang['C']
    }

    Return $result
}
}

$cacc02 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['InvalidAdminNames'] = ('Administrator', 'Admin', 'Guest', 'Guest1')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Local Account Names'
<#
    DESCRIPTION: 
        Checks to see if the local default accounts have been renamed.
        The "Administrator" and "Guest" accounts should be.


    PASS:    All local accounts have been renamed
    WARNING:
    FAIL:    A local account was found that needs to be renamed
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-acc-02-local-account-names
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-02-local-account-names'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Name FROM Win32_UserAccount WHERE LocalAccount="True"'
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $accsFound = 0
    ForEach ($acc In $check)
    {
        $script:appSettings['InvalidAdminNames'] | ForEach {
            If ($acc -like $_)
            {
                $accsFound += 1
                $result.data += '{0},#' -f $acc
            }
        }
    }

    If ($accsFound -gt 0)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'A local account was found that needs to be renamed'
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Local accounts have been renamed'
    }
    
    Return $result
}
}

$cacc03 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseUsers'] = ('Domain Admins', 'Enterprise Admins')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Local Admins'
<#
    DESCRIPTION: 
        Check the local administrators group to ensure no non-standard accounts exist.  If there is a specific application requirement
        for local administration access then these need to be well documented.


    PASS:    No local administrators found
    WARNING: This is a workgroup server, is this correct.?
    FAIL:    One or more local administrator accounts exist
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-acc-03-local-admins
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-03-local-admins'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query1    = 'SELECT * FROM Win32_Group WHERE SID="S-1-5-32-544" AND LocalAccount="True"'
        [object]$WMIObject = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2
        [array] $check     = $WMIObject.GetRelated('Win32_Account', 'Win32_GroupUser', '', '', 'PartComponent', 'GroupComponent', $false, $null) | Select-Object -ExpandProperty Name

        [System.Collections.ArrayList]$check2 = @()
        $check | ForEach { $check2 += $_ }

        [string] $query2 = "SELECT PartOfDomain FROM Win32_ComputerSystem"
        [boolean]$domain = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty PartOfDomain
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }
 
    If ($domain -eq $true)
    {
        ForEach ($ck In $check)
        {
            ForEach ($exc In $script:appSettings['IgnoreTheseUsers'])
            {
                If ($ck -eq $exc) { $check2.Remove($ck) }
            }
        }

        If ($check2.count -gt 0)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more local administrator accounts exist'
            $check2 | ForEach { $result.data += '{0},#' -f $_ }
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'No local administrators found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Warning']
        $result.message = 'This is a workgroup server, is this correct.?'
    }

    Return $result
}
}

$cacc04 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseUsers'] = ('Allowed RODC Password Replication Group', 'Cert Publishers', 'ConfigMgr Remote Control Users', 'Denied RODC Password Replication Group', 'DHCP', 'DnsAdmins', 'HelpServicesGroup', 'IIS_WPG', 'Offer Remote Assistance Helpers', 'Pre-Windows 2000 Compatible Access', 'RAS and IAS Servers', 'TelnetClients', 'WinRMRemoteWMIUsers__', 'SQLServer', 'RSABypass')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Local Groups'
<#
    DESCRIPTION: 
        Check all local groups and ensure no additional groups exist. If there is a specific application requirement for local groups then
        these need to be documented with a designated team specified as the owner.
        If you use specific role groups, make sure they are excluded in the settings file.

    PASS:    No additional local accounts
    WARNING:
    FAIL:    One or more local groups exist
    MANUAL:
    NA:      Server is a domain controller

    APPLIES: All

    REQUIRED-FUNCTIONS: Check-DomainController
#>

Function c-acc-04-local-groups
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-04-local-groups'

    #... CHECK STARTS HERE ...#

    Try
    {
        If ((Check-DomainController $serverName) -eq $false)
        {
            [string]$query = 'SELECT Name, SID FROM Win32_Group WHERE LocalAccount="True" AND NOT SID LIKE "S-1-5-32-%"'
            $script:appSettings['IgnoreTheseUsers'] | ForEach { $query += ' AND NOT Name LIKE "%{0}%"' -f $_ }
            [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
        }
        Else
        {
            [array]$check = '!!DCignore'
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        If ($check[0] -eq '!!DCignore')
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'Server is a domain controller'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more local groups exist'
            $check | ForEach { $result.data += '{0},#' -f $_ }
        }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No additional local accounts'
    }
    Return $result
}
Function Check-DomainController
{
    Param ( [string] $serverName )
    Try {
        $query = "SELECT DomainRole FROM Win32_ComputerSystem"
        $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object DomainRole
        If ($check.DomainRole -eq 4 -or $check.DomainRole -eq 5) { Return $true } }
    Catch { Return $false }
    Return $false
}
}

$cacc05 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseUsers'] = ('NT AUTHORITY\\NetworkService', 'NT AUTHORITY\\LocalService', 'LocalSystem')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Service Logon Accounts'
<#
    DESCRIPTION: 
        Checks all services to ensure no user accounts are assigned. If specific application service accounts are required then they should be domain 
        level accounts (not local) and restricted from interactice access by policy.


    PASS:    No services found running under a local accounts
    WARNING:
    FAIL:    One or more services was found to be running under local accounts
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-acc-05-service-logon-accounts
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-05-service-logon-accounts'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DisplayName, StartName FROM Win32_Service WHERE NOT DisplayName=""'
        $script:appSettings['IgnoreTheseUsers'] | ForEach { $query += ' AND NOT StartName = "{0}"' -f $_ }
        [object]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object DisplayName, StartName
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Warning']
        $result.message = 'One or more services was found to be running under local accounts'
        $check | ForEach { $result.data += '{0} ({1}),#' -f $_.DisplayName, $_.StartName }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No services found running under a local accounts'
    }
    
    Return $result
}
}

$cacc06 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Guest Account'
<#
    DESCRIPTION: 
        Checks to make sure that the guest user account has been disabled.
        The guest account is located via the well known SID.


    PASS:    Guest account is disabled
    WARNING:
    FAIL:    Guest account has not been disabled
    MANUAL:
    NA:      Guest account does not exist

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-acc-06-guest-account
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-acc-06-guest-account'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Name, Disabled FROM Win32_UserAccount WHERE LocalAccount="True" AND SID LIKE "%-501"'    # Local Guest account SID always ends in '-501'
        [object]$guest = Get-WmiObject  -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, Disabled
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($guest) -eq $true)
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Guest account does not exist'
    }
    Else
    {
        If ($guest.Disabled -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Guest account is disabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Guest account has not been disabled'
            $result.data    = $guest.Name
        }
    }

    Return $result
}
}

$ccom01 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['MaximumDATAgeAllowed'] = '7'
$script:appSettings['ProductName'] = 'McAfee VirusScan Enterprise'
$script:appSettings['ProductVersion'] = '8.8'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'McAfee AV Installed'
<#
    DESCRIPTION: 
        Check McAfee anti virus is installed and updating automatically.
        Also checks that virus definitions are up to date.


    PASS:    McAfee product found, DATs are OK
    WARNING:
    FAIL:    McAfee product not found, install required / DATs are not up-to-date / No DAT version found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS: Win32_Product
#>

Function c-com-01-mcafee-antivirus-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-01-mcafee-antivirus-installed'

    #... CHECK STARTS HERE ...#

    [string]$verCheck = Win32_Product -serverName $serverName -displayName $script:appSettings['ProductName']
    If ([string]::IsNullOrEmpty($verCheck) -eq $false)
    {
        [string]$verNeed  = $script:appSettings['ProductVersion']

        # Check AV Version
        If ($verCheck -ge $verNeed)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'McAfee product  found, '
            $result.data    = 'Version {0}, ' -f $verCheck
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'McAfee product found, but wrong version, '
            $result.data    = 'Version {0} found. Expected version: {1}, ' -f $verCheck, $script:appSettings['ProductVersion']
        }

        # Check DAT Update date
        Try
        {
            [datetime]$dtVal = '01/01/1901'
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('Software\Wow6432Node\McAfee\AVEngine')
            If ($regKey) { $dtVal = $regKey.GetValue('AVDatDate') }
            Try {$regKey.Close() } Catch {}
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($dtVal -ne '01/01/1901')
        {
            $days = ((Get-Date) - $dtVal).Days
            If ($days -le $script:appSettings['MaximumDATAgeAllowed'])
            {
                $result.result   = $script:lang['Pass']
                $result.message += 'DATs are OK'
                $result.data    += 'DATs {0} day(s) old' -f $days.ToString()
            }
            Else
            {
                $result.result   = $script:lang['Fail']
                $result.message += 'DATs are not up-to-date'
                $result.data    += 'DATs {0} day(s) old' -f $days.ToString()
            }
        }
        Else
        {
            $result.result   = $script:lang['Fail']
            $result.message += 'No DAT version found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = '{0} not found, install required' -f $script:appSettings['ProductName']
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Win32_Product
{
    Param ( [string] $serverName, [string] $displayName )
    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() }
    }
    Catch { Return $null }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } }
        }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Win32_Product -serverName $serverName -displayName $displayName
            }
            Else { $verCheck = $null } }
    }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
}

$ccom02 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductNames'] = ('Microsoft Monitoring Agent', 'System Center Operations Manager', 'Operations Manager Agent')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Monitoring Installed'
<#
    DESCRIPTION: 
        Check relevant monitoring tool agent is installed and that the correct port is open to the management server



    PASS:    {0} found, Port {1} open to {2}
    WARNING:
    FAIL:    Monitoring software not found, install required / {0} found, Agent not configured with port and/or servername / {0} found, Port {1} not open to {2}
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS: Win32_Product, Test-Port
#>

Function c-com-02-scom-monitoring-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-02-scom-monitoring-installed'

    #... CHECK STARTS HERE ...#

    Try
    {
        [boolean]$found = $false
        $script:appSettings['ProductNames'] | ForEach {
            [string]$verCheck = Win32_Product -serverName $serverName -displayName $_
            If ([string]::IsNullOrEmpty($verCheck) -eq $false)
            {
                $found            = $true
                [string]$prodName = $_
                [string]$prodVer  = $verCheck
            }
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('Software\Microsoft\Microsoft Operations Manager\3.0\Agent Management Groups')
        If ($regKey) {
            [string[]]$regSubKey = $regKey.GetSubKeyNames()
            If ($regSubKey.Count -gt 0) {
                $regKey = $null
                $regKey = $reg.OpenSubKey("Software\Microsoft\Microsoft Operations Manager\3.0\Agent Management Groups\$($regSubKey[0])\Parent Health Services\0")
                If ($regkey) {
                    [string]$valName = $regKey.GetValue('NetworkName')
                    [string]$valPort = $regKey.GetValue('Port')
                }
            }
        }
        Try {$regKey.Close() } Catch {}
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($found -eq $true)
    {
        If (([string]::IsNullOrEmpty($valName) -eq $false) -and ([string]::IsNullOrEmpty($valPort) -eq $false))
        {
            [boolean]$portTest = (Test-Port -serverName $valName -Port $valPort)
            If ($portTest -eq $true)
            {
                $result.result  = $script:lang['Pass']
                $result.message = '{0} found' -f $prodName
                $result.data    = 'Version {0},#Port {1} open to {2}' -f $prodVer, $valPort, $valName
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = '{0} found' -f $prodName
                $result.data    = 'Version {0},#Port {1} not open to {2}' -f $prodVer, $valPort, $valName
            }
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = '{0} found' -f $prodName
            $result.data    = 'Version {0},#Agent not configured with port and/or servername' -f $prodVer
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Monitoring software not found, install required'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Win32_Product
{
    Param ( [string] $serverName, [string] $displayName )
    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() }
    }
    Catch { Return $null }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } }
        }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Win32_Product -serverName $serverName -displayName $displayName
            }
            Else { $verCheck = $null } }
    }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Test-Port
{
    Param ([string] $serverName, [string] $Port)
    Try
    {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($serverName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
        }
    }
    Catch { Return $false }
}
}

$ccom03 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'SCCM Installed'
<#
    DESCRIPTION: 
        Check relevant SCCM agent is installed, and that the correct port is open to the management server



    PASS:    SCCM agent found, Port {0} open to {1}
    WARNING:
    FAIL:    SCCM agent not found, install required / SCCM agent found, Agent not configured with port and/or servername / SCCM agent found, Port {0} not open to {1}
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS: Test-Port
#>

Function c-com-03-sccm-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-03-sccm-installed'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Name FROM Win32_Process WHERE Name="CcmExec.exe"'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('Software\Microsoft\CCM')
        If ($regKey) {
            [string]$valName = $regKey.GetValue('NetworkName')
            [string]$valPort = $regKey.GetValue('Port')
        }
        Try {$regKey.Close() } Catch {}
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($check) -eq $false)
    {
        If (([string]::IsNullOrEmpty($valName) -eq $false) -and ([string]::IsNullOrEmpty($valPort) -eq $false))
        {
            [boolean]$portTest = (Test-Port -serverName $valName -Port $valPort)
            If ($portTest -eq $true)
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'SCCM agent found,#Port {0} open to {1}' -f $valPort, $valName
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'SCCM agent found,#Port {0} not open to {1}' -f $valPort, $valName
            }
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'SCCM agent found,#Agent not configured with port and/or servername'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'SCCM agent not found, install required'
    }

    Return $result
}
Function Test-Port
{
    Param ([string] $serverName, [string] $Port)
    Try
    {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($serverName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
        }
    }
    Catch { Return $false }
}
}

$ccom04 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductName'] = 'Symantec NetBackup'
$script:appSettings['RequiredServerRoles'] = ('Exchange', 'SQL')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'NetBackup Agent Installed'
<#
    DESCRIPTION: 
        Check NetBackup agent is installed



    PASS:    {0} found, Port 1556 open to {1}
    WARNING:
    FAIL:    {0} not found / Port 1556 not open to {0} / Backup agent software not found, but this server has {0} installed which requires it / Backup agent software not found, but this server is a domain controller which requires it
    MANUAL:  Is this server backed up via VADP.?  Manually check vCenter annotations, and look for "NetBackup.VADP: 1"
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS: Win32_Product, Test-Port, Check-DomainController, Check-VMware
#>

Function c-com-04-netbackup-agent-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-04-netbackup-agent-installed'
    
    #... CHECK STARTS HERE ...#

    [string]$verCheck = Win32_Product -serverName $serverName -displayName $script:appSettings['ProductName']
    If ([string]::IsNullOrEmpty($verCheck) -eq $false)
    {
        $result.result  = $script:lang['Pass']
        $result.message = '{0} found,#' -f $script:appSettings['ProductName']
        $result.data    = 'Version {0}' -f $verCheck

        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('Software\Veritas\NetBackup\CurrentVersion\Config')
            If ($regKey) { [string[]]$valNames = $regKey.GetValue('Server') }
            Try {$regKey.Close()} Catch {}
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        ForEach ($server In $valNames)
        {
            [boolean]$portTest = (Test-Port -serverName $server -Port 1556)
            If   ($portTest -eq $true) {     $result.message += ('Port 1556 open to {0},#'     -f $server) }
            Else { $result.result = $script:lang['Fail'];  $result.message += ('Port 1556 not open to {0},#' -f $server) }
        }
    }
    Else
    {
        If ((Check-VMware $serverName) -eq $true)
        {
            # If backup software not installed, and is a VM, then check for additional software to see if it should be installed
            $found = $false
            $script:appSettings['RequiredServerRoles'] | ForEach {
                [string]$verExist = Win32_Product -serverName $serverName -displayName $_
                If ([string]::IsNullOrEmpty($verCheck) -eq $false)
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = '{0} not found' -f $script:appSettings['ProductName']
                    $result.data    = 'Backup agent software not found, but this server has {0} installed which requires it' -f $_
                    $found          = $true
                }
            }

            If ((Check-DomainController $serverName) -eq $true)
            {
                $result.result  = $script:lang['Fail']
                $result.message = '{0} not found' -f $script:appSettings['ProductName']
                $result.data    = 'Backup agent software not found, but this server is a domain controller which requires it'
                $found          = $true
            }

            If ($found -eq $false)
            {
                $result.result  = $script:lang['Manual']
                $result.message = '{0} not found, VADP backup.?' -f $script:appSettings['ProductName']
                $result.data    = 'Is this server backed up via VADP.?  Manually check vCenter annotations, and look for "NetBackup.VADP: 1"'
            }
        }
        Else
        {
            # Physical server
            $result.result  = $script:lang['Fail']
            $result.message = '{0} not found' -f $script:appSettings['ProductName']
            $result.data    = ''
        }
    }
    
    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Win32_Product
{
    Param ( [string] $serverName, [string] $displayName )
    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() }
    }
    Catch { Return $null }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } }
        }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Win32_Product -serverName $serverName -displayName $displayName
            }
            Else { $verCheck = $null } }
    }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Test-Port
{
    Param ([string] $serverName, [string] $Port)
    Try
    {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($serverName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
        }
    }
    Catch { Return $false }
}
Function Check-DomainController
{
    Param ( [string] $serverName )
    Try {
        $query = "SELECT DomainRole FROM Win32_ComputerSystem"
        $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object DomainRole
        If ($check.DomainRole -eq 4 -or $check.DomainRole -eq 5) { Return $true } }
    Catch { Return $false }
    Return $false
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$ccom05 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['MaximumLastPatchAgeAllowed'] = '35'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Patching Compliant'
<#
    DESCRIPTION: 
        Check server is compliant with patch policy (must be patched to latest released patch level for this customer)
        Check date of last patch and FAIL if not within 35 days


    PASS:    Windows patches applied
    WARNING: Server not patched within the last {0} days / Operating system not supported by check
    FAIL:    Server not patched within the last {0} days / No last patch date - server has never been updated
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-com-05-last-patch-date
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-05-last-patch-date'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Caption FROM Win32_OperatingSystem'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption

        If ($check -notlike '*2003*')
        {
            $session  = [activator]::CreateInstance([type]::GetTypeFromProgID('Microsoft.Update.Session', $serverName)) 
            $searcher = $session.CreateUpdateSearcher()
            $history  = $searcher.GetTotalHistoryCount()
            If ($history -gt 0) { [datetime]$check = $searcher.QueryHistory(0, 1) | Select-Object -ExpandProperty Date } Else { [datetime]$check = 0 }
        }
        Else
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'Operating system not supported by check'
            $result.data    = ''
            Return $result
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check -ne 0)
    {
        [int]$days = ((Get-Date) - $check).Days
        If ($days -gt ($script:appSettings['MaximumLastPatchAgeAllowed'] * 2))
        {
            # 2 months (using default setting)
            $result.result  = $script:lang['Fail']
            $result.message = 'Server not patched within the last {0} days' -f ($script:appSettings['MaximumLastPatchAgeAllowed'] * 2)
            $result.data    = 'Last patched: {0} ({1} days ago)' -f $check, $days
        }
        ElseIf ($days -gt $script:appSettings['MaximumLastPatchAgeAllowed'])
        {
            # 1 month (using default setting)
            $result.result  = $script:lang['Warning']
            $result.message = 'Server not patched within the last {0} days' -f $script:appSettings['MaximumLastPatchAgeAllowed']
            $result.data    = 'Last patched: {0} ({1} days ago)' -f $check, $days
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Windows patches applied'
            $result.data    = 'Last patched: {0} ({1} days ago)' -f $check, $days
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'No last patch date - server has never been updated'
    }

    Return $result
}
}

$ccom06 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'WSUS Server Setting'
<#
    DESCRIPTION: 
        Check that a WSUS server has been specified



    PASS:    WSUS server configured, Port {0} open to {1}
    WARNING:
    FAIL:    WSUS server has not been configured / WSUS server configured, Port {0} not open to {1}
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS: Test-Port
#>

Function c-com-06-wsus-server
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-06-wsus-server'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('Software\Policies\Microsoft\Windows\WindowsUpdate')
        If ($regKey) { [string]$keyVal = $regKey.GetValue('WUServer') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'WSUS server configured'
        $result.data    = $keyVal

        $keyVal = $keyVal.Replace('http://', '').Replace('https://', '')
        If ($keyVal.Contains(':') -eq $true) { [string]$name = ($keyVal.Split(':')[0]); [string]$port = $keyVal.Split(':')[1] }
        Else {                                 [string]$name =  $keyVal;                [string]$port = 80                    }

        [boolean]$portTest = (Test-Port -serverName $name -Port $port)
        If   ($portTest -eq $true) {     $result.data += (',#Port {0} open to {1}'     -f $port, $name) }
        Else { $result.result = $script:lang['Fail'];  $result.data += (',#Port {0} not open to {1}' -f $port, $name) }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'WSUS server has not been configured'
    }

    Return $result
}
Function Test-Port
{
    Param ([string] $serverName, [string] $Port)
    Try
    {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($serverName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
        }
    }
    Catch { Return $false }
}
}

$ccom07 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
$script:lang['Name'] = 'Sentinel Agent Installed'
<#
    DESCRIPTION: 
        Check sentinel monitoring agent is installed, and that the correct port is open to the management server



    PASS:    Sentinel agent found, Port {0} open to {1}
    WARNING:
    FAIL:    Sentinel agent not found, install required / Port {0} not open to {1}
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS: Win32_Product, Test-Port
#>

Function c-com-07-sentinel-agent-installed
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = $script:lang['Name']
    $result.check  = 'c-com-07-sentinel-agent-installed'

    #... CHECK STARTS HERE ...#

    [string]$verCheck = Win32_Product -serverName $serverName -displayName 'NetIQ Sentinel Agent'
    If ([string]::IsNullOrEmpty($verCheck) -eq $false)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Sentinel agent found,#'
        $result.data    = 'Version {0}' -f $verCheck

        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('Software\Wow6432Node\NetIQ\Security Manager\Configurations\AgentManager\Operations\Agent\Consolidators')
            If ($regKey) {
                [array]$valCons = @()
                ForEach ($key In (0..9))
                {
                    $valCons += $(New-Object -TypeName PSObject -Property @{'host' = $($regKey.GetValue("Consolidator $key Host")); `
                                                                            'port' = $($regKey.GetValue("Consolidator $key Port")); } )
                }
            }
            Try {$regKey.Close() } Catch {}
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        ForEach ($key In (0..9))
        {
            If ([string]::IsNullOrEmpty($($valCons.host[$key])) -eq $false)
            {
                $portTest = Test-Port -serverName $($valCons.host[$key]) -Port $($valCons.port[$key])
                If ($portTest -eq $true) { [string]$connected = ('{0}|{1}' -f $($valCons.host[$key]), $($valCons.port[$key])) }
            }
        }

        If ([string]::IsNullOrEmpty($connected) -eq $false) { $result.message += ('Port {0} open to {1}'     -f $($connected.Split('|')[1]), $($connected.Split('|')[0]))          }
        Else                                                { $result.message += ('Port {0} not open to {1}' -f $($valCons.port[0]), $($valCons.host[0])); $result.result = $script:lang['Fail'] }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Sentinel agent not found, install required'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Win32_Product
{
    Param ( [string] $serverName, [string] $displayName )
    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() }
    }
    Catch { Return $null }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } }
        }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Win32_Product -serverName $serverName -displayName $displayName
            }
            Else { $verCheck = $null } }
    }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Test-Port
{
    Param ([string] $serverName, [string] $Port)
    Try
    {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($serverName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
        }
    }
    Catch { Return $false }
}
}

$cdrv01 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['MinimumSystemDriveSize'] = '49'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check the system drive is a minimum of 50gb for Windows 2008+ servers (some are reporting 49gb)
        


    PASS:    System drive ({0}) meets minimum required size
    WARNING:
    FAIL:    System drive ({0}) is too small, should be {1}gb
    MANUAL:  Unable to get drive size, please check manually
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-drv-01-system-drive-size
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'System Drive Size'
    $result.check  = 'c-drv-01-system-drive-size'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query1 = 'SELECT SystemDrive FROM Win32_OperatingSystem'
        [string]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty SystemDrive
        If ([string]::IsNullOrEmpty($check1) -eq $false)
        {
            [string]$query2 = 'SELECT Size FROM Win32_LogicalDisk WHERE Name = "{0}"' -f $check1
            [string]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Size
            [int]   $sizeGB = [decimal]::Round(($check2 / (1024*1024*1024)))
        }
        Else
        {
            [int]$sizeGB = -1
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($sizeGB -ne -1)
    {
        If ($sizeGB -ge $script:appSettings['MinimumSystemDriveSize'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'System drive ({0}) meets minimum required size' -f $check1
            $result.data    = 'Size: {0}gb' -f $sizeGB
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'System drive ({0}) is too small, should be {1}gb' -f $check1, $script:appSettings['MinimumSystemDriveSize']
            $result.data    = 'Size: {0}gb' -f $sizeGB
        }
    }
    Else
    {
        $result.result  = $script:lang['Manual']
        $result.message = 'Unable to get drive size, please check manually'
        $result.data    = 'System drive needs to be {0}gb or larger' -f $script:appSettings['MinimumSystemDriveSize']
    }

    Return $result
}
}

$cdrv02 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseDrives'] = ('A', 'B')
$script:appSettings['MinimumDrivePercentFree'] = '17'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure all drives have a minimum % of free space.  The default value is 17%



    PASS:    All drives have the required minimum free space of {0}%
    WARNING:
    FAIL:    One or more drives were found with less than {0}% free space
    MANUAL:  Unable to get drive information, please check manually
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-drv-02-min-drive-freespace
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Min Drive % Freespace'
    $result.check  = 'c-drv-02-min-drive-freespace'
 
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT * FROM Win32_LogicalDisk WHERE DriveType = "3"'    # Filter on DriveType = 3 (Fixed Drives)
        $script:appSettings['IgnoreTheseDrives'] | ForEach { $query += ' AND NOT Name = "{0}"' -f $_ }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, FreeSpace, Size
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $countFailed = 0
    If ($check -ne $null)
    {
        ForEach ($drive In $check)
        {
            $free = $drive.FreeSpace
            $size = $drive.Size
            If ($size -ne $null)
            {
                $percentFree  = [decimal]::Round(($free / $size) * 100)
                $result.data += $drive.Name + ' (' + $percentFree + '% free),#'
                If ($percentFree -lt $script:appSettings['MinimumDrivePercentFree']) { $countFailed += 1 }
            }
        }
    
        If ($countFailed -ne 0)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more drives were found with less than ' + $script:appSettings['MinimumDrivePercentFree'] + '% free space'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All drives have the required minimum free space of ' + $script:appSettings['MinimumDrivePercentFree'] + '%'
        }
    }
    Else
    {
        $result.result  = $script:lang['Manual']
        $result.message = 'Unable to get drive information, please check manually'
        $result.data    = 'All drives need to have ' + $script:appSettings['MinimumDrivePercentFree'] + '% or more free'
    }
    Return $result
}
}

$cdrv03 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['FixedPageFileSize'] = '4096'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check the page file is located on the system root drive and fixed size.  The default setting is 4096MB (4GB)
        If the page file is larger a document detailing the tuning process 
        used must exist and should follow Microsoft best tuning practices (http://support.microsoft.com/kb/2021748)

    PASS:    Pagefile is set correctly
    WARNING: 
    FAIL:    Pagefile is system managed, it should be set to a custom size of {0}mb / Pagefile should be set on the system drive, to Custom, with Initial and Maximum sizes set to {0}mb / Pagefile does not exist on {0} drive
    MANUAL:  Unable to get page file information, please check manually
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-drv-03-pagefile-size-location
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Pagefile Location & Size'
    $result.check  = 'c-drv-03-pagefile-size-location'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query1 = 'SELECT SystemDrive FROM Win32_OperatingSystem'
        [string]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty SystemDrive
        If ([string]::IsNullOrEmpty($check1) -eq $false)
        {
            If ((Get-WmiObject -ComputerName $serverName -Namespace ROOT\Cimv2 -List 'Win32_PageFileSetting').Name -eq 'Win32_PageFileSetting')
            {
                [string]$query2 = 'SELECT Name, InitialSize, MaximumSize FROM Win32_PageFileSetting'
                [string]$query3 = 'SELECT AutomaticManagedPagefile FROM Win32_ComputerSystem'
                [object]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2                               | Select-Object Name, InitialSize, MaximumSize
                [string]$check3 = Get-WmiObject -ComputerName $serverName -Query $query3 -Namespace ROOT\Cimv2 -ErrorAction SilentlyContinue | Select-Object -ExpandProperty AutomaticManagedPagefile
            }
        }
        Else
        {
            [object] $check2 = $null
            [boolean]$check3 = $false
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check3 -eq $true)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Pagefile is system managed, it should be set to a custom size of {0}mb' -f $script:appSettings['FixedPageFileSize']
    }
    Else
    {
        If (($check2 -eq $null) -and ($check3 -eq $false))
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Unable to get page file information, please check manually'
            $result.data    = 'Pagefile should be set to Custom,#with Initial and Maximum sizes set to ' + $script:appSettings['FixedPageFileSize'] + 'mb'
        }
        ElseIf ($check2 -ne $null)
        {
            If ($check2.MaximumSize -eq 0) 
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Pagefile is system managed, it should be set to a custom size of {0}mb' -f $script:appSettings['FixedPageFileSize']
            }
            ElseIf (($check2.MaximumSize -eq $script:appSettings['FixedPageFileSize']) -and ($check2.InitialSize -eq $script:appSettings['FixedPageFileSize'])) 
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'Pagefile is set correctly'
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Pagefile should be set on the system drive, to Custom, with Initial and Maximum sizes set to ' + $script:appSettings['FixedPageFileSize'] + 'mb'
                $result.data    = 'Location: {0},#Initial Size: {1}mb,#Maximum Size: {2}mb' -f $check2.Name, $check2.InitialSize, $check2.MaximumSize
            }
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Pagefile does not exist on {0} drive' -f $check1
            $result.data    = ''
        }
    }

    Return $result
}
}

$cdrv04 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DVDDriveLetter'] = 'R:'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        If a CD/DVD drive is present on the server confirm it is configured as "R:"



    PASS:    CD/DVD drive set correctly
    WARNING:
    FAIL:    CD/DVD drive found, but not configured as {0}
    MANUAL:
    NA:      No CD/DVD drives found

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-drv-04-cd-dvd-drive
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'CD/DVD Drive Letter'
    $result.check  = 'c-drv-04-cd-dvd-drive'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DeviceID FROM Win32_LogicalDisk WHERE DriveType="5"'    # DriveType 5 is CD/DVD Drive
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty DeviceID
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If (($check.Count -eq 0 ) -or ([string]::IsNullOrEmpty($check) -eq $true))
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'No CD/DVD drives found'
    }
    Else
    {
        [boolean]$found = $false
        $check | ForEach {
            If ($_ -eq $script:appSettings['DVDDriveLetter']) { $found = $true }
            $result.data += '{0},#' -f $_
        }

        If ($found -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'CD/DVD drive set correctly'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'CD/DVD drive found, but not configured as {0}' -f $script:appSettings['DVDDriveLetter']
        }
    }

    Return $result
}
}

$cdrv05 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseShares'] = ('', '')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check Shared Folders to ensure no additional shares are present
        (Shared folders should be documented with a designated team specified as the owner)


    PASS:    No additional shares found
    WARNING: Shared folders found, check against documentation
    FAIL:
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-drv-05-shared-folders
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Shared Folders'
    $result.check  = 'c-drv-05-shared-folders'

    #... CHECK STARTS HERE ...#

    Try
    {   #                                                              Admin Shares         IPC Share
        [string]$query = "SELECT Name FROM Win32_Share WHERE NOT(Type='2147483648' OR Type='2147483651') AND NOT Name=''"
        If ($script:appSettings['IgnoreTheseShares'].Count -gt 0)
        {
            For ($i = 0; $i -lt $script:appSettings['IgnoreTheseShares'].Count; $i++)
            {
                $query += " AND NOT Name='" + $script:appSettings['IgnoreTheseShares'][$i] + "'"
            }
        }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Warning']
        $result.message = 'Shared folders found, check against documentation'
        $check | ForEach { $result.data += '{0},#' -f $_ }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No additional shares found'
    }
    
    Return $result
}
}

$cdrv06 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductNames'] = ('HDLM GUI', 'SANsurfer', 'Emulex FC')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Where SAN storage is used, ensure multipathing software is installed and Dual Paths are present and functioning.
        ** ONLY CHECKS IF SOFTWARE INSTALLED **


    PASS:
    WARNING:
    FAIL:    SAN storage software not found, install required
    MANUAL:  {0} found
    NA:      Not a physical machine

    APPLIES: Physicals

    REQUIRED-FUNCTIONS: Win32_Product, Check-VMware
#>

Function c-drv-06-san-storage
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'SAN Storage Software'
    $result.check  = 'c-drv-06-san-storage'
    
    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $false)
    {
        Try
        {
            [boolean]$found = $false
            $script:appSettings['ProductNames'] | ForEach {
                [string]$verCheck = Win32_Product -serverName $serverName -displayName $_
                If ([string]::IsNullOrEmpty($verCheck) -eq $false)
                {
                    $found            = $true
                    [string]$prodName = $_
                    [string]$prodVer  = $verCheck
                }
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }        

        If ($found -eq $true)
        {
            $result.result  = $script:lang['Manual']
            $result.message = '{0} found'   -f $prodName
            $result.data    = 'Version {0}' -f $prodVer
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'SAN storage software not found, install required'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a physical machine'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Win32_Product
{
    Param ( [string] $serverName, [string] $displayName )
    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() }
    }
    Catch { Return $null }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } }
        }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Win32_Product -serverName $serverName -displayName $displayName
            }
            Else { $verCheck = $null } }
    }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$cdrv07 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductNames'] = ('HP Array Configuration Utility', 'Dell OpenManage Server Administrator', 'Broadcom Drivers And Management Applications')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check local disk array management agent is installed on the server.
        ** ONLY CHECKS IF SOFTWARE INSTALLED **


    PASS:
    WARNING:
    FAIL:    Disk management software not found, install required
    MANUAL:  {0} found
    NA:      Not a physical machine

    APPLIES: Physicals

    REQUIRED-FUNCTIONS: Win32_Product, Check-VMware
#>

Function c-drv-07-disk-management-agent
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Disk Management Agent'
    $result.check  = 'c-drv-07-disk-management-agent'
    
    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $false)
    {
        Try
        {
            [boolean]$found = $false
            $script:appSettings['ProductNames'] | ForEach {
                [string]$verCheck = Win32_Product -serverName $serverName -displayName $_
                If ([string]::IsNullOrEmpty($verCheck) -eq $false)
                {
                    $found            = $true
                    [string]$prodName = $_
                    [string]$prodVer  = $verCheck
                }
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }        

        If ($found -eq $true)
        {
            $result.result  = $script:lang['Manual']
            $result.message = '{0} found'   -f $prodName
            $result.data    = 'Version {0}' -f $prodVer
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Disk management software not found, install required'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a physical machine'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Win32_Product
{
    Param ( [string] $serverName, [string] $displayName )
    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() }
    }
    Catch { Return $null }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } }
        }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Win32_Product -serverName $serverName -displayName $displayName
            }
            Else { $verCheck = $null } }
    }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$cdrv08 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure all drives are formatted as NTFS



    PASS:    All drives are formatted as NTFS
    WARNING:
    FAIL:    One or more drives were found not formatted as NTFS
    MANUAL:  Unable to get drive information, please check manually
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-drv-08-drive-ntfs-format
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'All drives are NTFS format'
    $result.check  = 'c-drv-08-drive-ntfs-format'
 
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT *  FROM Win32_LogicalDisk WHERE DriveType = "3"'    # Filter on DriveType=3 (Fixed Drives)
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, FileSystem
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $countFailed = 0
    $result.data = ''
    If ($check -ne $null)
    {
        $check | ForEach {
            If ($_.FileSystem -ne 'NTFS')
            {
                If ($_.FileSystem -eq $null) { $_.FileSystem = 'Not Formatted' }
                $result.data += '{0} ({1}),#' -f $_.Name, $_.FileSystem
                $countFailed += 1
            }
        }
    
        If ($countFailed -ne 0)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more drives were found not formatted as NTFS'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All drives are formatted as NTFS'
        }
    }
    Else
    {
        $result.result  = $script:lang['Manual']
        $result.message = 'Unable to get drive information, please check manually'
        $result.data    = 'All drives need to be formatted as NTFS'
    }
    Return $result
}
}

$chvh01 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check Hyper-V is installed on server core



    PASS:    Hyper-V is using Windows Server Core
    WARNING:
    FAIL:    Hyper-V is not using Windows Server Core
    MANUAL:
    NA:      Not a Hyper-V server

    APPLIES: Hyper-V Hosts

    REQUIRED-FUNCTIONS: Check-NameSpace, Check-HyperV
#>

Function c-hvh-01-server-core
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Server Core'
    $result.check  = 'c-hvh-01-server-core'
 
    #... CHECK STARTS HERE ...#

    If ((Check-HyperV $serverName) -eq $true)
    {
        Try
        {
            [string] $query   = 'SELECT Name FROM Win32_ServerFeature WHERE Name = "Server Graphical Shell"'
            [string] $check   = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name

            If ([string]::IsNullOrEmpty($check) -eq $true)
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Hyper-V is not using Windows Server Core'
            }
            Else
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'Hyper-V is using Windows Server Core'
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Hyper-V server'
    }

    Return $result
}
Function Check-NameSpace
{
    Param ( [string]$serverName, [string]$namespace )
    [string]$find = $namespace;  [string]$ns = 'ROOT'
    If ($namespace -like '*\*') { [string]$find = $namespace.Split('\')[-1]; [string]$ns = 'ROOT\' + $namespace.replace('\{0}' -f $find, '') }
    [array] $wmin = Get-WmiObject -ComputerName $serverName -Namespace $ns -Class '__Namespace' | Select-Object -ExpandProperty Name
    If ($wmin -contains $find) { Return $true } Else { Return $false }
}
Function Check-HyperV
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}

}

$chvh02 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check Hyper-V is the only one installed



    PASS:    No extra server roles or features exist
    WARNING:
    FAIL:    One or more extra server roles or features exist
    MANUAL:
    NA:      Not a Hyper-V server

    APPLIES: Hyper-V Hosts

    REQUIRED-FUNCTIONS: Check-NameSpace, Check-HyperV
#>

Function c-hvh-02-no-other-server-roles
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'No Other Server Roles'
    $result.check  = 'c-hvh-02-no-other-server-roles'
 
    #... CHECK STARTS HERE ...#

    If ((Check-HyperV $serverName) -eq $true)
    {
        Try
        {
            # This will need to be change to use "Get-WindowsFeature" in 2012+
            [string]$query = "Select Name, ID FROM Win32_ServerFeature WHERE ParentID = '0'"
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2
            [System.Collections.ArrayList]$check2 = @()
            $check | ForEach { $check2 += $_ }

            ForEach ($ck In $check)
            {
                ForEach ($exc In $script:appSettings['IgnoreTheseRoleIDs'])
                {
                    If ($ck.ID -eq $exc) { $check2.Remove($ck) }
                }
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check2.Count -ne 0)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more extra server roles or features exist'
            $check2 | ForEach { $result.data += '{0},#' -f $_.Name }
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'No extra server roles or features exist'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Hyper-V server'
    }

    Return $result
}
Function Check-NameSpace
{
    Param ( [string]$serverName, [string]$namespace )
    [string]$find = $namespace;  [string]$ns = 'ROOT'
    If ($namespace -like '*\*') { [string]$find = $namespace.Split('\')[-1]; [string]$ns = 'ROOT\' + $namespace.replace('\{0}' -f $find, '') }
    [array] $wmin = Get-WmiObject -ComputerName $serverName -Namespace $ns -Class '__Namespace' | Select-Object -ExpandProperty Name
    If ($wmin -contains $find) { Return $true } Else { Return $false }
}
Function Check-HyperV
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}

}

$chvh03 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check all VMs are running from a non-system drive



    PASS:    No virtual machines are using the system drive
    WARNING:
    FAIL:    One or more virtual machines are using the system drive
    MANUAL:
    NA:      Not a Hyper-V server / No virtual machines exist on this host

    APPLIES: Hyper-V Hosts

    REQUIRED-FUNCTIONS: Check-NameSpace, Check-HyperV
#>

Function c-hvh-03-vm-location
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'VM Location'
    $result.check  = 'c-hvh-03-vm-location'
 
    #... CHECK STARTS HERE ...#

    If ((Check-HyperV $serverName) -eq $true)
    {
        Try
        {
            [string]$query1 = 'SELECT SystemDrive FROM Win32_OperatingSystem'
            [string]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty SystemDrive
            [string]$query2 = 'SELECT * FROM Msvm_ComputerSystem WHERE Caption="Virtual Machine"'
            [object]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Virtualization\v2
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check2.Count -ne 0)
        {
            [string]$result.data = ''
            ForEach ($vm In $check2)
            {
                $VSSD = Get-WmiObject -ComputerName $serverName -Query "SELECT * FROM Msvm_VirtualSystemSettingData     WHERE ConfigurationID =              '$($VM.Name)'"  -Namespace ROOT\Virtualization\v2
                $SASD = Get-WmiObject -ComputerName $serverName -Query "SELECT * FROM Msvm_StorageAllocationSettingData WHERE      InstanceID LIKE 'Microsoft:$($VM.Name)%'" -Namespace ROOT\Virtualization\v2

                If ($($VSSD.ConfigurationDataRoot).Substring(0,2) -eq $check1) { $result.data += '{0} - Configuration,#' -f $VM.ElementName }
                ForEach ($SA In $SASD) {
                    [int]$driveNum = $(($SA.Parent).Split("\")[11])
                    $item = $SA
                    Do
                    {
                        $parent = ($item.Parent).Split('=')[1].Split('\\')[0].Split(':')[1].Trim('"')
                        $item = Get-WmiObject -ComputerName $serverName -Query "SELECT * FROM Msvm_VirtualSystemSettingData     WHERE ConfigurationID LIKE           '$parent%'" -Namespace ROOT\Virtualization\v2
                        $path = Get-WmiObject -ComputerName $serverName -Query "SELECT * FROM Msvm_StorageAllocationSettingData WHERE      InstanceID LIKE 'Microsoft:$parent%'" -Namespace ROOT\Virtualization\v2

                        If (($path.HostResource[$driveNum]).Substring(0,2) -eq $check1) { $result.data += '{0} - Disk {1},#' -f $VM.ElementName, $driveNum }
                    }
                    While ($item.Parent)
                }
            }

            If ($result.data -ne '')
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'One or more virtual machines are using the system drive'
            }
            Else
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'No virtual machines are using the system drive'
            }
        }
        Else
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'No virtual machines exist on this host'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Hyper-V server'
    }

    Return $result
}
Function Check-NameSpace
{
    Param ( [string]$serverName, [string]$namespace )
    [string]$find = $namespace;  [string]$ns = 'ROOT'
    If ($namespace -like '*\*') { [string]$find = $namespace.Split('\')[-1]; [string]$ns = 'ROOT\' + $namespace.replace('\{0}' -f $find, '') }
    [array] $wmin = Get-WmiObject -ComputerName $serverName -Namespace $ns -Class '__Namespace' | Select-Object -ExpandProperty Name
    If ($wmin -contains $find) { Return $true } Else { Return $false }
}
Function Check-HyperV
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}

}

$chvh04 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check the version of the Integration Services



    PASS:    
    WARNING:
    FAIL:    Registry setting not found
    MANUAL:  Integration services found
    NA:      Not a Hyper-V server

    APPLIES: Hyper-V Hosts

    REQUIRED-FUNCTIONS: Check-NameSpace, Check-HyperV
#>

Function c-hvh-04-integration-services
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Integration Services'
    $result.check  = 'c-hvh-04-integration-services'
 
    #... CHECK STARTS HERE ...#

    If ((Check-HyperV $serverName) -eq $true)
    {
        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\GuestInstaller\Version')
            If ($regKey) { [string]$keyVal = $regKey.GetValue('Microsoft-Hyper-V-Guest-Installer') }
            Try { $regKey.Close() } Catch { }
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ([string]::IsNullOrEmpty($keyVal) -eq $false)
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Integration services found'
            $result.data    = ('Version: {0}' -f $keyVal)
        }
        Else
        {
            $result.result  = $script:lang['fail']
            $result.message = 'Registry setting not found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a Hyper-V server'
    }

    Return $result
}
Function Check-NameSpace
{
    Param ( [string]$serverName, [string]$namespace )
    [string]$find = $namespace;  [string]$ns = 'ROOT'
    If ($namespace -like '*\*') { [string]$find = $namespace.Split('\')[-1]; [string]$ns = 'ROOT\' + $namespace.replace('\{0}' -f $find, '') }
    [array] $wmin = Get-WmiObject -ComputerName $serverName -Namespace $ns -Class '__Namespace' | Select-Object -ExpandProperty Name
    If ($wmin -contains $find) { Return $true } Else { Return $false }
}
Function Check-HyperV
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}

}

$cnet01 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check IPv6 has been unbound on all active NICs, or globally



    PASS:    IPv6 disabled globally / IPv6 enabled globally, but disabled on all NICs
    WARNING:
    FAIL:    IPv6 enabled globally, and NIC(s) found with IPv6 enabled
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-net-01-no-ipv6
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'IPv6 Disabled'
    $result.check  = 'c-net-01-no-ipv6'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        # First check if IPv6 is disabled globally
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\TCPIP6\Parameters')
        If ($regKey) { $keyVal = [string]$regKey.GetValue('DisabledComponents') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()

    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($keyval -eq '-1')    # All Disabled
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'IPv6 disabled globally'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'IPv6 enabled globally'

        # Second, check each adapter
        # Get binding GUIDs from reg key
        Try
        {
            $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey2 = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\TCPIP6\Linkage')
            If ($regKey2) { $keyVal2 = $regKey2.GetValue('Bind') }
            Try { $regKey.Close() } Catch { }
            $reg.Close()
        }
        Catch
        {
            $result.pass     = $script:lang['Error']
            $result.message += $script:lang['Script-Error']
            $result.data     = $_.Exception.Message
            Return $result
        }

        # Get names from WMI based on keyVal2 GUIDs
        [array]$ipv6Adapters = $null
    
        If ([string]::IsNullOrEmpty($keyVal2) -eq $false)
        {
            ForEach ($bind In $keyVal2)
            {
                Try
                {
                    $deviceid = $bind.split('\')[2]
                    [string]$query   = 'SELECT NetConnectionID FROM Win32_NetworkAdapter WHERE GUID="{0}"' -f $deviceid
                    [array] $adapter = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty NetConnectionID
                }
                Catch
                {
                    $result.result  = $script:lang['Error']
                    $result.message = $script:lang['Script-Error']
                    $result.data    = $_.Exception.Message
                    Return $result
                }

                If ([string]::IsNullOrEmpty($adapter) -eq $false)
                {
                    $ipv6Adapters +=            $adapter
                    $result.data  += '{0},#' -f $adapter
                }
            }

            If ($ipv6Adapters.Count -gt 0)
            {
                $result.result   = $script:lang['Fail']
                $result.message += ' and NIC(s) found with IPv6 enabled'
            }
            Else
            {
                $result.result   = $script:lang['Pass']
                $result.message += ', but disabled on all NICs'
                $result.data     = ''
            }
        }
        Else
        {
            $result.result   = $script:lang['Pass']
            $result.message += ', but disabled on all NICs'
            $result.data     = ''
        }
    }

    Return $result
}
}

$cnet02 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check there are no unused Network interfaces on the server. We define "not in use" by showing any ENABLED NICs set to DHCP
        All NICs should have a statically assigned IP address.


    PASS:    No DHCP enabled adapters found
    WARNING:
    FAIL:    DHCP enabled adapters found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-net-02-unused-network-interfaces
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Unused Network Adapters'
    $result.check  = 'c-net-02-unused-network-interfaces'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT * FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled="TRUE" AND DHCPEnabled="TRUE"'
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'DHCP enabled adapters found'
        $check | ForEach {
            $nicName = $_.GetRelated('Win32_NetworkAdapter') | Select-Object -ExpandProperty NetConnectionID
            $result.data += '{0},#' -f $nicName
        }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No DHCP enabled adapters found'
    }

    Return $result
}
}

$cnet03 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check network interfaces are labelled so their purpose is easily identifiable.
        FAIL if any Adapter Names are "Local Area Connection x" or "Ethernet x"


    PASS:    All adapters renamed from default
    WARNING:
    FAIL:    An adapter was found with the default name
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-net-03-network-adapter-labels
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Network Adapter Names'
    $result.check  = 'c-net-03-network-adapter-labels'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT NetConnectionID FROM Win32_NetworkAdapter WHERE NetConnectionID = ""'
        ('Local Area Connection', 'Ethernet') | ForEach { $query += ' OR NetConnectionID LIKE "%{0}%"' -f $_ }
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty NetConnectionID
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $result.result  = $script:lang['Pass']
    $result.message = 'All adapters renamed from default'

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'An adapter was found with the default name'
        $check | ForEach { $result.data += '{0},#' -f $_ }
    }

    Return $result
}
}

$cnet04 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ManagementAdapterNames'] = ('Management', 'MGMT', 'MGT')
$script:appSettings['ProductionAdapterNames'] = ('Production', 'PROD', 'PRD')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check binding order is set correctly for "Production" as the primary network adapter then as applicable for other interfaces
        If no "Production" adapter is found, "Management" should be first


    PASS:    Binding order correctly set
    WARNING:
    FAIL:    No network adapters found / {0} or {1} adapters not listed / Binding order incorrect, {0} should be first / Registry setting not found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-net-04-binding-order
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Network Binding Order'
    $result.check  = 'c-net-04-binding-order'

    #... CHECK STARTS HERE ...#

    Try
    {
        # Get binding order GUIDs from reg key
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\Tcpip\Linkage')
        If ($regKey) { $keyVal = $regKey.GetValue('Bind') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    [array]$bindingorder = $null
    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        ForEach ($bind In $keyVal)
        {
            Try
            {
                [string]$deviceid = ($bind -split '\\')[2]
                If ($deviceid -notlike '{*}')
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = 'No network adapters found'
                    $result.data    = ''
                    Return $result
                }

                [string]$query   = 'SELECT NetConnectionID FROM Win32_NetworkAdapter WHERE GUID="{0}"' -f $deviceid
                [array] $adapter = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty NetConnectionID
            }
            Catch
            {
                $result.result  = $script:lang['Error']
                $result.message = $script:lang['Script-Error']
                $result.data    = $_.Exception.Message
                Return $result
            }

            If ([string]::IsNullOrEmpty($adapter) -eq $false)
            {
                $bindingorder +=            $adapter
                $result.data  += '{0},#' -f $adapter
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
        Return $result
    }

    [boolean]$prodExists = $false
    [boolean]$mgmtExists = $false

    If ($bindingorder -eq $null)
    {
        $result.result  = $script:lang['Fail']
        $result.message = '{0} or {1} adapters not listed' -f $script:appSettings['ProductionAdapterNames'][0], $script:appSettings['ManagementAdapterNames'][0]
        $result.data    = ''
        Return $result
    }

    # Check if 'Production' actually exists
    ForEach ($p In $script:appSettings['ProductionAdapterNames'])
    {
        # Check if firstmost binding is 'Production'
        If ($bindingorder[0] -like '{0}*' -f $p )
        {
            $prodExists     = $true
            $result.result  = $script:lang['Pass']
            $result.message = 'Binding order correctly set'
            Break
        }
        ElseIf ($bindingorder -like '*{0}*' -f $p)
        {
            $prodExists     = $true
            $result.result  = $script:lang['Fail']
            $result.message = 'Binding order incorrect, {0} should be first' -f $script:appSettings['ProductionAdapterNames'][0]
            Break
        }
        Else
        {
            $prodExists = $false
        }
    }

    If ($prodExists -eq $false)
    {
        # No 'Production', check for 'Management'
        ForEach ($m In $script:appSettings['ManagementAdapterNames'])
        {
            # Check if firstmost binding is 'Management'
            If ($bindingorder[0] -like '{0}*' -f $m)
            {
                $mgmtExists     = $true
                $result.result  = $script:lang['Pass']
                $result.message = 'Binding order correctly set'
                Break
            }
            ElseIf ($bindingorder -like '*{0}*' -f $m)
            {
                $mgmtExists     = $true
                $result.result  = $script:lang['Fail']
                $result.message = 'Binding order incorrect, {0} should be first' -f $script:appSettings['ManagementAdapterNames'][0]
                Break
            }
            Else
            {
                $mgmtExists = $false
            }
        }
    }

    If (($prodExists -eq $false) -and ($mgmtExists -eq $false))
    {
        $result.result  = $script:lang['Fail']
        $result.message = '{0} or {1} adapters not listed' -f $script:appSettings['ProductionAdapterNames'][0], $script:appSettings['ManagementAdapterNames'][0]
    }
    
    Return $result
}
}

$cnet05 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check the network adapter speed and duplex settings.
        Should be set to "Full Duplex" and "Auto"


    PASS:    All network adapters configured correctly
    WARNING: One or more network adapters configured incorrectly
    FAIL:    No network adapters found or enabled
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-net-05-network-speed-duplex
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Network Speed And Duplex'
    $result.check  = 'c-net-05-network-speed-duplex'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT * FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled = "True"'
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All network adapters configured correctly'

        ForEach ($connection In $check)
        {
            $data   = $connection.Caption -split ']'
            $suffix = $data[0].Substring(($data[0].length - 4), 4)

            Try
            {
                $reg     = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
                $regKey1 = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318}\' + $suffix)
                If ($regKey1) { $keyVal = $regKey1.GetValue('*PhysicalMediaType') }
            }
            Catch
            {
                $result.result  = $script:lang['Error']
                $result.message = $script:lang['Script-Error']
                $result.data    = $_.Exception.Message
                Return $result
            }

            If ($keyVal -eq '14')    # Ethernet
            {
                $nic   = $connection.GetRelated('Win32_NetworkAdapter') | Select-Object Speed, NetConnectionID
                $keySD = $regKey1.GetValue('*SpeedDuplex')

                $regPath2 = 'SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318}\' + $suffix + '\Ndi\Params\*SpeedDuplex\enum'
                $regKey2  = $reg.OpenSubKey($regPath2)
                If ($keySD -ne $null) { $duplex = $regKey2.GetValue($keySD) } Else { $duplex = 'unknown' }

                $nicSpeed = [math]::Round($nic.Speed/1000000)
                If (($nicSpeed -lt 1000) -or ($duplex -notlike '*auto*'))
                {
                    $result.result  = $script:lang['Warning']
                    $result.message = 'One or more network adapters configured incorrectly'
                }
                $result.data += '{0}: {1}mb ({2}),#' -f $nic.NetConnectionID, $nicSpeed, $duplex
                If ($keySD -ne $null) { $regKey2.Close() }
            }
        }
        $regKey1.Close()
        $reg.Close()
    }
    Else
    {
       $result.result  = $script:lang['Fail']
       $result.message = 'No network adapters found or enabled'
       $result.data    = ''
    }

    Return $result
}
}

$cnet06 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductNames'] = ('HP Network Config Utility', 'Broadcom Advanced Control Suite')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION:
        Check local network management agent is installed on the server.
        ** ONLY CHECKS IF SOFTWARE INSTALLED **


    PASS:    {0} found
    WARNING:
    FAIL:    Network management software not found, install required
    MANUAL:
    NA:      Not a physical machine

    APPLIES: Physicals

    REQUIRED-FUNCTIONS: Win32_Product, Check-VMware
#>

Function c-net-06-network-agent
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Network Management Agent'
    $result.check  = 'c-net-06-network-agent'

    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $false)
    {
        Try
        {
            [boolean]$found = $false
            $script:appSettings['ProductNames'] | ForEach {
                [string]$verCheck = Win32_Product -serverName $serverName -displayName $_
                If ([string]::IsNullOrEmpty($verCheck) -eq $false)
                {
                    $found            = $true
                    [string]$prodName = $_
                    [string]$prodVer  = $verCheck
                }
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($found -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.message = '{0} found'   -f $prodName
            $result.data    = 'Version {0}' -f $prodVer
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Network management software not found, install required'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a physical machine'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Win32_Product
{
    Param ( [string] $serverName, [string] $displayName )
    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() }
    }
    Catch { Return $null }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } }
        }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Win32_Product -serverName $serverName -displayName $displayName
            }
            Else { $verCheck = $null } }
    }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$cnet07 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['NetworkTeamNames'] = ('HP Network Teaming', 'BASP Virtual Adapter')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check network interfaces for known teaming names, manually check they are configured correctly.
        Fail if no teams found or if server is a virtual.  Checked configuration is:
        Teaming Mode: "Static Independent";  Load Balancing Mode: "Address Hash";  Standby Adapter: (set)

    PASS:    Network team count: {0}
    WARNING:
    FAIL:    No teamed network adapter(s) found / There are no network teams configured on this server / Native teaming enabled on virtual machine / Team configuration is not set correctly
    MANUAL:  Teamed network adpater(s) found, check they are configured correctly
    NA:      Not a physical server / Operating system not supported

    APPLIES: Physicals

    REQUIRED-FUNCTIONS: Check-VMware
#>

Function c-net-07-network-teaming
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Network Teaming'
    $result.check  = 'c-net-07-network-teaming'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Caption FROM Win32_OperatingSystem'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption

        If ($check -like '*200*')    # 2003, 2008
        {
            [string]$query1 = 'SELECT ProductName, NetConnectionID FROM Win32_NetworkAdapter WHERE ProductName = "dummyValue"'
            $script:appSettings['NetworkTeamNames'] | ForEach { $query1 += ' AND ProductName = "{0}"' -f $script:appSettings['NetworkTeamNames'] }
            [array]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty NetConnectionID
        }
        ElseIf ($check -like '*201*')    # 2012, 2016
        {
            [string]$query1 = 'SELECT Name, LoadBalancingAlgorithm, TeamingMode FROM MSFT_NetLbfoTeam'
            [array] $check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\StandardCimv2 | Select-Object Name, LoadBalancingAlgorithm, TeamingMode | Sort-Object Name

            If ([string]::IsNullOrEmpty($check1) -eq $false)
            {
                [string]$query2 = 'SELECT Name, Team, AdministrativeMode, FailureReason, OperationalMode FROM MSFT_NetLbfoTeamMember'
                [array] $check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\StandardCimv2 | Select-Object Name, Team, AdministrativeMode, FailureReason, OperationalMode | Sort-Object Name

                [string]$query3 = 'SELECT Team, VlanID FROM MSFT_NetLbfoTeamNic'
                [array] $check3 = Get-WmiObject -ComputerName $serverName -Query $query3 -Namespace ROOT\StandardCimv2 | Select-Object Team, VlanID
            }
            Else
            {
                [array]$check1 = ('NOTEAMS')    # 
            }
        }
        Else
        {
            [array]$check1 = ('UNKNOWN')    # Desktop OS, Unsupported
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }


    If ($check -like '*200*')    # 2003, 2008
    {
        If ((Check-VMware $serverName) -eq $false)
        {
            If ($check1.Count -gt 0)
            {
                $result.result  = $script:lang['Manual']
                $result.message = 'Teamed network adpater(s) found, check they are configured correctly'
                $check1 | ForEach { $result.data += '{0},#' -f $_ }
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'No teamed network adapter(s) found'
            }
        }
        Else
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'Not a physical server'
        }
    }
    ElseIf ($check -like '*201*')    # 2012, 2016
    {
        If ($check1 -eq 'NOTEAMS')
        {
            If ((Check-VMware $serverName) -eq $true)
            {
                $result.result  = $script:lang['Not-Applicable']
                $result.message = 'Not a phsical server'
                $result.data    = ''
            }
            Else
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'There are no network teams configured on this server'
                $result.data    = 'All phyiscal servers should have teamed network adapters'
            }
        }
        Else
        {
            If ((Check-VMware $serverName) -eq $true)
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Native teaming enabled on virtual machine'
                $result.data    = 'Virtual machines should not be using network teaming'
            }
            Else
            {
                [array]$teams = @()
                ForEach ($team In $check1)
                {
                    [PSCustomObject]$newTeam = New-Object -TypeName PSObject -Property @{'name'=''; 'lba'=''; 'tm'=''; 'adapters'=@(); 'standby'=''}
                    $newTeam.name = $team.Name
                    $newTeam.lba  = $team.LoadBalancingAlgorithm
                    $newTeam.tm   = $team.TeamingMode

                    ForEach ($nic In $check2)
                    {
                        If ($nic.Team -eq $team.Name)
                        {
                            $newTeam.adapters += $nic.Name
                            If (($nic.AdministrativeMode -eq '1') -and ($nic.FailureReason -eq '1') -and ($nic.OperationalMode -eq '1')) { $newTeam.standby = $nic.Name }
                        }
                    }
                    $teams += $newTeam
                }

                If ($teams.Count -gt 0)
                {
                    [boolean]$pass = $true
                    $result.message = 'Network team count: '+ $teams.Count
                    ForEach ($team In $teams)
                    {
                        [string]$vlan = $check3[$check3.Team.IndexOf($team.name)].VlanID
                        If ($vlan -eq '') { $vlan = 'none' }
                        $result.data += '{0} (vlan: {1}): ' -f $team.name, $vlan

                        Switch ($team.tm)
                        {
                            '0' { $result.data += 'Static Teaming, '    ; $pass = $false }
                            '1' { $result.data += 'Static Independent, '                 }    # Default Config
                            '2' { $result.data += 'LACP, '              ; $pass = $false }
                        }

                        Switch ($team.lba)
                        {
                            '0' { $result.data += 'Address Hash, '                       }    # Default Config
                            '4' { $result.data += 'Hyper-V Port, '      ; $pass = $false }
                            '5' { $result.data += 'Dynamic, '           ; $pass = $false }
                        }

                        If ($team.standby -eq '')
                        {
                            $result.data += 'No standby NIC.#';
                            $pass = $false
                        }
                        Else
                        {
                            $result.data += $team.standby + '.#'
                        }
                    }

                    If ($pass -eq $true)
                    {
                        $result.result  = $script:lang['Pass']
                    }
                    Else
                    {
                        $result.result  = $script:lang['Fail'];
                        $result.message += ', Team configuration is not set correctly'
                    }
                }
                Else
                {
                    $result.result  = $script:lang['Fail']
                    $result.message = 'There are no network teams configured on this server'
                    $result.data    = 'All phyiscal servers should have teamed network adapters'
                }
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Operating system not supported'
        $result.data    = '{0}' -f $check
    }
    Return $result
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$cnet08 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ManagementAdapterNames'] = ('Management', 'MGMT', 'MGT')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check that a management network adapter exists.
        This must always be present on a server and labelled correctly


    PASS:    Management network adapter found
    WARNING:
    FAIL:    No management network adapter
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-net-08-management-adapter
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Management Adapter'
    $result.check  = 'c-net-08-management-adapter'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT NetConnectionID FROM Win32_NetworkAdapter WHERE NetConnectionID = ""'
        $script:appSettings['ManagementAdapterNames'] | ForEach { $query += ' OR NetConnectionID LIKE "%{0}%"' -f $_ }
        [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty NetConnectionID
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $result.result  = $script:lang['Fail']
    $result.message = 'No management network adapter'

    If ([string]::IsNullOrEmpty($check) -eq $false)
    {
        If ($check.Count -gt 0)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Management network adapter found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'No management network adapter'
    }

    Return $result
}
}

$cnet09 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['StaticRoute01'] = ''
$script:appSettings['StaticRoute02'] = ''
$script:appSettings['StaticRoute03'] = ''
$script:appSettings['StaticRoute04'] = ''
$script:appSettings['StaticRoute99'] = ''
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION:
        Checks to make sure the specified static routes have been added



    PASS:    All static routes are present
    WARNING:
    FAIL:    One or more static routes are missing or incorrect
    MANUAL:
    NA:      No static routes to check

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-net-09-static-routes
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Static Routes'
    $result.check  = 'c-net-09-static-routes'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Destination, Mask, NextHop FROM Win32_IP4RouteTable'
        [object]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Destination, Mask, NextHop
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    [boolean]$RoutesToCheck = $false
    For ($i = 1; $i -le 99; $i++)
    {
        [string[]]$routeEntry = $script:appSettings["StaticRoute$(($i -as [string]).PadLeft(2, '0'))"]
        If ([string]::IsNullOrEmpty($routeEntry) -eq $false) { $RoutesToCheck = $true; Break }
    }
    
    If ($RoutesToCheck -eq $false)
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'No static routes to check'
        Return $result
    }

    If ([string]::IsNullOrEmpty($check) -eq $true)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'No static routes present'
    }
    Else
    {
        For ($i = 1; $i -le 99; $i++)
        {
            [string[]]$routeEntry = $script:appSettings["StaticRoute$(($i -as [string]).PadLeft(2, '0'))"]
            If ([string]::IsNullOrEmpty($routeEntry) -eq $false)
            {
                $pos = [array]::IndexOf($check.Destination, $routeEntry[0])
                If ($pos -ge 0)
                {
                    If ($check.Mask[$pos]    -ne $routeEntry[1]) { $result.data += '' + $routeEntry[0] + ' (Wrong Mask),#'    }
                    If ($check.NextHop[$pos] -ne $routeEntry[2]) { $result.data += '' + $routeEntry[0] + ' (Wrong Gateway),#' }
                }
                Else { $result.data += '' + $routeEntry[0] + ' (Missing),#' }
            }
            $routeEntry = $null
        }

        If ($result.data -eq '')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All static routes are present'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more static routes are missing or incorrect'
        }
    }

    Return $result
}
}

$creg01 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check that the server time is correct.  If a valid source is used, the time is also checked against that source.
        Maximum time difference allowed is 10 seconds.  Any longer and the check fails


    PASS:    Time source is set to a remote server, and is syncronsized correctly
    WARNING:
    FAIL:    Time source is set to a remote server, and is not syncronsized correctly / Time source is not set / Time source is not set correctly / Error getting required information / 
    MANUAL:  Not a supported operating system for this check
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-reg-01-local-time
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Local Date/Time'
    $result.check  = 'c-reg-01-local-time'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]  $query = 'SELECT Day, Month, Year, Hour, Minute, Second FROM Win32_LocalTime'
        [array]   $check = Get-WmiObject -ComputerName $serverName  -Query $query -Namespace ROOT\Cimv2 | Select  Day, Month, Year, Hour, Minute, Second
        [datetime]$rdt   = Get-Date -Year $check[0].Year -Month  $check[0].Month  -Day    $check[0].Day `
                                    -Hour $check[0].Hour -Minute $check[0].Minute -Second $check[0].Second

        Try
        {
            If ($serverName -eq $env:ComputerName) {
                [string]$source = Invoke-Command                           -ScriptBlock { &"$env:SystemRoot\System32\w32tm.exe" /query /source } -ErrorAction SilentlyContinue
            }
            Else {
                [string]$source = Invoke-Command -ComputerName $serverName -ScriptBlock { &"$env:SystemRoot\System32\w32tm.exe" /query /source } -ErrorAction SilentlyContinue
            }
            If ($source.Contains(',') -eq $true) { $source = ($source.Split(',')[0]) }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }
        
        If ([string]::IsNullOrEmpty($source) -eq $true)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Time source is not set'
        }
        ElseIf (($source -eq 'Local CMOS Clock') -or ($source -eq 'Free-running System Clock'))
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Time source is not set correctly'
            $result.data    = '{0},#Time is {1}' -f $source, $rdt
        }
        ElseIf ($source -like '*The following error*')
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Error getting required information'
            $result.data    = '{0},#Time is {1}' -f $source, $rdt
        }
        ElseIf ($source -like '*The command /query is unknown*')    # Windows 2003 server
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Not a supported operating system for this check'
            $result.data    = 'Time is {0}' -f $rdt
        }
        Else
        {
            $offSet = (Get-NtpTime -NTPServer $source.Trim() -InputDateTime $rdt)
            If ($offSet -lt 10)
            {
                $result.result   = $script:lang['Pass']
                $result.message += 'Time source is set to a remote server, and is syncronsized correctly'
                $result.data    += 'Source: {0},#Time is about {1} seconds adrift' -f $source.Trim(), $offSet
            }
            Else
            {
                $result.result   = $script:lang['Fail']
                $result.message += 'Time source is set to a remote server, and is not syncronsized correctly'
                $result.data    += 'Source: {0},#Time is about {1} seconds adrift' -f $source.Trim(), $offSet
            }
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    Return $result
}

Function Get-NtpTime {
    Param ([string]$NTPServer, [datetime]$InputDateTime)
    $StartOfEpoch=New-Object DateTime(1900,1,1,0,0,0,[DateTimeKind]::Utc)   
    Function OffsetToLocal($Offset) { $StartOfEpoch.AddMilliseconds($Offset).ToUniversalTime() }
    [Byte[]]$NtpData = ,0 * 48
    $NtpData[0]      = 0x1B

    $Socket = New-Object Net.Sockets.Socket([Net.Sockets.AddressFamily]::InterNetwork, [Net.Sockets.SocketType]::Dgram, [Net.Sockets.ProtocolType]::Udp)
    $Socket.SendTimeOut    = 2000
    $Socket.ReceiveTimeOut = 2000
    Try { $Socket.Connect($NTPServer, 123) } Catch { Return 'Failed to connect to server' }
    Try { [Void]$Socket.Send($NtpData); [Void]$Socket.Receive($NtpData) } Catch { Return 'Failed to communicate with server' }
    $Socket.Shutdown('Both')
    $Socket.Close()

    $IntPart  = [System.BitConverter]::ToUInt32($NtpData[35..32],0)
    $FracPart = [System.BitConverter]::ToUInt32($NtpData[39..36],0)
    $CalcPart = $IntPart * 1000 + ($FracPart * 1000 / 0x100000000)
    $Offset =  ($CalcPart - ($InputDateTime.ToUniversalTime() - $StartOfEpoch).TotalMilliseconds)

    Return [Math]::Round($Offset/1000, 3)
}
}

$creg02 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['TimeZoneNames'] = ('(UTC) Dublin, Edinburgh, Lisbon, London', '(GMT) Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London', '(UTC +00:00) Dublin, Edinburgh, Lisbon, London')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check that the server timezone is correct.  Default setting is "(GMT) Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London"
        For Windows 2003, check is "(UTC) Dublin, Edinburgh, Lisbon, London"


    PASS:    Server timezone set correctly
    WARNING:
    FAIL:    Server timezone is incorrect and should be set to {0}
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-reg-02-timezone
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Local Timezone'
    $result.check  = 'c-reg-02-timezone'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'Select Caption FROM Win32_TimeZone'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($script:appSettings['TimeZoneNames'] -contains $check )
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Server timezone set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Server timezone is incorrect and should be set to {0}' -f $script:appSettings['TimeZoneNames']
        $result.data    = $check
    }

    Return $result
}
}

$creg03 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DefaultLocation'] = 'United Kingdom'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure the Region and Language > Location is set correctly.
        Default setting is "United Kingdom"


    PASS:    Regional location set correctly
    WARNING:
    FAIL:    Regional location incorrectly set to {0} / Registry setting not found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-reg-03-location
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Region > Location'
    $result.check  = 'c-reg-03-location'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('Users', $serverName)
        $regKey = $reg.OpenSubKey('.DEFAULT\Control Panel\International')
        If ($regKey) { $keyVal = $regKey.GetValue('sCountry') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq $script:appSettings['DefaultLocation'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Regional location set correctly'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Regional location incorrectly set to {0}' -f $keyVal
            $result.data    = $keyVal.toString()
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
}

$creg04 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DefaultLanguage'] = '00000809'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure the Region and Language > keyboard and Languages is set correctly
        Default setting is "English (United Kingdom)"  


    PASS:    Keyboard layout is set correctly
    WARNING:
    FAIL:    Keyboard layout is not set correctly / Registry setting not found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-reg-04-language
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Region > Language'
    $result.check  = 'c-reg-04-language'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('Users', $serverName)
        $regKey = $reg.OpenSubKey('.DEFAULT\Keyboard Layout\Preload')
        If ($regKey) { $keyVal = $regKey.GetValue('1') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq $script:appSettings['DefaultLanguage'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Keyboard layout is set correctly'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Keyboard layout is not set correctly'
            $result.data    =  $keyVal
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
}

$csec01 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DisabledCiphers'] = ('DES 56/56', 'NULL', 'RC2 128/128', 'RC2 40/128', 'RC2 56/128', 'RC2 56/56', 'RC4 128/128', 'RC4 40/128', 'RC4 56/128', 'RC4 64/128')
$script:appSettings['EnabledCiphers'] = ('AES 128/128', 'AES 256/256', 'Triple DES 168/168')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure security ciphers are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings



    PASS:    All ciphers set correctly
    WARNING:
    FAIL:    One or more ciphers set incorrectly
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-01-schannel-p1-ciphers
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Security Settings 1: Ciphers'
    $result.check  = 'c-sec-01-schannel-p1-ciphers'

    #... CHECK STARTS HERE ...#

    Try
    {
        $disabled = $true
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)

        For ($i = 0; $i -lt 2; $i++)
        {
            If ($i -eq 0) { $regPathCheck = $script:appSettings['EnabledCiphers'];  $regValue = 0xFFFFFFFF; $regResult = 'Enabled'  }
            If ($i -eq 1) { $regPathCheck = $script:appSettings['DisabledCiphers']; $regValue = 0;          $regResult = 'Disabled' }

            ForEach ($key In $regPathCheck)
            {
                $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Ciphers\' + $key)
                If ([string]::IsNullOrEmpty($keyKey) -eq $false)
                {
                    $keyVal = $regKey.GetValue('Enabled')
                    If ($keyVal -ne $regValue)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Should be {1}),#' -f $key, $regResult
                    }        
                }
                Else
                {
                    # Only show MISSING for ciphers that should be disabled
                    If ($i -eq 1)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Missing, should be {1}),#' -f $key, $regResult
                    }
                }
                Try { $regKey.Close() } Catch { }
            }
        }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($disabled -eq $true)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All ciphers set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'One or more ciphers set incorrectly'
    }

    Return $result
}
}

$csec02 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DisabledHashes'] = ('MD5')
$script:appSettings['EnabledHashes'] = ('SHA', 'SHA256', 'SHA384', 'SHA512')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure hashes are set correctly.   Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings



    PASS:    All hashes set correctly
    WARNING:
    FAIL:    One or more hashes set incorrectly
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-02-schannel-p2-hashes
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Security Settings 2: Hashes'
    $result.check  = 'c-sec-02-schannel-p2-hashes'

    #... CHECK STARTS HERE ...#

    Try
    {
        $disabled = $true
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)

        For ($i = 0; $i -lt 2; $i++)
        {
            If ($i -eq 0) { $regPathCheck = $script:appSettings['EnabledHashes'];  $regValue = 0xFFFFFFFF; $regResult = 'Enabled'  }
            If ($i -eq 1) { $regPathCheck = $script:appSettings['DisabledHashes']; $regValue = 0;          $regResult = 'Disabled' }

            ForEach ($key In $regPathCheck)
            {
                $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Hashes\' + $key)
                If ($regKey -ne $null)
                {
                    $keyVal = $regKey.GetValue('Enabled')
                    If ($keyVal -ne $regValue)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Should be {1}),#' -f $key, $regResult
                    }        
                }
                Else
                {
                    # Only show MISSING for hashes that should be disabled
                    If ($i -eq 1)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Missing, should be {1}),#' -f $key, $regResult
                    }
                }
                Try { $regKey.Close() } Catch { }
            }
        }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($disabled -eq $true)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All hashes set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'One or more hashes set incorrectly'
    }

    Return $result
}
}

$csec03 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['KeyExchangeAlgorithms'] = ('Diffie-Hellman', 'ECDH', 'PKCS')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION:
        Ensure key exchange algorithms are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings



    PASS:    All key exchange algorithms set correctly
    WARNING:
    FAIL:    One or more key exchange algorithms set incorrectly
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-03-schannel-p3-keyexchangealgorithms
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Security Settings 3: Key Exchange Algorithms'
    $result.check  = 'c-sec-03-schannel-p3-keyexchangealgorithms'

    #... CHECK STARTS HERE ...#

    Try
    {
        $disabled = $true
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        ForEach ($key In $script:appSettings['KeyExchangeAlgorithms'])
        {
            $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\KeyExchangeAlgorithms\' + $key)
            If ([string]::IsNullOrEmpty($regKey) -eq $false)
            {
                $keyVal = $regKey.GetValue('Enabled')
                If ($keyval -eq $null)
                {
                    $disabled     = $false
                    $result.data += '{0} (Value not explicitly set),#' -f $key
                }
                ElseIf ($keyVal -ne 0xFFFFFFFF)
                {
                    $disabled     = $false
                    $result.data += '{0} (Incorrect),#' -f $key
                }
            }
            Else
            {
                # $result.data += '{0} (Key not explicitly set),#' -f $key
            }
            Try { $regKey.Close() } Catch { }
        }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($disabled -eq $true)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All key exchange algorithms set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'One or more key exchange algorithms set incorrectly'
    }

    Return $result
}
}

$csec04 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DisabledProtocols'] = ('Multi-Protocol Unified Hello', 'PCT 1.0', 'SSL 2.0', 'SSL 3.0' , 'TLS 1.0')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure protocols are set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings



    PASS:    All protocols set correctly
    WARNING:
    FAIL:    One or more protocols set incorrectly
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-04-schannel-p4-protocols
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Security Settings 4: Protocols'
    $result.check  = 'c-sec-04-schannel-p4-protocols'

    #... CHECK STARTS HERE ...#

    Try
    {
        $disabled = $true
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        ForEach ($k In $script:appSettings['DisabledProtocols'])
        {
            For ($i = 0; $i -lt 2; $i++)
            {
                If ($i -eq 0) { $key = $k + '\Server' } Else { $key = $k + '\Client' }

                $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\' + $key)
                If ([string]::IsNullOrEmpty($regKey) -eq $false)
                {
                    If ($i -eq 0) { $keyVal = $regKey.GetValue('Enabled') } Else { $keyVal = $regKey.GetValue('DisabledByDefault') }
                    If ($keyval -eq $null)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Value Missing),#' -f $key
                    }
                    ElseIf ($keyVal -ne $i)
                    {
                        $disabled     = $false
                        $result.data += '{0} (Incorrect),#' -f $key
                    }        
                }
                Else
                {
                    $disabled     = $false
                    $result.data += '{0} (Key Missing),#' -f $key
                }
                Try { $regKey.Close() } Catch { }
            }
        }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($disabled -eq $true)
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All protocols set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'One or more protocols set incorrectly'
    }

    Return $result
}
}

$csec05 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['CipherSuiteOrder'] = 'TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P521,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P521,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P521,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P256,TLS_RSA_WITH_AES_256_GCM_SHA384,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_3DES_EDE_CBC_SHA'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure the security cipher order is set correctly.  Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings



    PASS:    Cipher suite order set correctly
    WARNING:
    FAIL:    Cipher suite order not set correctly / Cipher suite order set to the default value
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-05-schannel-p5-cipher-order
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Security Settings 5: Cipher Suite Order'
    $result.check  = 'c-sec-05-schannel-p5-cipher-order'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SOFTWARE\Policies\Microsoft\Cryptography\Configuration\SSL\00010002')
        If ($regKey) { $keyVal = $regKey.GetValue('Functions') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()

    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq $script:appSettings['CipherSuiteOrder'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Cipher suite order set correctly'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Cipher suite order not set correctly'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Cipher suite order set to the default value'
    }

    Return $result
}
}

$csec06 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['RejectAnnonymousAccountEnumeration'] = '1'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure the system is set to reject attempts to enumerate accounts in the SAM by anonymous users.


    
    PASS:    Reject annonymous account enumeration is enabled
    WARNING:
    FAIL:    Reject annonymous account enumeration is disabled / Registry setting not found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-06-reject-enumerate-accounts
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Reject Annonymous Account Enumeration'
    $result.check  = 'c-sec-06-reject-enumerate-accounts'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Lsa')
        If ($regKey) { $keyVal = $regKey.GetValue('restrictanonymousSAM') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq $script:appSettings['RejectAnnonymousAccountEnumeration'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Reject annonymous account enumeration is enabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Reject annonymous account enumeration is disabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
}

$csec07 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['RejectAnnonymousShareEnumeration'] = '1'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure the system is set to reject attempts to enumerate shares in the SAM by anonymous users. 



    PASS:    Reject annonymous share enumeration is enabled
    WARNING:
    FAIL:    Reject annonymous share enumeration is disabled / Registry setting not found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-07-reject-enumerate-shares
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Reject Annonymous Share Enumeration'
    $result.check  = 'c-sec-07-reject-enumerate-shares'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Lsa')
        If ($regKey) { $keyVal = $regKey.GetValue('restrictanonymous') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }
 
    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq $script:appSettings['RejectAnnonymousShareEnumeration'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Reject annonymous share enumeration is enabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Reject annonymous share enumeration is disabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
}

$csec08 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['EnableDomainCredentialCaching'] = '0'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check system is not caching domain credentials



    PASS:    Domain credential caching is disabled
    WARNING:
    FAIL:    Domain credential cahing is enabled / Registry setting not found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-08-domain-credential-caching
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Domain Credential Caching'
    $result.check  = 'c-sec-08-domain-credential-caching'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon')
        If ($regKey) { $keyVal = $regKey.GetValue('CachedLogonsCount') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }
    
    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq $script:appSettings['EnableDomainCredentialCaching'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Domain credential caching is disabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Domain credential caching is enabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
}

$csec09 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ElevatePromptForAdminCredentials'] = ('1', '3')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure the system is set to request administrative credentials before granting an application elevated privileges. 
        Default setting is either "(1):Prompt for credentials on the secure desktop" or "(3):Prompt for credentials"


    PASS:    Prompt for credentials is enabled
    WARNING:
    FAIL:    System is not set to "Prompt for credentials" when launching an application with elevated privileges / Registry setting not found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-09-request-admin-elevated
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Elevate Prompt For Admin Credentials'
    $result.check  = 'c-sec-09-request-admin-elevated'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System')
        If ($regKey) { $keyVal = $regKey.GetValue('ConsentPromptBehaviorAdmin') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($script:appSettings['ElevatePromptForAdminCredentials'] -contains $keyVal)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Prompt for credentials is enabled'
            $result.data    = ''
        }
        Else
        {
            $result.data = 'Current setting: '
            Switch ($keyVal)
            {
                0 { $result.data += 'Elevate without prompting'                    }
                1 { $result.data += 'Prompt for credentials on the secure desktop' }    # Default Setting
                2 { $result.data += 'Prompt for consent on the secure desktop'     }
                3 { $result.data += 'Prompt for credentials'                       }    # Default Setting
                4 { $result.data += 'Prompt for consent'                           }
                5 { $result.data += 'Prompt for consent for non-Windows binaries'  }
            }
        
            $result.result  = $script:lang['Fail']
            $result.message = 'System is not set to "Prompt for credentials" when launching an application with elevated privileges'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
}

$csec10 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['RejectAnnonymousShareAccess'] = '1'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure the system is set to restrict anonymous access to named pipes



    PASS:    Restrict annonymous pipe/share access is enabled
    WARNING:
    FAIL:    Restrict annonymous pipe/share access is disabled / Registry setting not found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-10-anonymous-pipe-share-access
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Reject Annonymous Pipe/Share Access'
    $result.check  = 'c-sec-10-anonymous-pipe-share-access'

    #... CHECK STARTS HERE ...#

    Try
    {    
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\LanManServer\Parameters')
        If ($regKey) { $keyVal = $regKey.GetValue('restrictnullsessaccess') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq $script:appSettings['RejectAnnonymousShareAccess'])
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Restrict annonymous pipe/share access is enabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Restrict annonymous pipe/share access is disabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }
    
    Return $result
}
}

$csec11 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Checks to see if the default webpage is present in IIS



    PASS:    IIS Installed, "iisstart.htm" not listed in default documents
    WARNING:
    FAIL:    IIS Installed, default document "iisstart.htm" configured
    MANUAL:
    NA:      IIS not Installed

    APPLIES: All

    REQUIRED-FUNCTIONS: Check-NameSpace
#>

Function c-sec-11-iis-default-page
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'IIS Default Page'
    $result.check  = 'c-sec-11-iis-default-page'

    #... CHECK STARTS HERE ...#

    Try
    {
        If ((Check-NameSpace -serverName $serverName -namespace 'MicrosoftIISv2') -eq $true)
        {
            # IISv6
            [string]$query  = "SELECT DefaultDoc FROM IISWebServerSetting"
            [string]$chktmp = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\MicrosoftIISv2 | Select-Object -ExpandProperty DefaultDoc
            If ($chktmp -ne $null) { $check = $chktmp.Replace(',', ', ') }
        }
        ElseIf ((Check-NameSpace -serverName $serverName -namespace 'WebAdministration') -eq $true)
        {
            # IISv7
            [string]$query  = "SELECT Files FROM DefaultDocumentSection"
            [array] $chktmp = (Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\WebAdministration).Files.Files | Select-Object -ExpandProperty Value
            If ($chktmp -ne $null) { [string]$check = [string]::Join(', ', $chktmp) }
        }
        Else
        {
            [string]$check = $null    # IIS not installed
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = 'SCRIPT ERROR 1'
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($check) -eq $true)
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'IIS not Installed'
        $result.data    = ''
    }
    Else
    {
        $result.message = 'IIS Installed, '
        If ($check -like '*iisstart.htm*')
        {
            $result.result   = $script:lang['Fail']
            $result.message += 'default document "iisstart.htm" configured'
            $result.data     = '' + $check
        }
        Else
        {
            $result.result   = $script:lang['Pass']
            $result.message += '"iisstart.htm" not listed in default documents'
            $result.data     = '' + $check
        }
    }

    Return $result
}
Function Check-NameSpace
{
    Param ( [string]$serverName, [string]$namespace )
    [string]$find = $namespace;  [string]$ns = 'ROOT'
    If ($namespace -like '*\*') { [string]$find = $namespace.Split('\')[-1]; [string]$ns = 'ROOT\' + $namespace.replace('\{0}' -f $find, '') }
    [array] $wmin = Get-WmiObject -ComputerName $serverName -Namespace $ns -Class '__Namespace' | Select-Object -ExpandProperty Name
    If ($wmin -contains $find) { Return $true } Else { Return $false }
}
}

$csec12 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['RequireSMBSigning'] = '1'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure SMB signing is turned on. 



    PASS:    SMB Signing configured correctly
    WARNING:
    FAIL:    SMB Signing not configured correctly / Registry setting not found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-12-smb-signing-on
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'SMB Signing On'
    $result.check  = 'c-sec-12-smb-signing-on'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters')
        If ($regKey) { $keyVal1 = $regKey.GetValue('RequireSecuritySignature') }
        Try { $regKey.Close() } Catch { }

        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters')
        If ($regKey) { $keyVal2 = $regKey.GetValue('RequireSecuritySignature') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If (([string]::IsNullOrEmpty($keyVal1) -eq $false) -or ([string]::IsNullOrEmpty($keyVal2) -eq $false))
    {
        $missing = ''
        If ($keyVal1 -eq $script:appSettings['RequireSMBSigning']) { $missing  = '' } Else { $missing  = 'LanmanServer,#'    }
        If ($keyVal2 -eq $script:appSettings['RequireSMBSigning']) { $missing += '' } Else { $missing += 'LanmanWorkstation' }

        If ($missing -eq '')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'SMB Signing configured correctly'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'SMB Signing not configured correctly'
            $result.data    = 'The following sections are not configured correctly: {0}' -f $missing
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Registry setting not found'
        $result.data    = ''
    }

    Return $result
}
}

$csec13 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['ProductNames'] = ('RSA Authentication Manager', 'RSA Authentication Agent')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        If server is Domain Controller or a Terminal Server ensure RSA authentication manager is installed and PIN is required to access server.



    PASS:    {0} found
    WARNING:
    FAIL:    RSA software not found
    MANUAL:
    NA:      Not a domain controller or terminal services server

    APPLIES: Domain Controllers

    REQUIRED-FUNCTIONS: Win32_Product, Check-DomainController, Check-TerminalServer
#>

Function c-sec-13-rsa-authentication
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'RSA Monitoring Installed'
    $result.check  = 'c-sec-13-rsa-authentication'

    #... CHECK STARTS HERE ...#

    If (((Check-DomainController $serverName) -eq $true) -or ((Check-TerminalServer $serverName) -eq $true))
    {
        Try
        {
            [boolean]$found = $false
            $script:appSettings['ProductNames'] | ForEach {
                [string]$verCheck = Win32_Product -serverName $serverName -displayName $_
                If ([string]::IsNullOrEmpty($verCheck) -eq $false)
                {
                    $found            = $true
                    [string]$prodName = $_
                    [string]$prodVer  = $verCheck
                }
            }
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($found -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'RSA software found'
            $result.data    = '{0}, Version {1}' -f $prodName, $prodVer
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'RSA software not found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a domain controller or terminal services server'
    }

    Return $result
}
$script:appSettings['Win32_Product'] = 'Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
Function Win32_Product
{
    Param ( [string] $serverName, [string] $displayName )
    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey($script:appSettings['Win32_Product'])
        If ($regKey) { [array]$keyVal = $regKey.GetSubKeyNames() }
    }
    Catch { Return $null }

    $found = $false
    If (($regKey) -and ($keyVal.Count -gt 0)) {
        ForEach ($app In $keyVal) {
            $appKey = $regKey.OpenSubKey($app).GetValue('DisplayName')
            If ($appKey -like ("*$displayName*")) {
                $found = $true
                [string]$verCheck = $regKey.OpenSubKey($app).GetValue('DisplayVersion')
                If (-not $verCheck) { $verCheck = '0.1' } }
        }
        If ($found -eq $false) {
            If ($script:appSettings['Win32_Product'] -like '*Wow6432Node*') {
                $script:appSettings['Win32_Product'] = $script:appSettings['Win32_Product'].Replace('Wow6432Node', '')
                $verCheck = Win32_Product -serverName $serverName -displayName $displayName
            }
            Else { $verCheck = $null } }
    }
    Else { $verCheck = $null }
    Try { $regKey.Close() } Catch { }
    $reg.Close()
    Return $verCheck
}
Function Check-DomainController
{
    Param ( [string] $serverName )
    Try {
        $query = "SELECT DomainRole FROM Win32_ComputerSystem"
        $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object DomainRole
        If ($check.DomainRole -eq 4 -or $check.DomainRole -eq 5) { Return $true } }
    Catch { Return $false }
    Return $false
}
Function Check-TerminalServer
{
    Param ( [string] $serverName )
    Try {
        # CHECK: Terminal Server...
        If ((Check-NameSpace -serverName $serverName -namespace 'Cimv2\TerminalServices') -eq $true) {
            If ((Get-WmiObject -ComputerName $serverName -Namespace ROOT\Cimv2\TerminalServices -List 'Win32_TerminalServiceSetting').Name -eq 'Win32_TerminalServiceSetting') {
                $query = "SELECT TerminalServerMode FROM Win32_TerminalServiceSetting"
                $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2\TerminalServices -Authentication PacketPrivacy -Impersonation Impersonate | Select-Object TerminalServerMode
                If ($check.TerminalServerMode -eq 1) { Return $true }
        } } }
    Catch { Return $false }
    Return $false
}

Function Check-NameSpace
{
    Param ( [string]$serverName, [string]$namespace )
    [string]$find = $namespace;  [string]$ns = 'ROOT'
    If ($namespace -like '*\*') { [string]$find = $namespace.Split('\')[-1]; [string]$ns = 'ROOT\' + $namespace.replace('\{0}' -f $find, '') }
    [array] $wmin = Get-WmiObject -ComputerName $serverName -Namespace $ns -Class '__Namespace' | Select-Object -ExpandProperty Name
    If ($wmin -contains $find) { Return $true } Else { Return $false }
}
}

$csec14 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseFirewallAppRules'] = ('McAfee', 'macmnsvc', 'System Center', 'nbwin')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Checks to see if there are any addional firewall rules, and warns if there are any.
        This ignores all default pre-configured rules, and netbackup ports rules (1556, 13724)
        macmnsvc: McAfee Service;  nbwin: NetBackup Client

    PASS:    No additional firewall rules exist
    WARNING: One or more additional firewall rules exist, check they are required
    FAIL:
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-14-firewall-rules
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Additional Firewall Rules'
    $result.check  = 'c-sec-14-firewall-rules'

    #... CHECK STARTS HERE ...#

    Try
    {
        [array]$check  = @()
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('System\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\FirewallRules')
        If ($regKey)
        {
            ForEach ($key In $regKey.GetValueNames())
            {
                [PSObject]$HashProps = @{ Active=$null; AppPath=$null; Direction=$null; EmbedCtxt=$null; Name=$null; RemotePort=$null }
                ForEach  ($FireWallRule In ($regkey.GetValue($key) -split '\|'))
                {
                    Switch (($FireWallRule -split '=')[0])
                    {
                        'Active'    { [string]$HashProps.Active      = ($FireWallRule -split '=')[1] }
                        'App'       { [string]$HashProps.AppPath     = ($FireWallRule -split '=')[1] }
                        'Dir'       { [string]$HashProps.Direction   = ($FireWallRule -split '=')[1] }
                        'EmbedCtxt' { [string]$HashProps.EmbedCtxt   = ($FireWallRule -split '=')[1] }
                        'Name'      { [string]$HashProps.Name        = ($FireWallRule -split '=')[1] }
                        'RPort'     { [array] $HashProps.RemotePort += ($FireWallRule -split '=')[1] }
                    }
                }
                If ((($HashProps.Name       -notlike     '@*'  ) -or ($HashProps.EmbedCtxt  -notlike     '@*'   )) -and `
                    (($HashProps.RemotePort -notcontains '1556') -or ($HashProps.RemotePort -notcontains '13724'))) { $check += (New-Object -TypeName PSObject -Property $HashProps) }
            }
        }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($check) -eq $false)
    {
        [System.Collections.ArrayList]$check2 = @(); $check | ForEach { $check2 += $_ }
        $check2 = $check2 | Sort-Object Direction, Name
        If ($script:appSettings['IgnoreTheseFirewallAppRules'].Length -gt 1) {
            $check | ForEach-Object {
                ForEach ($exclude In $script:appSettings['IgnoreTheseFirewallAppRules']) {
                    If ($_.Name -match $exclude) { $check2.Remove($_) }
                }
            }
        }

        If ($check2.count -gt 0)
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'One or more additional firewall rules exist, check they are required'
            $check2 | ForEach-Object {
                If ($_.Active -eq 'False') {$act=' (Disabled)'} Else {$act=''}
                $result.data += '({0}) {1}{2},#' -f $_.Direction, $_.Name, $act }
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'No additional firewall rules exist'
        }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No additional firewall rules exist'
    }

    Return $result
}
}

$csec15 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DomainProfile'] = '0'
$script:appSettings['PublicProfile'] = '0'
$script:appSettings['StandardProfile'] = '0'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check if Windows firewall is enabled or disabled



    PASS:    Windows firewall is set correctly
    WARNING: 
    FAIL:    Windows firewall is not set correctly
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sec-15-firewall-state
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Check Firewall State'
    $result.check  = 'c-sec-15-firewall-state'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        Try { [string]$regDP = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\DomainProfile'  ).GetValue('EnableFirewall') } Catch { [string]$regDP = 'Unknown' }
        Try { [string]$regSP = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile').GetValue('EnableFirewall') } Catch { [string]$regSP = 'Unknown' }
        Try { [string]$regPP = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\PublicProfile'  ).GetValue('EnableFirewall') } Catch { [string]$regPP = 'Unknown' }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $result.data = ''
    If ($regDP -ne $global:appSettings['DomainProfile']  ) { $result.data += (  'Domain profile is {0}, but should be {1},#' -f $regDP, $global:appSettings['DomainProfile']  ) }
    If ($regSP -ne $global:appSettings['StandardProfile']) { $result.data += ('Standard profile is {0}, but should be {1},#' -f $regSP, $global:appSettings['StandardProfile']) }
    If ($regPP -ne $global:appSettings['PublicProfile']  ) { $result.data += (  'Public profile is {0}, but should be {1},#' -f $regPP, $global:appSettings['PublicProfile']  ) }

    If ($result.data -eq '')
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Windows firewall is set correctly'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Windows firewall is not set correctly'
        $result.data    = ($result.data).Replace('0', 'disabled').Replace('1', 'enabled')
    }

    Return $result
}
}

$csys01 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check for a pending reboot



    PASS:    Server is not waiting for a reboot
    WARNING:
    FAIL:    Server is waiting for a reboot
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-01-pending-reboot
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Pending Reboot'
    $result.check  = 'c-sys-01-pending-reboot'
    
    #... CHECK STARTS HERE ...#

    Try {
        $result.data = ''
        $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)

        Try {
            $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing')
            If ($regKey) { ForEach ($regVal In $regKey) { If ($regVal -contains 'RebootPending') { $result.data += 'Pending trusted installer operations,#'; Break } } }
            Try { $regKey.Close() } Catch { }
        } Catch { }

        Try {
            $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update')
            If ($regKey) { ForEach ($regVal In $regKey.GetSubKeyNames()) { If ($regVal -contains 'RebootRequired') { $result.data += 'Pending windows updates,#'; Break } } }
            Try { $regKey.Close() } Catch { }
        } Catch { }

        Try {
            $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Session Manager')
            If ($regKey.GetValue('PendingFileRenameOperations') -ne $null)
            {
                ForEach ($pfro In $regKey.GetValue('PendingFileRenameOperations'))
                { If (($pfro -ne '') -and ($pfro -notlike '*VMwareDnD*')) { $result.data += 'Pending file rename operations,#'; Break } }
            }
            Try { $regKey.Close() } Catch { }
        } Catch { }

        Try {
            $regKey1 = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName\')
            $regKey2 = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName\')
            If ($regKey1.GetValue('ComputerName') -ne $regKey2.GetValue('ComputerName')) { $result.data += 'Pending computer rename,#' }
            Try { $regKey1.Close(); $regKey2.Close() } Catch { }
        } Catch { }

        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($result.data -eq '')
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Server is not waiting for a reboot'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Server is waiting for a reboot'
    }

    Return $result
}
}

$csys02 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check windows is licensed.



    PASS:    Windows is licenced, Port 1688 open to KMS Server {0}
    WARNING:
    FAIL:    Windows is licenced, Port 1688 not open to KMS Server {0} / Windows licence check failed / Windows not licenced
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS: Test-Port
#>

Function c-sys-02-windows-license
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Windows License'
    $result.check  = 'c-sys-02-windows-license'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        If ((Get-WmiObject -ComputerName $serverName -Namespace ROOT\Cimv2 -List 'SoftwareLicensingProduct').Name -eq 'SoftwareLicensingProduct')
        {
            [string]$query1 = 'SELECT LicenseStatus FROM SoftwareLicensingProduct WHERE ApplicationID="55c92734-d682-4d71-983e-d6ec3f16059f" AND NOT LicenseStatus = "0"'
            [array] $check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty LicenseStatus
        }

        If ((Get-WmiObject -ComputerName $serverName -Namespace ROOT\Cimv2 -List 'SoftwareLicensingService').Name -eq 'SoftwareLicensingService')
        {
            [string]$query2 = "SELECT KeyManagementServiceMachine, DiscoveredKeyManagementServiceMachineName FROM SoftwareLicensingService"
            [object]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Select KeyManagementServiceMachine, DiscoveredKeyManagementServiceMachineName
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    [string]$kms    = ''
    [string]$status = ''
    If ($check1.Count -gt 0)
    {
        Switch ($check1[0])
        {
                  1 { $status = 'Licensed';                      Break }    # <-- Requried for PASS
                  2 { $status = 'Out-Of-Box Grace Period';       Break }
                  3 { $status = 'Out-Of-Tolerance Grace Period'; Break }
                  4 { $status = 'Non-Genuine Grace Period';      Break }
                  5 { $status = 'Notification';                  Break }
                  6 { $status = 'Extended Grace';                Break }
            Default { $status = 'Unknown'                              }
        }
    }
    Else
    {
        $status = 'Not Licensed'
    }    

    If ($check2.DiscoveredKeyManagementServiceMachineName -ne '') { $kms = $check2.DiscoveredKeyManagementServiceMachineName }
    If ($check2.KeyManagementServiceMachine               -ne '') { $kms = $check2.KeyManagementServiceMachine               }

    If ($kms -ne '')
    {
        [boolean]$portTest = Test-Port -serverName $kms -Port 1688
        If ($portTest -eq $true)
        {
            $result.result  = $script:lang['Pass']
            $result.data    = ('Port 1688 open to KMS Server {0}' -f $kms)
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.data    = ('Port 1688 not open to KMS Server {0}' -f $kms)
        }
    }
    Else
    {
        $result.result  = $script:lang['Warning']
        $result.data    = 'Not using a KMS server'
    }

    If ($status -eq 'Licensed')
    {
        $result.message = 'Windows is licenced'
    }
    ElseIf ($status -eq '')
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Windows licence check failed'
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Windows not licenced'
        $result.data    = ('Status: {0},#{1}' -f $status, $result.data)
    }

    Return $result
}
Function Test-Port
{
    Param ([string] $serverName, [string] $Port)
    Try
    {
        $tcp  = New-Object System.Net.Sockets.TcpClient
        $con  = $tcp.BeginConnect($serverName, $port, $null, $null)
        $wait = $con.AsyncWaitHandle.WaitOne(3000, $false)

        If (-not $wait) { $tcp.Close(); Return $false }
        Else {
            $failed = $false; $error.Clear()
            Try { $tcp.EndConnect($con) } Catch {}
            If (!$?) { $failed = $true }; $tcp.Close()
            If ($failed -eq $true) { Return $false } Else { Return $true }
        }
    }
    Catch { Return $false }
}
}

$csys03 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseServices'] = ('NetBackup Bare Metal Restore Boot Server', 'NetBackup SAN Client Fibre Transport Service', 'Microsoft .NET Framework NGEN', 'Software Protection', 'Volume Shadow Copy')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check services and ensure all services set to start automatically are running (NetBackup Bare Metal Restore Boot Server, 
        NetBackup SAN Client Fibre Transport Service and .NET4.0 are all expected to be Automatic but not running)


    PASS:    All auto-start services are running
    WARNING:
    FAIL:    An auto-start service was found not running
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-03-services-not-started
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Services Not Started'
    $result.check  = 'c-sys-03-services-not-started'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DisplayName FROM Win32_Service WHERE StartMode="Auto" AND Started="False"'
        $script:appSettings['IgnoreTheseServices'] | ForEach {  $query += ' AND NOT DisplayName LIKE "%{0}%"' -f $_ }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty DisplayName
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'An auto-start service was found not running'
        $check | ForEach { $result.data += '{0},#' -f $_ }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All auto-start services are running'
    }
    
    Return $result
}
}

$csys04 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['CheckTheseServices'] = ('HP System Management Homepage')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check services and ensure all listed services are set to disabled and are stopped



    PASS:    All services are configured correctly
    WARNING:
    FAIL:    One or more services are configured incorrectly
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-04-services-not-stopped
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Services Not Stopped'
    $result.check  = 'c-sys-04-services-not-stopped'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DisplayName, StartMode, State FROM Win32_Service WHERE DisplayName = "null"'
        $script:appSettings['CheckTheseServices'] | ForEach { $query += ' OR DisplayName = "{0}"' -f $_ }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object DisplayName, StartMode, State
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        ForEach ($service In $check)
        {
            $st = ''; $sm = ''
            If ($service.State     -ne 'Stopped' ) { $st = $service.State     }
            If ($service.StartMode -ne 'Disabled') { $sm = $service.StartMode }
            If (($st -ne '') -or ($sm -ne ''))     { $result.data += '{0} ({1}/{2}),#' -f $service.DisplayName, $sm, $st }
        }

        If ($result.data.Length -gt 1)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more services are configured incorrectly'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All services are configured correctly'
        }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'All services are configured correctly'
    }
    
    Return $result
}
}

$csys05 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['GetLatestEntriesAge'] = '14'
$script:appSettings['GetLatestEntriesCount'] = '15'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check System Event Log and ensure no errors or warnings are present in the last 14 days.  If found, will return the latest 15 entries



    PASS:    No errors found in system event log
    WARNING: Errors were found in the system event log
    FAIL:
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-05-system-event-log
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'System Event Log Errors'
    $result.check  = 'c-sys-05-system-event-log'

    #... CHECK STARTS HERE ...#

    Try
    {
        If ($PSVersionTable.PSVersion.Major -ge 4)
        {
            [double]$timeOffSet = ($script:appSettings['GetLatestEntriesAge'] -as [int]) * 60 * 60 * 24 * 1000    # Convert 'days' into 'miliseconds'
            [xml]   $xml        = '<QueryList><Query Id="0" Path="System"     ><Select Path="System"     >*[System[(Level=1 or Level=2) and TimeCreated[timediff(@SystemTime) &lt;= {0}]]]</Select></Query></QueryList>' -f $timeOffSet
            [object]$check      = Get-WinEvent -ComputerName $serverName -MaxEvents $script:appSettings['GetLatestEntriesCount'] -FilterXml $xml -ErrorAction SilentlyContinue | Select LevelDisplayName, TimeCreated, Id, ProviderName, Message
        }
        Else
        {
            $check = Get-EventLog -ComputerName $serverName -LogName System      -EntryType Error -Newest $script:appSettings['GetLatestEntriesCount'] -After (Get-Date).AddDays(-($script:appSettings['GetLatestEntriesAge'])) -ErrorAction SilentlyContinue
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Length -gt 0)
    {
        If ((Test-Path -Path ('{0}EventLogs' -f $resultPath)) -eq $false) { Try { New-Item -Path ('{0}EventLogs' -f $resultPath) -ItemType Directory -Force | Out-Null } Catch {} }
        [string]$outFile = '{0}EventLogs\{1}-Error-Events-System.csv' -f $resultPath, $serverName.ToUpper()
        $check | Export-Csv $outFile -NoTypeInformation

        $result.result  = $script:lang['Warning']
        $result.message = 'Errors were found in the system event log'
        $result.data    = (Split-Path -Path $outFile -Leaf)
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No errors found in system event log'
    }
    
    Return $result
}
}

$csys06 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['GetLatestEntriesAge'] = '14'
$script:appSettings['GetLatestEntriesCount'] = '15'
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check Application Event Log and ensure no errors or warnings are present in the last 14 days.  If found, will return the latest 15 entries



    PASS:    No errors found in application event log
    WARNING: Errors were found in the application event log
    FAIL:
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-06-application-event-log
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Application Event Log Errors'
    $result.check  = 'c-sys-06-application-event-log'

    #... CHECK STARTS HERE ...#

    Try
    {
        If ($PSVersionTable.PSVersion.Major -ge 4)
        {
            [double]$timeOffSet = ($script:appSettings['GetLatestEntriesAge'] -as [int]) * 60 * 60 * 24 * 1000    # Convert 'days' into 'miliseconds'
            [xml]   $xml        = '<QueryList><Query Id="0" Path="Application"><Select Path="Application">*[System[(Level=1 or Level=2) and TimeCreated[timediff(@SystemTime) &lt;= {0}]]]</Select></Query></QueryList>' -f $timeOffSet
            [object]$check      = Get-WinEvent -ComputerName $serverName -MaxEvents $script:appSettings['GetLatestEntriesCount'] -FilterXml $xml -ErrorAction SilentlyContinue | Select LevelDisplayName, TimeCreated, Id, ProviderName, Message
        }
        Else
        {
            $check = Get-EventLog -ComputerName $serverName -LogName Application -EntryType Error -Newest $script:appSettings['GetLatestEntriesCount'] -After (Get-Date).AddDays(-($script:appSettings['GetLatestEntriesAge'])) -ErrorAction SilentlyContinue
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Length -gt 0)
    {
        If ((Test-Path -Path ('{0}EventLogs' -f $resultPath)) -eq $false) { Try { New-Item -Path ('{0}EventLogs' -f $resultPath) -ItemType Directory -Force | Out-Null } Catch {} }
        [string]$outFile = '{0}EventLogs\{1}-Error-Events-Application.csv' -f $resultPath, $serverName.ToUpper()
        $check | Export-Csv $outFile -NoTypeInformation

        $result.result  = $script:lang['Warning']
        $result.message = 'Errors were found in the application event log'
        $result.data    = (Split-Path -Path $outFile -Leaf)
    }
    Else
    {
        $result.result  = $script:lang['Pass']        
        $result.message = 'No errors found in application event log'
    }
    
    Return $result
}
}

$csys07 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseDeviceNames'] = ('abc', 'xyz')    # Examples Only
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Checks Device Manager to ensure there are no unknown devices, conflicts or errors.
        


    PASS:    No device errors found
    WARNING:
    FAIL:    Device errors found
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-07-devices-status
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Device Errors'
    $result.check  = 'c-sys-07-devices-status'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        # Excludes Working (0) and Disabled (22)
        [string]$query = 'SELECT Name, ConfigManagerErrorCode FROM Win32_PnPEntity WHERE NOT ConfigManagerErrorCode = 0 AND NOT ConfigManagerErrorCode = 22'
        $script:appSettings['IgnoreTheseDeviceNames'] | ForEach { $query += ' AND NOT Name = "{0}"' -f $_ }
        [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.Count -gt 0)
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Device errors found'
        $check | ForEach { $result.data += '{0},#' -f $_ }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No device errors found'
    }
    
    Return $result
}
}

$csys09 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreTheseScheduledTasks'] = ('SQM data sender', 'SystemSoundsService', 'StartComponentCleanup', 'Automatic-Workplace-Join', 'ReplaceOMCert', 'Optimize Start Menu Cache Files')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check to see if any non standard scheduled tasks exist on  the server (Any application specific scheduled tasks 
        should be documented with a designated contact point specified).  Skips any Microsoft specific tasks
   
   
    PASS:    No additional scheduled tasks found
    WARNING: Additional scheduled tasks found - make sure these are documented
    FAIL:
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-09-scheduled-tasks
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Scheduled Tasks'
    $result.check  = 'c-sys-09-scheduled-tasks'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT Caption FROM Win32_OperatingSystem'
        [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Caption

        If ($check -notlike '*2003*')
        {
            $schedule = New-Object -ComObject('Schedule.Service')
            $schedule.Connect($serverName) 
            $tasks = Get-Tasks($schedule.GetFolder('\'))
        }
        Else
        {
            # Windows 2003 Servers
            $result.result  = $script:lang['Warning']
            $result.message = 'Operating system not supported by check'
            $result.data    = ''
            Return $result
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    $tasksOut = ''
    $tasks | ForEach {
        [xml]   $xml    = $_.Xml
        [string]$author = $xml.Task.RegistrationInfo.Author
        If (($Author -notlike '*Microsoft*') -and ($Author -notlike '*SystemRoot*'))
        {
            If ($script:appSettings['IgnoreTheseScheduledTasks'] -notcontains $_.Name) { [string]$tasksOut += '{0} ({1}),#' -f $_.Name, $author }
        }
    }

    If ($tasksOut -eq '')
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No additional scheduled tasks found'
    }
    Else
    {
        $result.result  = $script:lang['Warning']
        $result.message = 'Additional scheduled tasks found - make sure these are documented'
        $result.data    = $tasksOut
    }
        
    Return $result
}

# Checks all task subfolders, not just root...
Function Get-Tasks
{
    Param ( [Object]$taskFolder )
    $tasks = $taskFolder.GetTasks(0)
    $tasks | ForEach-Object { $_ }
    Try {
        $taskFolders = $taskFolder.GetFolders(0)
        $taskFolders | ForEach-Object { Get-Tasks $_ $true } }
    Catch { }
}
}

$csys10 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['IgnoreThesePrinterNames'] = ('Send To OneNote', 'PDFCreator', 'Microsoft XPS Document Writer', 'Fax', 'WebEx Document Loader', 'Microsoft Print To PDF')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check to see if any printers exist on the server. If printers exist, ensure the spooler directory is not stored on the system drive.

        

    PASS:    Printers found, and spool directory is not set to default path
    WARNING:
    FAIL:    Spool directory is set to the default path and needs to be changed, Registry setting not found
    MANUAL:
    NA:      No printers found / Print Spooler service is not running

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-10-print-spooler
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Print Spool Directory'
    $result.check  = 'c-sys-10-print-spooler'

    #... CHECK STARTS HERE ...#

    Try
    {
        $svc = Get-Service -DisplayName 'Print Spooler' | Select-Object -ExpandProperty Status
        If ($svc -eq 'Running')
        {
            [string]$query = 'SELECT Name FROM Win32_Printer WHERE NOT Name="null"'
            $script:appSettings['IgnoreThesePrinterNames'] | ForEach { $query += ' AND NOT Name="{0}"' -f $_ }
            [array]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Name
        }
        Else
        {
            [array]$check = 'STOPPED'
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check -eq 'STOPPED')
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Print Spooler service is not running'
    }
    ElseIf (($check -ne $null) -and ($check.Count -gt 0))
    {
        $check | ForEach { $result.data += '{0},#' -f $_ }        

        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Control\Print\Printers')
        If ($regKey) { $keyVal = $regKey.GetValue('DefaultSpoolDirectory') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()

        If ([string]::IsNullOrEmpty($keyVal) -eq $false)
        {
            If ($keyVal -eq $("$env:SystemDrive\Windows\system32\spool\PRINTERS"))
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Spool directory is set to the default path and needs to be changed'
                $result.data    = 'Location: {0},#{1}' -f $keyVal, $result.data
            }
            Else 
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'Printers found, and spool directory is not set to default path'
                $result.data    = 'Location: {0},#{1}' -f $keyVal, $result.data
            }
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Registry setting not found'
            $result.data    = ''
        }
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'No printers found'
    }

    Return $result
}
}

$csys11 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Ensure autorun is disabled.



    PASS:    Autorun is disabled
    WARNING:
    FAIL:    Autorun is enabled
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-11-autorun-disabled
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Drive Autorun'
    $result.check  = 'c-sys-11-autorun-disabled'

    #... CHECK STARTS HERE ...#

    Try
    {
        $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
        $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer')
        If ($regKey) { $keyVal = $regKey.GetValue('NoDriveTypeAutoRun') }
        Try { $regKey.Close() } Catch { }
        $reg.Close()
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }
 
    If ([string]::IsNullOrEmpty($keyVal) -eq $false)
    {
        If ($keyVal -eq '255')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Autorun is disabled'
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Autorun is enabled'
        }
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Autorun is enabled'
    }

    Return $result
}
}

$csys12 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check if SNMP role is install on the server.  If so, ensure the SNMP community strings follow the secure password policy.



    PASS:    SNMP Service installed, but disabled
    WARNING:
    FAIL:    SNMP Service installed, no communities configured
    MANUAL:  SNMP Service installed, communities listed
    NA:      SNMP Service not installed

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-12-snmp-configuration
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'SNMP Configuration'
    $result.check  = 'c-sys-12-snmp-configuration'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query = 'SELECT DisplayName, StartMode FROM Win32_Service WHERE DisplayName="SNMP Service"'
        [object]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object DisplayName, StartMode
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ([string]::IsNullOrEmpty($check) -eq $false)
    {
        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\services\SNMP\Parameters\ValidCommunities')
            If ($regKey) { [array]$keyVal = $regKey.GetValueNames() }
            Try { $regKey.Close() } Catch { }
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If (($regKey) -and ($keyVal.Count -gt 0))
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'SNMP Service installed, communities listed'

            ForEach ($key In $keyVal)
            {
                $keyVal_ = $regKey.GetValue($key)
                If ($keyVal_ -eq '4') { $result.data += $key + ' (readonly),#'  }
                If ($keyVal_ -eq '8') { $result.data += $key + ' (readwrite),#' }
            }
        }
        Else
        {
            If ($check.StartMode -eq 'Disabled')
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'SNMP Service installed, but disabled'
            }
            Else
            {
                $result.result  = $script:lang['Warning']
                $result.message = 'SNMP Service installed, no communities configured'
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'SNMP Service not installed'
    }

    Return $result
}
}

$csys13 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Checks that the currently logged on user is a member of the domain
        and not a local user account


    PASS:    Currently logged on with domain user account
    WARNING: This is a workgroup server, is this correct.?
    FAIL:    Not currently logged on with current domain user account
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-13-domain-user-logon
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Domain User Logon'
    $result.check  = 'c-sys-13-domain-user-logon'

    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$usrdom = ([System.Security.Principal.WindowsIdentity]::GetCurrent().Name -split '\\')[0]  # <-- More secure than enviroment variable
        [string]$query  = "SELECT PartOfDomain, Domain FROM Win32_ComputerSystem"
        [object]$check  = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object PartOfDomain, Domain
        [string]$domain = ($check.Domain -split '\.')[0]
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check.PartOfDomain -eq $true)
    {
        If ($usrdom -eq $domain)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Currently logged on with domain user account'
            $result.data    = $check.Domain
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Not currently logged on with current domain user account'
            $result.data    = 'User: {0}, Server: {1}' -f $usrdom, $check.Domain
        }
    }
    Else
    {
        $result.result  = $script:lang['Warning']
        $result.message = 'This is a workgroup server, is this correct.?'
        $result.data    = 'Workgroup: {0}' -f $domain
    }

    Return $result
}
}

$csys14 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check power plan is set to High Performance.
        


    PASS:    Power plan is set correctly
    WARNING:
    FAIL:    Power plan is not set correctly
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS: Check-NameSpace
#>

Function c-sys-14-power-plan
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Power Plan'
    $result.check  = 'c-sys-14-power-plan'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        If ((Check-NameSpace -serverName $serverName -namespace 'Cimv2\Power') -eq $true)
        {
            [string]$query = 'SELECT ElementName FROM Win32_PowerPlan WHERE IsActive="True"'
            [string]$check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2\Power -Authentication PacketPrivacy -Impersonation Impersonate | Select-Object -ExpandProperty ElementName
        }
        If ($check -eq '') { $check = '(Unknown)' }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check -eq 'High Performance')
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Power plan is set correctly'
        $result.data    = $check
    }
    Else
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Power plan is not set correctly'
        $result.data    = $check
    }

    Return $result
}
Function Check-NameSpace
{
    Param ( [string]$serverName, [string]$namespace )
    [string]$find = $namespace;  [string]$ns = 'ROOT'
    If ($namespace -like '*\*') { [string]$find = $namespace.Split('\')[-1]; [string]$ns = 'ROOT\' + $namespace.replace('\{0}' -f $find, '') }
    [array] $wmin = Get-WmiObject -ComputerName $serverName -Namespace $ns -Class '__Namespace' | Select-Object -ExpandProperty Name
    If ($wmin -contains $find) { Return $true } Else { Return $false }
}
}

$csys15 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check hibernation is turned off



    PASS:    Hibernation is currently disabled
    WARNING:
    FAIL:    Hibernation is currently enabled
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS:
#>

Function c-sys-15-hibernation
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Hibernation'
    $result.check  = 'c-sys-15-hibernation'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        [string]$query1 = 'SELECT SystemDrive FROM Win32_OperatingSystem'
        [string]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty SystemDrive
        If ([string]::IsNullOrEmpty($check1) -eq $false)
        {
            # Dev Note: Do not change " to ', it will break this check
            [string]$query2 = "Associators of {Win32_Directory.Name='" + $check1 + "\'} WHERE ResultClass=CIM_DataFile"
            [string]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2 | Where-Object {$_.name -match 'hiberfil.sys'} | Select-Object -ExpandProperty Name
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If ($check2 -like '*hiberfil.sys')
    {
        $result.result  = $script:lang['Fail']
        $result.message = 'Hibernation is currently enabled'
        $result.data    = $check2
    }
    Else
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Hibernation is currently disabled'
        $result.data    = $check2
    }

    Return $result
}
}

$csys16 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check that remote desktop is enabled and that Network Level Authentication (NLA) is set



    PASS:    Secure remote desktop and NLA enabled
    WARNING: Network Level Authentication is not set
    FAIL:    Secure remote desktop disabled
    MANUAL:
    NA:

    APPLIES: All

    REQUIRED-FUNCTIONS: Check-NameSpace
#>

Function c-sys-16-remote-desktop
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Remote Desktop'
    $result.check  = 'c-sys-16-remote-desktop'
    
    #... CHECK STARTS HERE ...#

    Try
    {
        If ((Check-NameSpace -serverName $serverName -namespace 'Cimv2\TerminalServices') -eq $true)
        {
            [string]$query1 = 'Select AllowTSConnections FROM Win32_TerminalServiceSetting'
            [string]$check1 = Get-WmiObject -ComputerName $serverName -Query $query1 -Namespace ROOT\Cimv2\TerminalServices -Authentication PacketPrivacy -Impersonation Impersonate | Select-Object -ExpandProperty AllowTSConnections

            [string]$query2 = 'Select UserAuthenticationRequired FROM Win32_TSGeneralSetting'
            [string]$check2 = Get-WmiObject -ComputerName $serverName -Query $query2 -Namespace ROOT\Cimv2\TerminalServices -Authentication PacketPrivacy -Impersonation Impersonate | Select-Object -ExpandProperty UserAuthenticationRequired
        }
    }
    Catch
    {
        $result.result  = $script:lang['Error']
        $result.message = $script:lang['Script-Error']
        $result.data    = $_.Exception.Message
        Return $result
    }

    If (($check1 -eq '1') -and ($check2 -eq '1'))
    {
        $result.result  = $script:lang['Pass']
        $result.message = 'Secure remote desktop enabled'
    }
    Else
    {
        If ($check1 -eq '0')
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Secure remote desktop disabled'
        }
        Else
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'Secure remote desktop enabled'
            $result.data    = 'Network Level Authentication is not set'
        }
    }

    Return $result
}
Function Check-NameSpace
{
    Param ( [string]$serverName, [string]$namespace )
    [string]$find = $namespace;  [string]$ns = 'ROOT'
    If ($namespace -like '*\*') { [string]$find = $namespace.Split('\')[-1]; [string]$ns = 'ROOT\' + $namespace.replace('\{0}' -f $find, '') }
    [array] $wmin = Get-WmiObject -ComputerName $serverName -Namespace $ns -Class '__Namespace' | Select-Object -ExpandProperty Name
    If ($wmin -contains $find) { Return $true } Else { Return $false }
}
}

$csys17 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        If server is a Terminal Services Server ensure it has a licence server set.



    PASS:    Terminal services server is licenced
    WARNING:
    FAIL:    Terminal services server is not licenced
    MANUAL:
    NA:      Not a terminal services server

    APPLIES: All

    REQUIRED-FUNCTIONS: Check-TerminalServer
#>

Function c-sys-17-terminal-services-licenced
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Terminal Services Licenced'
    $result.check  = 'c-sys-17-terminal-services-licenced'

    #... CHECK STARTS HERE ...#

    If ((Check-TerminalServer $serverName) -eq $true)
    {
        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('SYSTEM\CurrentControlSet\Services\TermService\Parameters\LicenseServers')
            If ($regKey) { $keyVal = $regKey.GetValue('SpecifiedLicenseServers') }
            Try { $regKey.Close() } Catch { }
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ([string]::IsNullOrEmpty($keyVal) -eq $false)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Terminal services server is licenced'
            $result.data    = '' + $keyVal
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'Terminal services server is not licenced'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a terminal services server'
    }

    Return $result
}
Function Check-TerminalServer
{
    Param ( [string] $serverName )
    Try {
        # CHECK: Terminal Server...
        If ((Check-NameSpace -serverName $serverName -namespace 'Cimv2\TerminalServices') -eq $true) {
            If ((Get-WmiObject -ComputerName $serverName -Namespace ROOT\Cimv2\TerminalServices -List 'Win32_TerminalServiceSetting').Name -eq 'Win32_TerminalServiceSetting') {
                $query = "SELECT TerminalServerMode FROM Win32_TerminalServiceSetting"
                $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2\TerminalServices -Authentication PacketPrivacy -Impersonation Impersonate | Select-Object TerminalServerMode
                If ($check.TerminalServerMode -eq 1) { Return $true }
        } } }
    Catch { Return $false }
    Return $false
}

Function Check-NameSpace
{
    Param ( [string]$serverName, [string]$namespace )
    [string]$find = $namespace;  [string]$ns = 'ROOT'
    If ($namespace -like '*\*') { [string]$find = $namespace.Split('\')[-1]; [string]$ns = 'ROOT\' + $namespace.replace('\{0}' -f $find, '') }
    [array] $wmin = Get-WmiObject -ComputerName $serverName -Namespace $ns -Class '__Namespace' | Select-Object -ExpandProperty Name
    If ($wmin -contains $find) { Return $true } Else { Return $false }
}
}

$cvhv01 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check that the latest HyperV integration services are installed



    PASS:    
    WARNING:
    FAIL:    Integration services not installed
    MANUAL:  Integration services found
    NA:      Not a virtual machine

    APPLIES: Virtuals

    REQUIRED-FUNCTIONS: Check-HyperV
#>

Function c-vhv-01-tools-version
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'HyperV Tools Version'
    $result.check  = 'c-vhv-01-tools-version'

    #... CHECK STARTS HERE ...#

    If ((Check-HyperV $serverName) -eq $true)
    {
        Try
        {
            $reg    = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $serverName)
            $regKey = $reg.OpenSubKey('SOFTWARE\Microsoft\Virtual Machine\Auto')
            If ($regKey) { [string]$keyVal = $regKey.GetValue('IntegrationServicesVersion') }
            Try { $regKey.Close() } Catch { }
            $reg.Close()
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ([string]::IsNullOrEmpty($keyVal) -eq $false)
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Integration services found'
            $result.data    = ('Version: {0}' -f $keyVal)
        }
        Else
        {
            $result.result  = $script:lang['fail']
            $result.message = 'Integration services not installed'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-HyperV
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BaseBoard -Namespace ROOT\Cimv2 | Select-Object Product
    If ($wmiBIOS.Product -eq 'Virtual Machine') { Return $true } Else { Return $false }
}

}

$cvmw01 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check that the latest vmware tools are installed



    PASS:    VMware tools are up to date
    WARNING:
    FAIL:    VMware tools can be upgraded
    MANUAL:  Unable to check the VMware Tools upgrade status
    NA:      Not a virtual machine

    APPLIES: Virtuals

    REQUIRED-FUNCTIONS: Check-VMware
#>

Function c-vmw-01-tools-version
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'VMware Tools Version'
    $result.check  = 'c-vmw-01-tools-version'

    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$versi = ''
            [string]$check = ''
            If ($serverName -eq $env:ComputerName) {
                $versi = Invoke-Command                           -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" -v   } -ErrorAction SilentlyContinue
                $check = Invoke-Command                           -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" help } -ErrorAction SilentlyContinue }
            Else {
                $versi = Invoke-Command -ComputerName $serverName -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" -v   } -ErrorAction SilentlyContinue
                $check = Invoke-Command -ComputerName $serverName -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" help } -ErrorAction SilentlyContinue }

            If ($check -like '*upgrade*')
            {
                If ($serverName -eq $env:ComputerName)
                {      $check = Invoke-Command                           -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" upgrade status } -ErrorAction SilentlyContinue }
                Else { $check = Invoke-Command -ComputerName $serverName -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" upgrade status } -ErrorAction SilentlyContinue }
            }
        }
        Catch { }

        If ($check -like 'VMware Tools are up-to-date*')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'VMware tools are up to date'
            $result.data    = 'Current Version: {0}' -f $versi
        }
        ElseIf ($check -like 'A new version of VMware Tools is available*')
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'VMware tools can be upgraded'
            $result.data    = 'Current Version: {0}' -f $versi
        }
        ElseIf ($check.StartsWith('Usage:') -eq $true)    # 'UPGRADE' option not available
        {                                                 # Older versions and some OSes.
            $result.result  = $script:lang['Manual']
            $result.message = 'Unable to check the VMware Tools upgrade status'
            $result.data    = 'Current version: {0}.  Open vSphere client, locate "{1}", check to see if the VMware tools can be upgraded, and do so if needed' -f $versi, $serverName
        }
        Else
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Unable to check the VMware Tools version or upgrade status'
            $result.data    = 'Open vSphere client, locate "{0}", check to see if the VMware tools can be upgraded, and do so if needed' -f $serverName
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$cvmw02 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check that VMware Host Time Sync is disabled



    PASS:    VMware tools time sync is disabled
    WARNING:
    FAIL:    VMware tools time sync is enabled
    MANUAL:  Unable to check the VMware time sync status
    NA:      Not a virtual machine

    APPLIES: Virtuals

    REQUIRED-FUNCTIONS: Check-VMware
#>

Function c-vmw-02-time-sync
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'VMware Time Sync'
    $result.check  = 'c-vmw-02-time-sync'

    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$check = ''

            If ($serverName -eq $env:ComputerName) {
                $check = Invoke-Command                           -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" timesync status } -ErrorAction SilentlyContinue
            }
            Else {
                $check = Invoke-Command -ComputerName $serverName -ScriptBlock { &"$env:ProgramFiles\VMware\VMware Tools\VMwareToolBoxCmd.exe" timesync status } -ErrorAction SilentlyContinue
            }
        }
        Catch { }

        If ($check -eq 'Disabled')
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'VMware tools time sync is disabled'
        }
        ElseIf ($check -eq 'Enabled')
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'VMware tools time sync is enabled'
        }
        Else
        {
            $result.result  = $script:lang['Manual']
            $result.message = 'Unable to check the VMware time sync status'
            $result.data    = 'Open vSphere client, locatate "{0}", select Edit Settings, Options tab, Select VMware Tools, make sure "Synchronize guest time with host" is not enabled' -f $serverName
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$cvmw03 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check all virtual servers have network cards that are configured as VMXNET3



    PASS:    All active NICS configured correctly
    WARNING: No network adapters found
    FAIL:    One or more active NICs were found not to be VMXNET3
    MANUAL:
    NA:      Not a virtual machine

    APPLIES: Virtuals

    REQUIRED-FUNCTIONS: Check-VMware
#>

Function c-vmw-03-nic-type
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'VMware NIC Type'
    $result.check  = 'c-vmw-03-nic-type'
    
    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$query = 'SELECT Description FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled = "True"'
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Description
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ([string]::IsNullOrEmpty($check) -eq $true)
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'No network adapters found'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'All active NICS configured correctly'
            $check | ForEach { If ($_ -notlike ('*VMXNET3*')) { $result.data += '{0},#' -f $_ } }
        
            If ([string]::IsNullOrEmpty($result.data) -eq $false)
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'One or more active NICs were found not to be VMXNET3'
            }
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$cvmw04 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:appSettings['DiskControllerDeviceType'] = 'LSI_SAS'
$script:appSettings['IgnoreTheseControllerTypes'] = ('spaceport', 'vhdmp')
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Check Windows disk controller is set correctly.
        Default setting is "LSI logic SAS"


    PASS:    Disk controller set correctly
    WARNING:
    FAIL:    No SCSI controllers found / Disk controller not set correctly
    MANUAL:
    NA:      Not a virtual machine

    APPLIES: Virtuals

    REQUIRED-FUNCTIONS: Check-VMware
#>

Function c-vmw-04-lsi-sas-controller
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'VMware Disk Controller'
    $result.check  = 'c-vmw-04-lsi-sas-controller'

    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$query = 'SELECT DriverName, Name FROM Win32_SCSIController WHERE NOT DriverName = ""'
            $script:appSettings['IgnoreTheseControllerTypes'] | ForEach { $query += ' AND NOT DriverName LIKE "%{0}%"' -f $_ }
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty DriverName 
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check.Count -gt 0)
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'Disk controller set correctly'

            $check | ForEach { If ($_ -ne $script:appSettings['DiskControllerDeviceType']) { $result.data += '{0},#' -f $_ } }
            If ([string]::IsNullOrEmpty($result.data) -eq $false)
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'Disk controller not set correctly'
            }
        }
        Else
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'No SCSI controllers found'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$cvmw05 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Checks to see if there are are more than 8 drives attached
        to the same SCSI adapter.
        

    PASS:    More than 7 drives exist, but on different SCSI adapters
    WARNING:
    FAIL:    More than 7 drives exist on one SCSI adapter
    MANUAL:
    NA:      Not a virtual machine / There are less than 8 drives attached to server

    APPLIES: Virtuals

    REQUIRED-FUNCTIONS: Check-VMware
#>

Function c-vmw-05-scsi-drive-count
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'VMware SCSI Drive Count'
    $result.check  = 'c-vmw-05-scsi-drive-count'

    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$query = "SELECT SCSIPort, SCSITargetID FROM Win32_DiskDrive"
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object SCSIPort, SCSITargetID
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        If ($check.Count -gt 7)
        {
            [boolean]$found = $false
            [array]$group = $check | Group-Object -Property SCSIPort -NoElement | Sort-Object SCSIPort
            $group | ForEach { $result.data += 'Adapter: {0}: Drive count: {1},#' -f $_.Name, $_.Count; If ($_.Count -gt 7) { $found = $true } }

            If ($found -eq $true)
            {
                $result.result  = $script:lang['Fail']
                $result.message = 'More than 7 drives exist on one SCSI adapter'
            }
            Else
            {
                $result.result  = $script:lang['Pass']
                $result.message = 'More than 7 drives exist, but on different SCSI adapters'
            }
        }
        Else
        {
            $result.result  = $script:lang['Not-Applicable']
            $result.message = 'There are less than 8 drives attached to server'
            $result.data    = 'Count: ' + $check.Count
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$cvmw06 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Checks to see if the total VM size is less than 1tb

        

    PASS:    VM is smaller than 1TB
    WARNING: VM is larger than 1TB.  Make sure there is an engineering exception in place for this
    FAIL:
    MANUAL:
    NA:      Not a virtual machine

    APPLIES: Virtuals

    REQUIRED-FUNCTIONS: Check-VMware
#>

Function c-vmw-06-total-vm-size
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Total VM Size'
    $result.check  = 'c-vmw-06-total-vm-size'

    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$query = "SELECT Size FROM Win32_LogicalDisk WHERE DriveType = '3'"
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object -ExpandProperty Size
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        [int]$size = 0
        $check | ForEach { $size += ($_ / 1GB) }
        If ($size -gt '1023')
        {
            $result.result  = $script:lang['Warning']
            $result.message = 'VM is larger than 1TB.  Make sure there is an engineering exception in place for this'
            $result.data    = $size.ToString() + ' GB'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'VM is smaller than 1TB'
            $result.data    = $size.ToString() + ' GB'
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

$cvmw07 = {
Function newResult { Return ( New-Object -TypeName PSObject -Property @{'server'=''; 'name'=''; 'check'=''; 'datetime'=(Get-Date -Format 'yyyy-MM-dd HH:mm'); 'result'='Unknown'; 'message'=''; 'data'='';} ) }
$script:lang        = @{}
$script:appSettings = @{}
$script:lang['Error'] = 'Error'
$script:lang['Fail'] = 'Fail'
$script:lang['Manual'] = 'Manual'
$script:lang['Not-Applicable'] = 'N/A'
$script:lang['Pass'] = 'Pass'
$script:lang['Script-Error'] = 'SCRIPT ERROR'
$script:lang['Warning'] = 'Warning'
<#
    DESCRIPTION: 
        Checks for any mounted CD/DVD or floppy drives



    PASS:    No CD/ROM or floppy drives are mounted
    WARNING:
    FAIL:    One or more CD/ROM or floppy drives are mounted
    MANUAL:
    NA:      Not a virtual machine

    APPLIES: Virtuals

    REQUIRED-FUNCTIONS: Check-VMware
#>

Function c-vmw-07-cd-dvd-floppy-mounted
{
    Param ( [string]$serverName, [string]$resultPath )

    $serverName    = $serverName.Replace('[0]', '')
    $resultPath    = $resultPath.Replace('[0]', '')
    $result        = newResult
    $result.server = $serverName
    $result.name   = 'Mounted drives'
    $result.check  = 'c-vmw-07-cd-dvd-floppy-mounted'
 
    #... CHECK STARTS HERE ...#

    If ((Check-VMware $serverName) -eq $true)
    {
        Try
        {
            [string]$query = "SELECT Name, VolumeName, Size FROM Win32_LogicalDisk WHERE DriveType='2' OR DriveType='5'"    # Filter on DriveType=2/5 (Removable and CD/DVD)
            [array] $check = Get-WmiObject -ComputerName $serverName -Query $query -Namespace ROOT\Cimv2 | Select-Object Name, VolumeName, Size
        }
        Catch
        {
            $result.result  = $script:lang['Error']
            $result.message = $script:lang['Script-Error']
            $result.data    = $_.Exception.Message
            Return $result
        }

        $check | ForEach { If ($_.size -ne $null) { $result.data += '{0} ({1}),#' -f $_.Name, $_.VolumeName } }

        If ([string]::IsNullOrEmpty($result.data) -eq $false)
        {
            $result.result  = $script:lang['Fail']
            $result.message = 'One or more CD/ROM or floppy drives are mounted'
        }
        Else
        {
            $result.result  = $script:lang['Pass']
            $result.message = 'No CD/ROM or floppy drives are mounted'
            $result.data    = ''
        }
    }
    Else
    {
        $result.result  = $script:lang['Not-Applicable']
        $result.message = 'Not a virtual machine'
    }

    Return $result
}
Function Check-VMware
{
    Param ( [string] $serverName )
    $wmiBIOS = Get-WmiObject -ComputerName $serverName -Class Win32_BIOS -Namespace ROOT\Cimv2 | Select-Object SerialNumber
    If ($wmiBIOS.SerialNumber -like '*VMware*') { Return $true } Else { Return $false }        
}
}

##############################################################################################################################################################################################
$script:qahelp['acc01']='<xml><description>Check all local users to ensure that no non-standard accounts exist.Unless the server is not in a domain, there should be no additional user accounts. Example standard accounts include "ASPNET", "__VMware"</description><pass>No additional local accounts exist</pass><fail>One or more local accounts exist</fail><applies>All</applies></xml>'
$script:qahelp['acc02']='<xml><description>Checks to see if the local default accounts have been renamed. The "Administrator" and "Guest" accounts should be.</description><pass>All local accounts have been renamed</pass><fail>A local account was found that needs to be renamed</fail><applies>All</applies></xml>'
$script:qahelp['acc03']='<xml><description>Check the local administrators group to ensure no non-standard accounts exist.If there is a specific application requirement for local administration access then these need to be well documented.</description><pass>No local administrators found</pass><warning>This is a workgroup server, is this correct.?</warning><fail>One or more local administrator accounts exist</fail><applies>All</applies></xml>'
$script:qahelp['acc04']='<xml><description>Check all local groups and ensure no additional groups exist. If there is a specific application requirement for local groups then these need to be documented with a designated team specified as the owner. If you use specific role groups, make sure they are excluded in the settings file.</description><pass>No additional local accounts</pass><fail>One or more local groups exist</fail><na>Server is a domain controller</na><applies>All</applies></xml>'
$script:qahelp['acc05']='<xml><description>Checks all services to ensure no user accounts are assigned. If specific application service accounts are required then they should be domainlevel accounts (not local) and restricted from interactice access by policy.</description><pass>No services found running under a local accounts</pass><fail>One or more services was found to be running under local accounts</fail><applies>All</applies></xml>'
$script:qahelp['acc06']='<xml><description>Checks to make sure that the guest user account has been disabled. The guest account is located via the well known SID.</description><pass>Guest account is disabled</pass><fail>Guest account has not been disabled</fail><na>Guest account does not exist</na><applies>All</applies></xml>'
$script:qahelp['com01']='<xml><description>Check McAfee anti virus is installed and updating automatically. Also checks that virus definitions are up to date.</description><pass>McAfee product found, DATs are</pass><fail>McAfee product not found, install required / DATs are not up-to-date / No DAT version found</fail><applies>All</applies></xml>'
$script:qahelp['com02']='<xml><description>Check relevant monitoring tool agent is installed and that the correct port is open to the management server</description><pass>{0} found, Port {1} open to {2}</pass><fail>Monitoring software not found, install required / {0} found, Agent not configured with port and/or servername / {0} found, Port {1} not open to {2}</fail><applies>All</applies></xml>'
$script:qahelp['com03']='<xml><description>Check relevant SCCM agent is installed, and that the correct port is open to the management server</description><pass>SCCM agent found, Port {0} open to {1}</pass><fail>SCCM agent not found, install required / SCCM agent found, Agent not configured with port and/or servername / SCCM agent found, Port {0} not open to {1}</fail><applies>All</applies></xml>'
$script:qahelp['com04']='<xml><description>Check NetBackup agent is installed</description><pass>{0} found, Port 1556 open to {1}</pass><fail>{0} not found / Port 1556 not open to {0} / Backup agent software not found, but this server has {0} installed which requires it / Backup agent software not found, but this server is a domain controller which requires it</fail><manual>Is this server backed up via VADP.?Manually check vCenter annotations, and look for "NetBackup.</manual><applies>All</applies></xml>'
$script:qahelp['com05']='<xml><description>Check server is compliant with patch policy (must be patched to latest released patch level for this customer) Check date of last patch and FAIL if not within 35 days</description><pass>Windows patches applied</pass><warning>Server not patched within the last {0} days / Operating system not supported by check</warning><fail>Server not patched within the last {0} days / No last patch date - server has never been updated</fail><applies>All</applies></xml>'
$script:qahelp['com06']='<xml><description>Check that a WSUS server has been specified</description><pass>WSUS server configured, Port {0} open to {1}</pass><fail>WSUS server has not been configured / WSUS server configured, Port {0} not open to {1}</fail><applies>All</applies></xml>'
$script:qahelp['com07']='<xml><description>Check sentinel monitoring agent is installed, and that the correct port is open to the management server</description><pass>Sentinel agent found, Port {0} open to {1}</pass><fail>Sentinel agent not found, install required / Port {0} not open to {1}</fail><applies>All</applies></xml>'
$script:qahelp['drv01']='<xml><description>Check the system drive is a minimum of 50gb for Windows 2008+ servers (some are reporting 49gb)</description><pass>System drive ({0}) meets minimum required size</pass><fail>System drive ({0}) is too small, should be {1}gb</fail><manual>Unable to get drive size, please check manually</manual><applies>All</applies></xml>'
$script:qahelp['drv02']='<xml><description>Ensure all drives have a minimum % of free space.The default value is 17%</description><pass>All drives have the required minimum free space of {0}%</pass><fail>One or more drives were found with less than {0}% free space</fail><manual>Unable to get drive information, please check manually</manual><applies>All</applies></xml>'
$script:qahelp['drv03']='<xml><description>Check the page file is located on the system root drive and fixed size.The default setting is 4096MB (4GB) If the page file is larger a document detailing the tuning processused must exist and should follow Microsoft best tuning practices (http://support.microsoft.com/kb/2021748)</description><pass>Pagefile is set correctly</pass><fail>Pagefile is system managed, it should be set to a custom size of {0}mb / Pagefile should be set on the system drive, to Custom, with Initial and Maximum sizes set to {0}mb / Pagefile does not exist on {0} drive</fail><manual>Unable to get page file information, please check manually</manual><applies>All</applies></xml>'
$script:qahelp['drv04']='<xml><description>If a CD/DVD drive is present on the server confirm it is configured as "</description><pass>CD/DVD drive set correctly</pass><fail>CD/DVD drive found, but not configured as {0}</fail><na>No CD/DVD drives found</na><applies>All</applies></xml>'
$script:qahelp['drv05']='<xml><description>Check Shared Folders to ensure no additional shares are present (Shared folders should be documented with a designated team specified as the owner)</description><pass>No additional shares found</pass><warning>Shared folders found, check against documentation</warning><applies>All</applies></xml>'
$script:qahelp['drv06']='<xml><description>Where SAN storage is used, ensure multipathing software is installed and Dual Paths are present and functioning. ** ONLY CHECKS IF SOFTWARE INSTALLED **</description><fail>SAN storage software not found, install required</fail><manual>{0} found</manual><na>Not a physical machine</na><applies>Physicals</applies></xml>'
$script:qahelp['drv07']='<xml><description>Check local disk array management agent is installed on the server. ** ONLY CHECKS IF SOFTWARE INSTALLED **</description><fail>Disk management software not found, install required</fail><manual>{0} found</manual><na>Not a physical machine</na><applies>Physicals</applies></xml>'
$script:qahelp['drv08']='<xml><description>Ensure all drives are formatted as</description><pass>All drives are formatted as</pass><fail>One or more drives were found not formatted as</fail><manual>Unable to get drive information, please check manually</manual><applies>All</applies></xml>'
$script:qahelp['hvh01']='<xml><description>Check Hyper-V is installed on server core</description><pass>Hyper-V is using Windows Server Core</pass><fail>Hyper-V is not using Windows Server Core</fail><na>Not a Hyper-V server</na><applies>Hyper-V Hosts</applies></xml>'
$script:qahelp['hvh02']='<xml><description>Check Hyper-V is the only one installed</description><pass>No extra server roles or features exist</pass><fail>One or more extra server roles or features exist</fail><na>Not a Hyper-V server</na><applies>Hyper-V Hosts</applies></xml>'
$script:qahelp['hvh03']='<xml><description>Check all VMs are running from a non-system drive</description><pass>No virtual machines are using the system drive</pass><fail>One or more virtual machines are using the system drive</fail><na>Not a Hyper-V server / No virtual machines exist on this host</na><applies>Hyper-V Hosts</applies></xml>'
$script:qahelp['hvh04']='<xml><description>Check the version of the Integration Services</description><fail>Registry setting not found</fail><manual>Integration services found</manual><na>Not a Hyper-V server</na><applies>Hyper-V Hosts</applies></xml>'
$script:qahelp['net01']='<xml><description>Check IPv6 has been unbound on all active NICs, or globally</description><pass>IPv6 disabled globally / IPv6 enabled globally, but disabled on all NICs</pass><fail>IPv6 enabled globally, and NIC(s) found with IPv6 enabled</fail><applies>All</applies></xml>'
$script:qahelp['net02']='<xml><description>Check there are no unused Network interfaces on the server. We define "not in use" by showing any ENABLED NICs set to DHCP All NICs should have a statically assigned IP address.</description><pass>No DHCP enabled adapters found</pass><fail>DHCP enabled adapters found</fail><applies>All</applies></xml>'
$script:qahelp['net03']='<xml><description>Check network interfaces are labelled so their purpose is easily identifiable. FAIL if any Adapter Names are "Local Area Connection x" or "Ethernet x"</description><pass>All adapters renamed from default</pass><fail>An adapter was found with the default name</fail><applies>All</applies></xml>'
$script:qahelp['net04']='<xml><description>Check binding order is set correctly for "Production" as the primary network adapter then as applicable for other interfaces If no "Production" adapter is found, "Management" should be first</description><pass>Binding order correctly set</pass><fail>No network adapters found / {0} or {1} adapters not listed / Binding order incorrect, {0} should be first / Registry setting not found</fail><applies>All</applies></xml>'
$script:qahelp['net05']='<xml><description>Check the network adapter speed and duplex settings. Should be set to "Full Duplex" and "Auto"</description><pass>All network adapters configured correctly</pass><warning>One or more network adapters configured incorrectly</warning><fail>No network adapters found or enabled</fail><applies>All</applies></xml>'
$script:qahelp['net06']='<xml><description>Check local network management agent is installed on the server. ** ONLY CHECKS IF SOFTWARE INSTALLED **</description><pass>{0} found</pass><fail>Network management software not found, install required</fail><na>Not a physical machine</na><applies>Physicals</applies></xml>'
$script:qahelp['net07']='<xml><description>Check network interfaces for known teaming names, manually check they are configured correctly. Fail if no teams found or if server is a virtual.Checked configuration is: Teaming Mode: "Static Independent";Load Balancing Mode: "Address Hash";Standby Adapter: (set)</description><pass>Network team count: {0}</pass><fail>No teamed network adapter(s) found / There are no network teams configured on this server / Native teaming enabled on virtual machine / Team configuration is not set correctly</fail><manual>Teamed network adpater(s) found, check they are configured correctly</manual><na>Not a physical server / Operating system not supported</na><applies>Physicals</applies></xml>'
$script:qahelp['net08']='<xml><description>Check that a management network adapter exists. This must always be present on a server and labelled correctly</description><pass>Management network adapter found</pass><fail>No management network adapter</fail><applies>All</applies></xml>'
$script:qahelp['net09']='<xml><description>Checks to make sure the specified static routes have been added</description><pass>All static routes are present</pass><fail>One or more static routes are missing or incorrect</fail><na>No static routes to check</na><applies>All</applies></xml>'
$script:qahelp['reg01']='<xml><description>Check that the server time is correct.If a valid source is used, the time is also checked against that source. Maximum time difference allowed is 10 seconds.Any longer and the check fails</description><pass>Time source is set to a remote server, and is syncronsized correctly</pass><fail>Time source is set to a remote server, and is not syncronsized correctly / Time source is not set / Time source is not set correctly / Error getting required information /</fail><manual>Not a supported operating system for this check</manual><applies>All</applies></xml>'
$script:qahelp['reg02']='<xml><description>Check that the server timezone is correct.Default setting is "(GMT) Greenwich Mean Time</description><pass>Server timezone set correctly</pass><fail>Server timezone is incorrect and should be set to {0}</fail><applies>All</applies></xml>'
$script:qahelp['reg03']='<xml><description>Ensure the Region and Language > Location is set correctly. Default setting is "United Kingdom"</description><pass>Regional location set correctly</pass><fail>Regional location incorrectly set to {0} / Registry setting not found</fail><applies>All</applies></xml>'
$script:qahelp['reg04']='<xml><description>Ensure the Region and Language > keyboard and Languages is set correctly Default setting is "English (United Kingdom)"</description><pass>Keyboard layout is set correctly</pass><fail>Keyboard layout is not set correctly / Registry setting not found</fail><applies>All</applies></xml>'
$script:qahelp['sec01']='<xml><description>Ensure security ciphers are set correctly.Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings</description><pass>All ciphers set correctly</pass><fail>One or more ciphers set incorrectly</fail><applies>All</applies></xml>'
$script:qahelp['sec02']='<xml><description>Ensure hashes are set correctly. Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings</description><pass>All hashes set correctly</pass><fail>One or more hashes set incorrectly</fail><applies>All</applies></xml>'
$script:qahelp['sec03']='<xml><description>Ensure key exchange algorithms are set correctly.Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings</description><pass>All key exchange algorithms set correctly</pass><fail>One or more key exchange algorithms set incorrectly</fail><applies>All</applies></xml>'
$script:qahelp['sec04']='<xml><description>Ensure protocols are set correctly.Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings</description><pass>All protocols set correctly</pass><fail>One or more protocols set incorrectly</fail><applies>All</applies></xml>'
$script:qahelp['sec05']='<xml><description>Ensure the security cipher order is set correctly.Settings taken from https://www.nartac.com/Products/IISCrypto/Default.aspx using "Best Practices/FIPS 140-2" settings</description><pass>Cipher suite order set correctly</pass><fail>Cipher suite order not set correctly / Cipher suite order set to the default value</fail><applies>All</applies></xml>'
$script:qahelp['sec06']='<xml><description>Ensure the system is set to reject attempts to enumerate accounts in the SAM by anonymous users.</description><pass>Reject annonymous account enumeration is enabled</pass><fail>Reject annonymous account enumeration is disabled / Registry setting not found</fail><applies>All</applies></xml>'
$script:qahelp['sec07']='<xml><description>Ensure the system is set to reject attempts to enumerate shares in the SAM by anonymous users.</description><pass>Reject annonymous share enumeration is enabled</pass><fail>Reject annonymous share enumeration is disabled / Registry setting not found</fail><applies>All</applies></xml>'
$script:qahelp['sec08']='<xml><description>Check system is not caching domain credentials</description><pass>Domain credential caching is disabled</pass><fail>Domain credential cahing is enabled / Registry setting not found</fail><applies>All</applies></xml>'
$script:qahelp['sec09']='<xml><description>Ensure the system is set to request administrative credentials before granting an application elevated privileges.Default setting is either "(1):Prompt for credentials on the secure desktop" or "(3):Prompt for credentials"</description><pass>Prompt for credentials is enabled</pass><fail>System is not set to "Prompt for credentials" when launching an application with elevated privileges / Registry setting not found</fail><applies>All</applies></xml>'
$script:qahelp['sec10']='<xml><description>Ensure the system is set to restrict anonymous access to named pipes</description><pass>Restrict annonymous pipe/share access is enabled</pass><fail>Restrict annonymous pipe/share access is disabled / Registry setting not found</fail><applies>All</applies></xml>'
$script:qahelp['sec11']='<xml><description>Checks to see if the default webpage is present in</description><pass>IIS Installed, "iisstart.htm" not listed in default documents</pass><fail>IIS Installed, default document "iisstart.htm" configured</fail><na>IIS not Installed</na><applies>All</applies></xml>'
$script:qahelp['sec12']='<xml><description>Ensure SMB signing is turned on.</description><pass>SMB Signing configured correctly</pass><fail>SMB Signing not configured correctly / Registry setting not found</fail><applies>All</applies></xml>'
$script:qahelp['sec13']='<xml><description>If server is Domain Controller or a Terminal Server ensure RSA authentication manager is installed and PIN is required to access server.</description><pass>{0} found</pass><fail>RSA software not found</fail><na>Not a domain controller or terminal services server</na><applies>Domain Controllers</applies></xml>'
$script:qahelp['sec14']='<xml><description>Checks to see if there are any addional firewall rules, and warns if there are any. This ignores all default pre-configured rules, and netbackup ports rules (1556, 13724) macmnsvc: McAfee Service;nbwin: NetBackup Client</description><pass>No additional firewall rules exist</pass><warning>One or more additional firewall rules exist, check they are required</warning><applies>All</applies></xml>'
$script:qahelp['sec15']='<xml><description>Check if Windows firewall is enabled or disabled</description><pass>Windows firewall is set correctly</pass><fail>Windows firewall is not set correctly</fail><applies>All</applies></xml>'
$script:qahelp['sys01']='<xml><description>Check for a pending reboot</description><pass>Server is not waiting for a reboot</pass><fail>Server is waiting for a reboot</fail><applies>All</applies></xml>'
$script:qahelp['sys02']='<xml><description>Check windows is licensed.</description><pass>Windows is licenced, Port 1688 open to KMS Server {0}</pass><fail>Windows is licenced, Port 1688 not open to KMS Server {0} / Windows licence check failed / Windows not licenced</fail><applies>All</applies></xml>'
$script:qahelp['sys03']='<xml><description>Check services and ensure all services set to start automatically are running (NetBackup Bare Metal Restore Boot Server,NetBackup SAN Client Fibre Transport Service and .NET4.0 are all expected to be Automatic but not running)</description><pass>All auto-start services are running</pass><fail>An auto-start service was found not running</fail><applies>All</applies></xml>'
$script:qahelp['sys04']='<xml><description>Check services and ensure all listed services are set to disabled and are stopped</description><pass>All services are configured correctly</pass><fail>One or more services are configured incorrectly</fail><applies>All</applies></xml>'
$script:qahelp['sys05']='<xml><description>Check System Event Log and ensure no errors or warnings are present in the last 14 days.If found, will return the latest 15 entries</description><pass>No errors found in system event log</pass><warning>Errors were found in the system event log</warning><applies>All</applies></xml>'
$script:qahelp['sys06']='<xml><description>Check Application Event Log and ensure no errors or warnings are present in the last 14 days.If found, will return the latest 15 entries</description><pass>No errors found in application event log</pass><warning>Errors were found in the application event log</warning><applies>All</applies></xml>'
$script:qahelp['sys07']='<xml><description>Checks Device Manager to ensure there are no unknown devices, conflicts or errors.</description><pass>No device errors found</pass><fail>Device errors found</fail><applies>All</applies></xml>'
$script:qahelp['sys09']='<xml><description>Check to see if any non standard scheduled tasks exist onthe server (Any application specific scheduled tasksshould be documented with a designated contact point specified).Skips any Microsoft specific tasks</description><pass>No additional scheduled tasks found</pass><warning>Additional scheduled tasks found - make sure these are documented</warning><applies>All</applies></xml>'
$script:qahelp['sys10']='<xml><description>Check to see if any printers exist on the server. If printers exist, ensure the spooler directory is not stored on the system drive.</description><pass>Printers found, and spool directory is not set to default path</pass><fail>Spool directory is set to the default path and needs to be changed, Registry setting not found</fail><na>No printers found / Print Spooler service is not running</na><applies>All</applies></xml>'
$script:qahelp['sys11']='<xml><description>Ensure autorun is disabled.</description><pass>Autorun is disabled</pass><fail>Autorun is enabled</fail><applies>All</applies></xml>'
$script:qahelp['sys12']='<xml><description>Check if SNMP role is install on the server.If so, ensure the SNMP community strings follow the secure password policy.</description><pass>SNMP Service installed, but disabled</pass><fail>SNMP Service installed, no communities configured</fail><manual>SNMP Service installed, communities listed</manual><na>SNMP Service not installed</na><applies>All</applies></xml>'
$script:qahelp['sys13']='<xml><description>Checks that the currently logged on user is a member of the domain and not a local user account</description><pass>Currently logged on with domain user account</pass><warning>This is a workgroup server, is this correct.?</warning><fail>Not currently logged on with current domain user account</fail><applies>All</applies></xml>'
$script:qahelp['sys14']='<xml><description>Check power plan is set to High Performance.</description><pass>Power plan is set correctly</pass><fail>Power plan is not set correctly</fail><applies>All</applies></xml>'
$script:qahelp['sys15']='<xml><description>Check hibernation is turned off</description><pass>Hibernation is currently disabled</pass><fail>Hibernation is currently enabled</fail><applies>All</applies></xml>'
$script:qahelp['sys16']='<xml><description>Check that remote desktop is enabled and that Network Level Authentication (NLA) is set</description><pass>Secure remote desktop and NLA enabled</pass><warning>Network Level Authentication is not set</warning><fail>Secure remote desktop disabled</fail><applies>All</applies></xml>'
$script:qahelp['sys17']='<xml><description>If server is a Terminal Services Server ensure it has a licence server set.</description><pass>Terminal services server is licenced</pass><fail>Terminal services server is not licenced</fail><na>Not a terminal services server</na><applies>All</applies></xml>'
$script:qahelp['vhv01']='<xml><description>Check that the latest HyperV integration services are installed</description><fail>Integration services not installed</fail><manual>Integration services found</manual><na>Not a virtual machine</na><applies>Virtuals</applies></xml>'
$script:qahelp['vmw01']='<xml><description>Check that the latest vmware tools are installed</description><pass>VMware tools are up to date</pass><fail>VMware tools can be upgraded</fail><manual>Unable to check the VMware Tools upgrade status</manual><na>Not a virtual machine</na><applies>Virtuals</applies></xml>'
$script:qahelp['vmw02']='<xml><description>Check that VMware Host Time Sync is disabled</description><pass>VMware tools time sync is disabled</pass><fail>VMware tools time sync is enabled</fail><manual>Unable to check the VMware time sync status</manual><na>Not a virtual machine</na><applies>Virtuals</applies></xml>'
$script:qahelp['vmw03']='<xml><description>Check all virtual servers have network cards that are configured as VMXNET3</description><pass>All active NICS configured correctly</pass><warning>No network adapters found</warning><fail>One or more active NICs were found not to be VMXNET3</fail><na>Not a virtual machine</na><applies>Virtuals</applies></xml>'
$script:qahelp['vmw04']='<xml><description>Check Windows disk controller is set correctly. Default setting is "LSI logic SAS"</description><pass>Disk controller set correctly</pass><fail>No SCSI controllers found / Disk controller not set correctly</fail><na>Not a virtual machine</na><applies>Virtuals</applies></xml>'
$script:qahelp['vmw05']='<xml><description>Checks to see if there are are more than 8 drives attached to the same SCSI adapter.</description><pass>More than 7 drives exist, but on different SCSI adapters</pass><fail>More than 7 drives exist on one SCSI adapter</fail><na>Not a virtual machine / There are less than 8 drives attached to server</na><applies>Virtuals</applies></xml>'
$script:qahelp['vmw06']='<xml><description>Checks to see if the total VM size is less than 1tb</description><pass>VM is smaller than 1</pass><warning>VM is larger than 1TB.Make sure there is an engineering exception in place for this</warning><na>Not a virtual machine</na><applies>Virtuals</applies></xml>'
$script:qahelp['vmw07']='<xml><description>Checks for any mounted CD/DVD or floppy drives</description><pass>No CD/ROM or floppy drives are mounted</pass><fail>One or more CD/ROM or floppy drives are mounted</fail><na>Not a virtual machine</na><applies>Virtuals</applies></xml>'

##############################################################################################################################################################################################
$script:lang['Accounts'] = 'Accounts'                 # User and group accounts
$script:lang['AD-Message'] = 'ACCESS DENIED'
$script:lang['Admin-Warn_1'] = 'You are not running this script as an administrator'
$script:lang['Admin-Warn_2'] = 'Restart PowerShell with the "Run as Administrator" option'
$script:lang['AD-Write-Host'] = 'ACCESS DENIED - Skipping all scripts for server'
$script:lang['Applies-To'] = 'Applies To'              # Part of the HTML hover help.
$script:lang['CF-Message'] = 'CONNECTION FAILURE while contacting the server, check that the server switched on and working'
$script:lang['CF-Write-Host'] = 'CONNECTION FAILURE - Skipping all scripts for server'
$script:lang['Checked'] = 'Checked'                 #
$script:lang['Compliance'] = 'Compliance'               # Tooling agent checks (AV, SCOM, SCCM, etc)
$script:lang['Drives'] = 'Drives'                   # Local disk drive information
$script:lang['Error'] = 'Error'                   #
$script:lang['Fail'] = 'Fail'                    #
$script:lang['Failed'] = 'Failed'                  #
$script:lang['FD-Message'] = 'Job failed to run or the remote server was disconnected'
$script:lang['FD-Write-Host'] = 'JOB FAILED/DISCONNECTED - Skipping all scripts for server'
$script:lang['Generated-By'] = 'Generated by'            # Generated By (username) on (date)
$script:lang['Header'] = 'Starting QA Procedure'
$script:lang['Help_01'] = 'Usage Information'
$script:lang['Help_02'] = 'Quick Usage:'
$script:lang['Help_03'] = 'Examples:'
$script:lang['Help_04'] = 'Local Server Only:'
$script:lang['Help_05'] = 'Use a period (.) to indicate the localhost, or use the servername:'
$script:lang['Help_06'] = 'Multiple Servers:'
$script:lang['Help_07'] = 'Using commas (,) to separate, add each server to the command line:'
$script:lang['Help_08'] = 'Using a text file, with each server on a separate line:'
$script:lang['Help_09'] = 'Please Note:'
$script:lang['Help_10'] = 'The script connects using the same credentials as the powershell window.'
$script:lang['Help_11'] = 'To connect using different credentials, Shift + Right-click the PowerShell'
$script:lang['Help_12'] = 'icon in the Start Menu and select "Run as different user".  Enter the user'
$script:lang['Help_13'] = 'details required and then re-run the script.'
$script:lang['Help_14'] = ''
$script:lang['Help_15'] = ''
$script:lang['Help_16'] = ''
$script:lang['Help_17'] = ''
$script:lang['Help_18'] = ''
$script:lang['Help_19'] = ''
$script:lang['Help_20'] = ''
$script:lang['HTML_Check'] = 'Check'                   # The check code (ACC-01)
$script:lang['HTML_Data'] = 'Data'                    # The informational data returned
$script:lang['HTML_Message'] = 'Message'                 # The message retuned to the user
$script:lang['HTML_Name'] = 'Name'                    # The short name of the check
$script:lang['HTML_Result'] = 'Result'                  # The check result (Pass, Fail, ...)
$script:lang['HyperV-Host'] = 'HyperV Host'              # Microsoft Hyper-V host systems (not guests)
$script:lang['Manual'] = 'Manual'                  #
$script:lang['ND-Message'] = 'Error while running, job returned no data'
$script:lang['ND-Name'] = 'NO DATA'
$script:lang['Network'] = 'Network'                  # Local area networking information
$script:lang['Not-Applicable'] = 'N/A'                     #
$script:lang['On'] = 'on'                      #
$script:lang['Pass'] = 'Pass'                    #
$script:lang['Passed'] = 'Passed'                  #
$script:lang['QA-Results'] = 'QA Results'              # Page header
$script:lang['Regional'] = 'Regional'                 # Localised keyboard/language settings
$script:lang['ReportsLocated'] = 'Reports Located In:'     #
$script:lang['RPC-Message'] = 'RPC FAILURE while communicating with the server, check the firewall ports are opened correctly'
$script:lang['RPC-Write-Host'] = 'RPC FAILURE - Skipping all scripts for server'
$script:lang['Scan-Head_1'] = 'There are {0} checks to perform, with a maximum of {1} running concurrently'
$script:lang['Scan-Head_2'] = 'Each has a timeout limit of {0} seconds.  Progress bar legend:'
$script:lang['Script-Version'] = 'Script Version:'         # Script Version: (version)
$script:lang['Security'] = 'Security'                 # Security and firewall checks
$script:lang['ServerCount'] = 'Scanning {0} servers'    #
$script:lang['Servers'] = 'servers'
$script:lang['Skipped'] = 'Skipped'                 #
$script:lang['System'] = 'System'                   # Local computer system checks
$script:lang['TimeTaken'] = 'Approx Time Taken :'     #
$script:lang['TO-Message'] = 'Job failed to finish within the timeout period, job cancelled'
$script:lang['TO-Name'] = 'TIMEOUT'
$script:lang['TotalCount_1'] = 'Total Server Counts'     # Total count of the number of servers scanned
$script:lang['TotalCount_2'] = 'Total Script Results'    # Total count of the script results (Passed, Failed, ...)
$script:lang['Verbose-Info'] = 'Verbose information:'
$script:lang['VMs-HyperV'] = 'VMs: HyperV'              # Computers that are Hyper-V guests (not hosts)
$script:lang['VMs-VMware'] = 'VMs: VMware'              # Computers that are VMware ESX guests (not hosts)
$script:lang['Warning'] = 'Warning'                 #
##############################################################################################################################################################################################
[string]$reportCompanyName = "ACME"
[string]$script:qaOutput   = "$env:SystemDrive\QA\Results\"
Function Show-HelpScreen
{
    Clear-Host
    Write-Header -Message $($script:lang['Help_01']) -Width $script:screenwidth
    Write-Host ' '$($script:lang['Help_02'])                                               -ForegroundColor Cyan
    Write-Colr '    QA.ps1 [-ComputerName] ','server01','[, server02, server03, ...]'      -Colour          Yellow, Yellow, Gray, Yellow, Gray
    Write-Colr '    QA.ps1 [-ComputerName] ','(Get-Content -Path x:\path\list.txt)'        -Colour          Yellow, Yellow, Gray, Yellow
    Write-Host ''
    Write-Host ''
    Write-Host ' '$($script:lang['Help_03'])                                               -ForegroundColor Cyan
    Write-Host '   '$($script:lang['Help_04'])                                             -ForegroundColor Cyan
    Write-Colr '      ', $($script:lang['Help_05'])                                        -Colour          Cyan, White
    Write-Colr '        QA.ps1 [-ComputerName] ','.'                                       -Colour          Yellow, Yellow, Gray, Yellow
    Write-Colr '        QA.ps1 [-ComputerName] ','server01'                                -Colour          Yellow, Yellow, Gray, Yellow
    Write-Host ''
    Write-Host '   '$($script:lang['Help_06'])                                             -ForegroundColor Cyan
    Write-Colr '      ', $($script:lang['Help_07'])                                        -Colour          Cyan, White
    Write-Colr '        QA.ps1 [-ComputerName] ','server01, server02, server03, ...'       -Colour          Yellow, Yellow, Gray, Yellow
    Write-Host ''
    Write-Colr '      ', $($script:lang['Help_08'])                                        -Colour          Cyan, White
    Write-Colr '        QA.ps1 [-ComputerName] ','(Get-Content -Path x:\path\list.txt)'    -Colour          Yellow, Yellow, Gray, Yellow
    Write-Host ''
    Write-Host ' '$script:lang['Help_09']                                                  -ForegroundColor Cyan

    [int]$iCnt = 10
    Do {
        If ([string]::IsNullOrEmpty($script:lang["Help_$iCnt"]) -eq $false) { Write-Host '   '$script:lang["Help_$iCnt"] -ForegroundColor White }
        $iCnt++
    } While ($iCnt -lt 20)

    Write-Host (DivLine -Width $script:screenwidth)                                        -ForegroundColor Yellow
    Write-Host ''
    Exit
}

###################################################################################################

Function Check-CommandLine
{
    If (Test-Path variable:help) { If ($Help -eq $true)
    {
        Show-HelpScreen
        Exit 
    } }

    # Resize window to be 120 wide and keep the height.
    # Also change the buffer size to be huge
    $gh = Get-Host
    $ws = $gh.UI.RawUI.WindowSize
    $wh = $ws.Height
    If ($ws.Width -le 120)
    {
        $ws.Height = 9999
        $ws.Width  =  120; $gh.UI.RawUI.Set_BufferSize($ws)
        $ws.Height =  $wh; $gh.UI.RawUI.Set_WindowSize($ws)
    }
    $script:screenwidth = ($ws.Width - 2)
    Remove-Variable wh, ws, gh

    Clear-Host
    Write-Header -Message $script:lang['Header'] -Width $script:screenwidth

    # Check admin status
    If (-not ([Security.Principal.WindowsPrincipal] `
              [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole( `
              [Security.Principal.WindowsBuiltInRole] 'Administrator'))
    {
        Write-Host ('  {0}' -f $script:lang['Admin-Warn_1']) -ForegroundColor Red
        Write-Host ('  {0}' -f $script:lang['Admin-Warn_2']) -ForegroundColor Red
        Write-Host ('')
        Break
    }

    [array]$serverFilter = @()
    If (Test-Path variable:ComputerName) { If ($ComputerName -ne $null) { $ComputerName | ForEach { If ($_.Length -gt 0) { $script:servers += $_.Trim() } } } }
    $script:servers | ForEach {
        If ($_ -eq '.') { $serverFilter += ${env:ComputerName}.ToLower() }
        Else { If ($_.Trim() -eq '-ComputerName') { $_ = '' }; If ($_.Trim().Length -gt 2) { $serverFilter += $_.Trim().ToLower() } }
    }
    $script:servers = ($serverFilter | Select-Object -Unique | Sort-Object)
    If ([string]::IsNullOrEmpty($script:servers) -eq $true) { Show-HelpScreen; Exit }
}

Function Start-QAProcess
{
    # Verbose information output
    If ($PSCmdlet.MyInvocation.BoundParameters.ContainsKey('Verbose') -eq $true) { $script:ccTasks = 1 }

    # Write job information
    [int]$count = $script:qaChecks.Count
    Write-Host ($('  {0}' -f $script:lang['Scan-Head_1']) -f $count, $script:ccTasks) -ForegroundColor White
    Write-Host ($('  {0}' -f $script:lang['Scan-Head_2']) -f $script:checkTimeout   ) -ForegroundColor White

    # Progress bar legend
    [string]$lP = $script:lang['Passed']; [string]$lW = $script:lang['Warning']       ; [string]$lF = $script:lang['Failed']
    [string]$lM = $script:lang['Manual']; [string]$lN = $script:lang['Not-Applicable']; [string]$lE = $script:lang['Error']
    Write-Host ('    ▄▄▄' + ''.PadLeft($lP.Length)) -NoNewline -ForegroundColor DarkGray; Write-Host ('    ▄▄▄' + ''.PadLeft($lW.Length)) -NoNewline -ForegroundColor DarkGray
    Write-Host ('    ▄▄▄' + ''.PadLeft($lF.Length)) -NoNewline -ForegroundColor DarkGray; Write-Host ('    ▄▄▄' + ''.PadLeft($lM.Length)) -NoNewline -ForegroundColor DarkGray
    Write-Host ('    ▄▄▄' + ''.PadLeft($lN.Length)) -NoNewline -ForegroundColor DarkGray; Write-Host ('    ▄▄▄' + ''.PadLeft($lE.Length))            -ForegroundColor DarkGray
    Write-Host ('     ▀ ' + $lP)                    -NoNewline -ForegroundColor Green   ; Write-Host ('     ▀ ' + $lW)                    -NoNewline -ForegroundColor Yellow
    Write-Host ('     ▀ ' + $lF)                    -NoNewline -ForegroundColor Red     ; Write-Host ('     ▀ ' + $lM)                    -NoNewline -ForegroundColor Cyan
    Write-Host ('     ▀ ' + $lN)                    -NoNewline -ForegroundColor Gray    ; Write-Host ('     ▀ ' + $lE)                               -ForegroundColor Magenta
    Write-Host (DivLine -Width $script:screenwidth)                                                    -ForegroundColor Yellow

    If ($script:servers.Count -gt 1)
    {
        Write-Host ($('  {0}' -f $script:lang['ServerCount']) -f $($script:servers.Count)) -ForegroundColor White
        Write-Host (DivLine -Width $script:screenwidth)                                    -ForegroundColor Yellow
    }

    # Create required output folders
    New-Item -ItemType Directory -Force -Path ($script:qaOutput) | Out-Null
    If ($PSCmdlet.MyInvocation.BoundParameters.ContainsKey('Verbose') -eq $true) { $pBlock = '■' } Else { $pBlock = '▀' }
    If ($GenerateCSV -eq $true)
        { If (Test-Path -Path ($script:qaOutput + 'QA_Results.csv')) {
            Try { Remove-Item ($script:qaOutput + 'QA_Results.csv') -Force } Catch {}
    } }

    # Master job loop
    [int]$CurrentServerNumber = 0
    ForEach ($server In $script:servers)
    {
        $CurrentServerNumber++
        [array]$serverresults = @()
        [int]   $Padding      = ($script:servers.Count -as [string]).Length
        [string]$CurrentCount = ('({0}/{1})' -f $CurrentServerNumber.ToString().PadLeft($Padding), ($script:servers.Count))
        Write-Host ''
        Write-Colr '  ', $server.PadRight($script:screenwidth - $CurrentCount.Length - 2), $CurrentCount -Colour White, White, Yellow
        Write-Host '   ' -NoNewline

        # Make sure the computer is reachable
        If ((Test-Connection -ComputerName $server -Quiet -Count 1) -eq $true)
        {
            # Use the test-port function to make sure that the RPC port is listening
            If ((Test-Port $server) -eq $true)
            {
                If ($PSCmdlet.MyInvocation.BoundParameters.ContainsKey('Verbose') -eq $true)
                {
                    Write-Host $script:lang['Verbose-Info'] -ForegroundColor Yellow -NoNewline
                }
                Else {
                    For ([int]$i = 0; $i -lt $count; $i++) { Write-Host '▄' -ForegroundColor DarkGray -NoNewline }
                    Write-Host ''
                    Write-Host '   ' -ForegroundColor DarkGray -NoNewline
                }

                # RPC Connected, loop through the checks and start a job
                [array]    $jobs         = $script:qaChecks
                [int]      $jobIndex     = 0         # Which job is up for running
                [hashtable]$workItems    = @{ }      # Items being worked on
                [hashtable]$jobtimer     = @{ }      # Timers for jobs
                [boolean]  $workComplete = $false    # Is the script done with what it needs to do?

                While (-not $workComplete)
                {
                    # Process any finished jobs.
                    ForEach ($key In @() + $workItems.Keys)
                    {
                        # Time in seconds current job has been running for
                        [int]$elapsed = $jobtimer.Get_Item($workItems[$key].Name).Elapsed.TotalSeconds

                        # Process succesful jobs
                        If ($workItems[$key].State -eq 'Completed')
                        {
                            # $key is done.
                            [PSObject]$result = Receive-Job $workItems[$key]
                            If ($result -ne $null)
                            {
                                # add to results
                                $script:results += $result
                                $serverresults  += $result

                                # provide some pretty output on the console
                                Switch ($result.result)
                                {
                                    $script:lang['Pass']           { Write-Host $pBlock -ForegroundColor Green  -NoNewline ; Break }
                                    $script:lang['Warning']        { Write-Host $pBlock -ForegroundColor Yellow -NoNewline ; Break }
                                    $script:lang['Fail']           { Write-Host $pBlock -ForegroundColor Red    -NoNewline ; Break }
                                    $script:lang['Manual']         { Write-Host $pBlock -ForegroundColor Cyan   -NoNewline ; Break }
                                    $script:lang['Not-Applicable'] { Write-Host $pBlock -ForegroundColor Gray   -NoNewline ; Break }
                                    $script:lang['Error']          { If ($result.data -like '*Access is denied*') {
                                                                         If ($workComplete -eq $false) {
                                                                             $result.message = $script:lang['AD-Message']    # ACCESS DENIED
                                                                             $script:failurecount++
                                                                             Write-Host ('■ ' + $script:lang['AD-Write-Host']) -ForegroundColor Magenta -NoNewline
                                                                             $workComplete = $true } }
                                                                     Else { If ($workComplete -eq $false) { Write-Host '█' -ForegroundColor Magenta -NoNewline } }
                                                                   }
                                    Default                        { Write-Host '█' -ForegroundColor DarkGray -NoNewline; Break }
                                }
                            }
                            Else
                            {
                                # Job returned no data
                                $result          = newResult
                                $result.server   = $server
                                $result.name     = $script:lang['ND-Name']    # NO DATA
                                $result.check    = $workItems[$key].name
                                $result.result   = 'Error'
                                $result.message  = $script:lang['ND-Message']
                                $script:results += $result
                                $serverresults  += $result
                                Write-Host '■' -ForegroundColor Magenta -NoNewline
                            }
                            $workItems.Remove($key)
                        
                        # Job failed or server disconnected
                        }
                        ElseIf (($workItems[$key].State -eq 'Failed') -or ($workItems[$key].State -eq 'Disconnected'))
                        {
                            $result          = newResult
                            $result.server   = $server
                            $result.name     = $workItems[$key].State.ToUpper()
                            $result.check    = $workItems[$key].name
                            $result.result   = 'Error'
                            $result.message  = $script:lang['FD-Message']    # FAILED / DISCONNECTED
                            $script:results += $result
                            $serverresults  += $result
                            Write-Host ('■ ' + $script:lang['FD-Write-Host']) -ForegroundColor Magenta -NoNewline
                            $workItems.Remove($key)
                            $script:failurecount++
                            $workComplete = $true
                        }

                        # Check for timed out jobs and kill them
                        If ($workItems[$key])
                        {
                            If ($workItems[$key].State -eq 'Running' -and ($elapsed -ge $script:checkTimeout))
                            {
                                $result          = newResult
                                $result.server   = $server
                                $result.name     = $script:lang['TO-Name']    # TIMEOUT
                                $result.check    = $workItems[$key].name
                                $result.result   = 'Error'
                                $result.message  = $script:lang['TO-Message']
                                $script:results += $result
                                $serverresults  += $result
                                Try { Stop-Job -Job $workItems[$key]; Remove-Job -Job $workItems[$key] } Catch { }
                                Write-Host '█' -ForegroundColor Magenta -NoNewline
                                $workItems.Remove($key)
                            }
                        }
                    }

                    # Start new jobs if there are open slots.
                    While (($workItems.Count -lt $script:ccTasks) -and ($jobIndex -lt $jobs.Length))
                    {
                        [string]$job             = ($jobs[$jobIndex].Substring(0, 8).Replace('-',''))  # c-xyz-01-gold-build --> cxyz01
                        [int]   $jobOn           =  $jobIndex + 1                                      # f-xyz-01-gold-build --> fxyz01
                        [int]   $numJobs         =  $jobs.Count
                        [string]$funcName        =  $jobs[$jobIndex]
                        [object]$initScript      =  Invoke-Expression "`$$job"

                        If ($PSCmdlet.MyInvocation.BoundParameters.ContainsKey('Verbose') -eq $true)
                        {
                            Write-Host ''
                            Write-Host '   '$jobs[$jobIndex].ToString().PadRight($script:screenwidth - 9, '.')': ' -ForegroundColor Gray -NoNewline
                        }

                        # Run the required job...
                        $workItems[$job] = Start-Job -InitializationScript $initScript -ArgumentList $funcName, $server, $script:qaOutput `
                                                     -ScriptBlock { Invoke-Expression  -Command "$args[0] $args[1] $args[2]" } -Name $funcName

                        $stopWatch = [System.Diagnostics.StopWatch]::StartNew()
                        $jobtimer.Add($funcName, $stopWatch)
                        $jobIndex += 1
                    }

                    # If all jobs have been processed we are done - next server.
                    If ($jobIndex -eq $jobs.Length -and $workItems.Count -eq 0) { $workComplete = $true }
                
                    # Wait between status checks
                    Start-Sleep -Milliseconds $waitTime
                }
            }
            Else
            {
                # RPC not responding / erroring, unable to ping server
                $result          = newResult
                $result.server   = $server
                $result.name     = 'X'
                $result.check    = 'X'
                $result.result   = 'Error'
                $result.message  = $script:lang['RPC-Message']    # RPC FAILURE
                $script:results += $result
                $serverresults  += $result
                $script:failurecount++
                Write-Host ('■ ' + $script:lang['RPC-Write-Host']) -ForegroundColor Magenta -NoNewline
            }
        }
        Else
        {
            # Unable to connect
            $result          = newResult
            $result.server   = $server
            $result.name     = 'X'
            $result.check    = 'X'
            $result.result   = 'Error'
            $result.message  = $script:lang['CF-Message']    # CONNECTION FAILURE
            $script:results += $result
            $serverresults  += $result
            $script:failurecount++
            Write-Host ('■ ' + $script:lang['CF-Write-Host']) -ForegroundColor Magenta -NoNewline
        }

        Write-Host ''
        Export-Results -results_input $serverresults
        If ($result.result -ne 'Error')
        {
            $resultsplit = Get-ResultsSplit -serverName $server
            [int]$padding = ($script:qaChecks).Count - 19
            If ($padding -lt 3) { $padding = 3 }
            If ($PSCmdlet.MyInvocation.BoundParameters.ContainsKey('Verbose') -eq $true) { $padding = ($script:screenwidth - 23) }
            Write-Colr ''.PadLeft($padding), $resultsplit.p.PadLeft(2), ', ', $resultsplit.w.PadLeft(2), ', ', $resultsplit.f.PadLeft(2), ', ', `
                                             $resultsplit.m.PadLeft(2), ', ', $resultsplit.n.PadLeft(2), ', ', $resultsplit.e.PadLeft(2) `
                         -Colour White, Green, White, Yellow, White, Red, White, Cyan, White, Gray, White, Magenta
        }
    }

    Remove-Variable server, i, jobs, jobIndex, workItems, jobTimer, workComplete, key, elapsed, result, job, jobOn, numJobs, funcName, initScript, stopwatch -ErrorAction SilentlyContinue
}

Function Get-ResultsSplit
{
    Param ( [string]$serverName )
    [string]$p = @($script:results | Where-Object  { $_.result -eq $script:lang['Pass']           -and $_.server -like $serverName }).Count.ToString()
    [string]$w = @($script:results | Where-Object  { $_.result -eq $script:lang['Warning']        -and $_.server -like $serverName }).Count.ToString()
    [string]$f = @($script:results | Where-Object  { $_.result -eq $script:lang['Fail']           -and $_.server -like $serverName }).Count.ToString()
    [string]$m = @($script:results | Where-Object  { $_.result -eq $script:lang['Manual']         -and $_.server -like $serverName }).Count.ToString()
    [string]$n = @($script:results | Where-Object  { $_.result -eq $script:lang['Not-Applicable'] -and $_.server -like $serverName }).Count.ToString()
    [string]$e = @($script:results | Where-Object  { $_.result -eq $script:lang['Error']          -and $_.server -like $serverName }).Count.ToString()

    [PSObject]$resultsplit = New-Object -TypeName PSObject -Property @{ 'p'=$p; 'w'=$w; 'f'=$f; 'm'=$m; 'n'=$n; 'e'=$e; }
    Return $resultsplit
}

Function Show-Results
{
    [string]$y = $script:failurecount
    [string]$x = (@($script:servers).Count - $y)
    $resultsplit = Get-ResultsSplit -serverName '*'
    [int]$w = $script:screenwidth - 2
    Write-Host ''
    Write-Host (DivLine -Width $script:screenwidth) -ForegroundColor Yellow

    [int]$rightPad = (($script:lang['Passed']).Length)
    If ((($script:lang['Warning']       ).Length) -gt $rightPad) { $rightPad = (($script:lang['Warning']       ).Length) }
    If ((($script:lang['Failed']        ).Length) -gt $rightPad) { $rightPad = (($script:lang['Failed']        ).Length) }
    If ((($script:lang['Manual']        ).Length) -gt $rightPad) { $rightPad = (($script:lang['Manual']        ).Length) }
    If ((($script:lang['Not-Applicable']).Length) -gt $rightPad) { $rightPad = (($script:lang['Not-Applicable']).Length) }
    If ((($script:lang['Error']         ).Length) -gt $rightPad) { $rightPad = (($script:lang['Error']         ).Length) }

    If ((($script:lang['Checked']).Length) -gt (($script:lang['Skipped']).Length)) { [int]$leftPad = (($script:lang['Checked']).Length) } Else { [int]$leftPad = (($script:lang['Skipped']).Length) }

    Write-Host ('  {0}{1}' -f ($script:lang['TotalCount_1']), (($script:lang['TotalCount_2']).PadLeft($w - (($script:lang['TotalCount_2']).Length)))) -ForegroundColor White
    Write-Host ('    {0}: {1}{2}:{3}' -f ($script:lang['Checked']).PadLeft($leftPad), $x.PadLeft(3), ($script:lang['Passed']        ).PadLeft($w - $rightPad - $leftPad - 7), ($resultsplit.p).PadLeft(4)) -ForegroundColor Green
    Write-Host ('    {0}: {1}{2}:{3}' -f ($script:lang['Skipped']).PadLeft($leftPad), $y.PadLeft(3), ($script:lang['Warning']       ).PadLeft($w - $rightPad - $leftPad - 7), ($resultsplit.w).PadLeft(4)) -ForegroundColor Yellow
    Write-Host (        '    {0}:{1}' -f                                                             ($script:lang['Failed']        ).PadLeft($w - $rightPad            - 2), ($resultsplit.f).PadLeft(4)) -ForegroundColor Red
    Write-Host (        '    {0}:{1}' -f                                                             ($script:lang['Manual']        ).PadLeft($w - $rightPad            - 2), ($resultsplit.m).PadLeft(4)) -ForegroundColor Cyan
    Write-Host (        '    {0}:{1}' -f                                                             ($script:lang['Not-Applicable']).PadLeft($w - $rightPad            - 2), ($resultsplit.n).PadLeft(4)) -ForegroundColor Gray
    Write-Host (        '    {0}:{1}' -f                                                             ($script:lang['Error']         ).PadLeft($w - $rightPad            - 2), ($resultsplit.e).PadLeft(4)) -ForegroundColor Magenta

    Write-Host (DivLine -Width $script:screenwidth) -ForegroundColor Yellow
    Remove-Variable x, y, w, resultsplit -ErrorAction SilentlyContinue
}

Function Export-Results
{
    Param ( [array]$results_input )
    [string]$Head = @'
<style>
    @charset UTF-8;
    html body       { font-family: Verdana, Geneva, sans-serif; font-size: 12px; height: 100%; margin: 0; overflow: auto; }
    #header         { background: #0066a1; color: #ffffff; width: 100% }
    #headerTop      { padding: 10px; }

    .logo1          { float: left;  font-size: 25px; font-weight: bold; padding: 0 7px 0 0; }
    .logo2          { float: left;  font-size: 25px; }
    .logo3          { float: right; font-size: 12px; text-align: right; }

    .headerRow1     { background: #66a3c7; height: 5px; }
    .headerRow2     { background: #000000; height: 5px; }
    .serverRow      { background: #000000; color: #ffffff; font-size: 32px; padding: 10px; text-align: center; text-transform: uppercase; }
    .summary        { width: 100%; }
    .summaryName    { float: left; text-align: center; padding: 6px 0; width: 16.66%; }
    .summaryCount   { text-align: center; font-size: 45px; }

    .p { background: #b3ffbe!important; }
    .w { background: #ffdc89!important; }
    .f { background: #ff9787!important; }
    .m { background: #66a3c7!important; }
    .n { background: #c8c8c8!important; }
    .e { background: #c80000!important; color: #ffffff!important; }
    .x { background: #ffffff!important; }
    .s { background: #c8c8c8!important; }

    .note           { text-decoration: none; }
    .note div.help  { display: none; }
    .note:hover     { cursor: help; position: relative; }
    .note:hover div.help { background: #ffffdd; border: #000000 3px solid; display: block; left: 10px; margin: 10px; padding: 15px; position: fixed; text-align: left; text-decoration: none; top: 10px; width: 600px; z-index: 100; }
    .note li        { display: table-row-group; list-style: none; }
    .note li span   { display: table-cell; vertical-align: top; padding: 3px 0; }
    .note li span:first-child { text-align: right; min-width: 120px; max-width: 120px; font-weight: bold; padding-right: 7px; }
    .note li span:last-child  { padding-left: 7px; border-left: 1px solid #000000; }

    .sectionRow     { background: #0066a1; color: #ffffff; font-size: 13px; padding: 1px 15px!important; font-weight: bold; height: 25px!important; }
    table tr:hover td.sectionRow { background: #0066a1; }

    table           { background: #eaebec; border: #cccccc 1px solid; border-collapse: collapse; margin: 0; width: 100%; }
    table th        { background: #ededed; border-top: 1px solid #fafafa; border-bottom: 1px solid #e0e0e0; border-left: 1px solid #e0e0e0; height: 45px; min-width: 55px; padding: 0px 15px; text-transform: capitalize; }
    table tr        { text-align: center; padding-left: 15px; }
    table td        { background: #fafafa; border-top: 1px solid #ffffff; border-bottom: 1px solid #e0e0e0; border-left: 1px solid #e0e0e0; height: 55px; min-width: 55px; padding: 0px 10px; }
    table td:first-child   { min-width: 175px; width: 175px; text-align: left; }
    table tr:last-child td { border-bottom: 0; }
    table tr:hover td      { background: #f2f2f2; }
</style>
'@

    If ($SkipHTMLHelp -eq $true) { $Head = $Head.Replace('cursor: help;', 'cursor: default;') }

    [string]$dt1 = (Get-Date -Format 'yyyy/MM/dd HH:mm')
    [string]$dt2 = $dt1.Replace('/','.').Replace(' ','-').Replace(':','.')    # 'yyyy/MM/dd HH:mm'  -->  'yyyy.MM.dd-HH.mm'
    [string]$un  = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name.ToLower()

    [string]$server = $results_input[0].server
    $resultsplit = Get-ResultsSplit -serverName $server
    [string]$body = @"
<div id="header">
    <div id="headerTop">
        <div class="logo1">$reportCompanyName</div>
        <div class="logo2">$($script:lang['QA-Results'])</div>
        <div class="logo3">$($script:lang['Script-Version']) <b>$version</b> ($settingsFile)
                      <br/>$($script:lang['Generated-By']) <b>$un</b> $($script:lang['On']) <b>$dt1</b></div>
        <div style="clear:both;"></div>
    </div>
    <div style="clear:both;"></div>
</div>
<div class="headerRow1"></div>
<div class="serverRow">$server</div>
<div class="summary">
    <div class="summaryName p"><b>$($script:lang['Passed']        )</b><br><span class="summaryCount">$($resultsplit.p)</span></div>
    <div class="summaryName w"><b>$($script:lang['Warning']       )</b><br><span class="summaryCount">$($resultsplit.w)</span></div>
    <div class="summaryName f"><b>$($script:lang['Failed']        )</b><br><span class="summaryCount">$($resultsplit.f)</span></div>
    <div class="summaryName m"><b>$($script:lang['Manual']        )</b><br><span class="summaryCount">$($resultsplit.m)</span></div>
    <div class="summaryName n"><b>$($script:lang['Not-Applicable'])</b><br><span class="summaryCount">$($resultsplit.n)</span></div>
    <div class="summaryName x"><b>$($script:lang['Error']         )</b><br><span class="summaryCount">$($resultsplit.e)</span></div>
</div>
<div style="clear:both;"></div>
<div class="headerRow2"></div>
"@

    [array] $core = @()
    [array] $cust = @()
    [string]$path = $script:qaOutput + $server + '_' + $dt2 + '.html'
    # Sort the results, adding the customer specific items at the end
    $results_input   | Select-Object name, check, result, message, data | ForEach-Object {
        If (($_.check) -eq 'X') { $core += $_ } Else { If ($script:sections.Keys -contains ($_.check).SubString(2,3)) { $core += $_ } Else { $cust += $_ } }
    }
    $core    = $core | Sort-Object check; $cust = $cust | Sort-Object check
    $outHTML = $core + $cust | ConvertTo-HTML -Head $Head -Title 'QA Results' -Body $Body

    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Pass'])           + '"') -InputObject $outHTML
    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Warning'])        + '"') -InputObject $outHTML
    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Fail'])           + '"') -InputObject $outHTML
    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Manual'])         + '"') -InputObject $outHTML
    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Not-Applicable']) + '"') -InputObject $outHTML
    $outHTML = Set-CellColour -Filter ('result -eq "' + $($script:lang['Error'])          + '"') -InputObject $outHTML -Row
    $outHTML = Format-HTMLOutput -InputObject $outHTML
    $outHTML | Out-File $path -Force -Encoding utf8

    # CSV Output
    If ($GenerateCSV -eq $true)
    {
        [string]$path   =  $script:qaOutput + 'QA_Results.csv'
        [array] $outCSV =  @()
        [array] $cnvCSV = ($results_input | Select-Object server, name, check, datetime, result, message, data | Sort-Object check, server | ConvertTo-Csv -NoTypeInformation)
        $cnvCSV | ForEach-Object { $outCSV += $_.Replace(',#',', ') }
        $outCSV | Out-File -FilePath $path -Encoding utf8 -Force
    }
    
    Remove-Variable resultsplit, Head, Body, serversOut, server, serverResults, outHTML, outCSV, cnvCSV, path -ErrorAction SilentlyContinue
}

###################################################################################################

Function Format-HTMLOutput
{
    Param ( [Object[]]$InputObject )
    Begin { }
    Process
    {
        [string]$sectionNew = ''
        [string]$sectionOld = ''

        ForEach ($input In $InputObject)
        {
            [string]$line = $input
            If ($line.IndexOf('<tr><th') -ge 0)
            {
                [int]$count = 0
                [int]$func  = 0
                $search = $line | Select-String -Pattern '<th>(.*?)</th>' -AllMatches
                ForEach ($match in $search.Matches)
                {
                    If ($match.Groups[1].Value -eq 'check'  ) { $func  = $count }
                    $count++
                }
                If ($func -eq $search.Matches.Count) { Break }

                # Rename headers to language specific values
                $line = $line.Replace('<th>name</th>',    "<th>$($script:lang['HTML_Name']   )</th>")
                $line = $line.Replace('<th>check</th>',   "<th>$($script:lang['HTML_Check']  )</th>")
                $line = $line.Replace('<th>result</th>',  "<th>$($script:lang['HTML_Result'] )</th>")
                $line = $line.Replace('<th>message</th>', "<th>$($script:lang['HTML_Message'])</th>")
                $line = $line.Replace('<th>data</th>',    "<th>$($script:lang['HTML_Data']   )</th>")
            }

            [string]$sectionRow = ''
            If ($line -match '<tr><td')
            {
                $search = $line | Select-String -Pattern '<td(.*?)>(.*?)</td>' -AllMatches
                If ($search.Matches.Count -ne 0)
                {
                    Try
                    {
                        # Rename "check" names
                        [string]$old = $search.Matches[$func].Groups[2].Value
                        If (($old.StartsWith('c-') -eq $true) -or ($old.StartsWith('f-') -eq $true))
                        {
                            [string]$new = $old.Substring(0,8)
                            $line = $line.Replace($old, $new)
                        }

                        # Add line breaks for long lines in results - If the check supports it.
                        $line = $line.Replace(',#', ',<br/>')

                        # Add section headers
                        Try { $sectionNew = ($search.Matches[$func].Groups[2].Value).Substring(2, 3).Replace('-', '') } Catch { $sectionNew = '' }
                        If ($sectionNew -ne $sectionOld)
                        {
                            $sectionOld = $sectionNew
                            [string]$selctionName = $script:sections[$sectionNew]
                            $sectionRow = '<tr><td class="sectionRow" colspan="5">{0}</td></tr>' -f $selctionName
                        }
                        Else { $sectionRow = '' }
                    }
                    Catch { }
                }
            }
            ElseIf ($line.StartsWith('</table>') -eq $true) { $sectionRow = '<tr><td class="sectionRow" colspan="5">&nbsp;</td>' }

            Write-Output $sectionRow$line
         }
    }
    End { }
}

Function Set-CellColour
{
    Param ( [Object[]]$InputObject, [string]$Filter, [switch]$Row )
    Begin
    {
        $Property = ($Filter.Split(' ')[0])
        $Colour   = ($Filter.Split(' ')[2]).Substring(1,1).ToLower()

        If ($Filter.ToUpper().IndexOf($Property.ToUpper()) -ge 0)
        {
            $Filter = $Filter.ToUpper().Replace($Property.ToUpper(), '$value')
            Try { [scriptblock]$Filter = [scriptblock]::Create($Filter) } Catch { Exit }
        } Else { Exit }
    }
    
    Process
    {
        ForEach ($input In $InputObject)
        {
            [string]$line = $input
            If ($line.IndexOf('<tr><th') -ge 0)
            {
                [int]$index = 0
                [int]$count = 0
                [int]$func  = 0
                $search = $line | Select-String -Pattern '<th>(.*?)</th>' -AllMatches
                ForEach ($match in $search.Matches)
                {
                    If ($match.Groups[1].Value -eq 'check'  ) { $func  = $count }
                    If ($match.Groups[1].Value -eq $Property) { $index = $count }
                    $count++
                }
                If ($index -eq $search.Matches.Count) { Break }
            }

            If ($line -match '<tr><td')
            {
                $search = $line | Select-String -Pattern '<td>(.*?)</td>' -AllMatches
                If (($search -ne $null) -and ($search.Matches.Count -ne 0))
                {
                    Try { [string]$check = ($search.Matches[$func].Groups[1].Value).Substring(2, 6).Replace('-', '') } Catch { [string]$check = '' }
                    $value = $search.Matches[$index].Groups[1].Value -as [double]
                    If ($value -eq $null) { $value = $search.Matches[$index].Groups[1].Value }
                    If (Invoke-Command $Filter)
                    {
                        If ($Row -eq $true) { $line = $line.Replace('<td>', '<td class="e">') }    # There was an error with this server
                        Else
                        {
                            # Insert HTML hover help
                            [string]$note = '' + $value + '</td>'
                            If (-not $SkipHTMLHelp)
                            {
                                [string]$help = Add-HoverHelp -inputLine $line -check $check
                                If ($help -ne '') { $note = '<div class="help">{0}</div>{1}</td>' -f $help, $value }
                            }

                            # Change result status cell colour
                            $line = $line.Replace($search.Matches[$index].Value, ('<td class="{0} note">{1}' -f $Colour, $note))
                        }
                    }
                    Remove-Variable value -ErrorAction SilentlyContinue
                }
            }
            Write-Output $line
        }
    }

    End
    { Remove-Variable line, check, index, func, search, match -ErrorAction SilentlyContinue }
}

Function Add-HoverHelp
{
    Param ([string]$inputLine, [string]$check)
    [string]$help = ''
    If ($script:qahelp[$check])
    {
        Try
        {
            [xml]$xml  = $script:qahelp[$check]
                 $help = '<li><span>{0}<br/>{1}</span><span>{2}</span></li><br/>' -f $script:sections[$check.Substring(0,3)], $check.Substring(3, 2), $xml.xml.description
            If ($xml.xml.ChildNodes.ToString() -like '*pass*'   ) { $help += '<li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Pass'],           ($xml.xml.pass)    }
            If ($xml.xml.ChildNodes.ToString() -like '*warning*') { $help += '<li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Warning'],        ($xml.xml.warning) }
            If ($xml.xml.ChildNodes.ToString() -like '*fail*'   ) { $help += '<li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Fail'],           ($xml.xml.fail)    }
            If ($xml.xml.ChildNodes.ToString() -like '*manual*' ) { $help += '<li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Manual'],         ($xml.xml.manual)  }
            If ($xml.xml.ChildNodes.ToString() -like '*na*'     ) { $help += '<li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Not-Applicable'], ($xml.xml.na)      }
            $help += '<br/><li><span>{0}</span><span>{1}</span></li>' -f $script:lang['Applies-To'], ($xml.xml.applies).Replace(', ','<br/>')
        }
        Catch { $help = '' } # No help if XML is invalid
    }
    Return $help
}

###################################################################################################

Function Test-Port
{
    Param ( [string]$serverName )
    $tcp  = New-Object System.Net.Sockets.TcpClient
    $iar  = $tcp.BeginConnect($serverName, 135, $null, $null)
    $wait = $iar.AsyncWaitHandle.WaitOne(3000, $false)

    $failed = $false
    If (-not $wait)
    {
        # Connection timeout
        $tcp.Close()
        Return $false
    }
    Else
    {
        # Close the connection and report the error if there is one
        $error.Clear()
        $tcp.EndConnect($iar) | Out-Null
        If (!$?) { $failed = $true }
        $tcp.Close()
    }

    Remove-Variable tcp, iar, wait -ErrorAction SilentlyContinue
    If ($failed -eq $true) { Return $false } Else { Return $true }
}

Function Write-Colr
{
    Param ([String[]]$Text,[ConsoleColor[]]$Colour,[Switch]$NoNewline=$false)
    For ([int]$i = 0; $i -lt $Text.Length; $i++) { Write-Host $Text[$i] -Foreground $Colour[$i] -NoNewLine }
    If ($NoNewline -eq $false) { Write-Host '' }
}

Function Write-Header
{
    Param ([string]$Message,[int]$Width); $underline=''.PadLeft($Width-16,'─')
    $q=('╔═══════════╗    ','','','','║           ║    ','','','','║  ','█▀█ █▀█','  ║    ','','║  ','█▄█ █▀█','  ║    ','','║  ',' ▀     ','  ║    ','',
        '║  ',' CHECK ','  ║','  ██','║  ','       ','  ║',' ██ ','║  ','      ','','██▄ ██  ','╚════════','','',' ▀██▀ ')
    $s=('QA Script Engine','Written by Mike @ My Random Thoughts','support@myrandomthoughts.co.uk','','','',$Message,$version,$underline)
    [System.ConsoleColor[]]$c=('White','Gray','Gray','Red','Cyan','Red','Green','Yellow','Yellow');Write-Host ''
    For ($i=0;$i-lt$q.Length;$i+=4) { Write-Colr '  ',$q[$i],$q[$i+1],$q[$i+2],$q[$i+3],$s[$i/4].PadLeft($Width-19) -Colour Yellow,White,Cyan,White,Green,$c[$i/4] }
    Write-Host ''
}

Function DivLine
{
    Param ([int]$Width);[string]$divLine=' ';For($i=0;$i-lt$Width;$i++){$divLine+='─'}
    Return $divLine
}

###################################################################################################

[int]      $script:ccTasks        =   5    # Number of concurrent tasks to perform (the higher the number the more resources you need)
[int]      $script:waitTime       = 100    # Time to wait between starting new tasks (milliseconds)
[int]      $script:checkTimeout   =  60    # Time to wait for each task to complete (seconds)
[int]      $script:screenwidth    = 120    #
[int]      $script:failurecount   =   0    #
[array]    $script:results        = @()    #
[array]    $script:servers        = @()    #
[hashtable]$script:sections       = @{'acc' = $script:lang['Accounts'];       #
                                      'com' = $script:lang['Compliance'];      # 
                                      'drv' = $script:lang['Drives'];          # List of sections, matched
                                      'hvh' = $script:lang['HyperV-Host'];     # with the check short name
                                      'net' = $script:lang['Network'];         # 
                                      'reg' = $script:lang['Regional'];        #
                                      'sec' = $script:lang['Security'];        # These are displayed in
                                      'sys' = $script:lang['System'];          # the HTML report file
                                      'vhv' = $script:lang['VMs-HyperV'];      #
                                      'vmw' = $script:lang['VMs-VMware'];     #
                                     }
$tt = [System.Diagnostics.StopWatch]::StartNew()
Check-CommandLine
Start-QAProcess
Show-Results

$tt.Stop()
Write-Host '  '$script:lang['TimeTaken'] $tt.Elapsed.Minutes 'min,' $tt.Elapsed.Seconds 'sec' -ForegroundColor White
Write-Host '  '$script:lang['ReportsLocated'] $script:qaOutput                                -ForegroundColor White
Write-Host (DivLine -Width $script:screenwidth)                                               -ForegroundColor Yellow
Write-Host ''
Write-Host ''
